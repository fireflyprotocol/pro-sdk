/* tslint:disable */
/* eslint-disable */
/**
 * Bluefin API
 * Bluefin API
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface Account
 */
export interface Account {
    /**
     * 
     * @type {TradingFees}
     * @memberof Account
     */
    'tradingFees': TradingFees;
    /**
     * If the user can trade.
     * @type {boolean}
     * @memberof Account
     */
    'canTrade': boolean;
    /**
     * If the current user can deposit to the account.
     * @type {boolean}
     * @memberof Account
     */
    'canDeposit': boolean;
    /**
     * If the current user can withdraw from the account.
     * @type {boolean}
     * @memberof Account
     */
    'canWithdraw': boolean;
    /**
     * Total effective balance in USD (e9 format).
     * @type {string}
     * @memberof Account
     */
    'crossEffectiveBalanceE9': string;
    /**
     * The sum of initial margin required across all cross positions (e9 format).
     * @type {string}
     * @memberof Account
     */
    'crossMarginRequiredE9': string;
    /**
     * The sum of initial margin required across all open orders (e9 format).
     * @type {string}
     * @memberof Account
     */
    'totalOrderMarginRequiredE9': string;
    /**
     * The amount of margin available to open new positions and orders (e9 format).
     * @type {string}
     * @memberof Account
     */
    'marginAvailableE9': string;
    /**
     * The sum of maintenance margin required across all cross positions (e9 format).
     * @type {string}
     * @memberof Account
     */
    'crossMaintenanceMarginRequiredE9': string;
    /**
     * The amount of margin available before liquidation (e9 format).
     * @type {string}
     * @memberof Account
     */
    'crossMaintenanceMarginAvailableE9': string;
    /**
     * The ratio of the maintenance margin required to the account value (e9 format).
     * @type {string}
     * @memberof Account
     */
    'crossMaintenanceMarginRatioE9': string;
    /**
     * The leverage of the account (e9 format).
     * @type {string}
     * @memberof Account
     */
    'crossLeverageE9': string;
    /**
     * Total unrealized profit (e9 format).
     * @type {string}
     * @memberof Account
     */
    'totalUnrealizedPnlE9': string;
    /**
     * Unrealized profit of cross positions (e9 format).
     * @type {string}
     * @memberof Account
     */
    'crossUnrealizedPnlE9': string;
    /**
     * An implicitly negative number that sums only the losses of all cross positions.
     * @type {string}
     * @memberof Account
     */
    'crossUnrealizedLossE9': string;
    /**
     * The total value of the cross account, combining the cross effective balance and unrealized PnL across all cross positions, and subtracting any pending funding payments on any cross position. 
     * @type {string}
     * @memberof Account
     */
    'crossAccountValueE9': string;
    /**
     * The total value of the account, combining the total effective balance and unrealized PnL across all positions, and subtracting any pending funding payments on any position. 
     * @type {string}
     * @memberof Account
     */
    'totalAccountValueE9': string;
    /**
     * Last update time in milliseconds since Unix epoch.
     * @type {number}
     * @memberof Account
     */
    'updatedAtMillis': number;
    /**
     * 
     * @type {Array<Asset>}
     * @memberof Account
     */
    'assets': Array<Asset>;
    /**
     * 
     * @type {Array<Position>}
     * @memberof Account
     */
    'positions': Array<Position>;
    /**
     * The accounts that are authorized to trade on behalf of the current account.
     * @type {Array<string>}
     * @memberof Account
     */
    'authorizedAccounts': Array<string>;
    /**
     * The address of the account.
     * @type {string}
     * @memberof Account
     */
    'accountAddress': string;
}
/**
 * Aggregated details about a trade in the account.
 * @export
 * @interface AccountAggregatedTradeUpdate
 */
export interface AccountAggregatedTradeUpdate {
    /**
     * 
     * @type {Trade}
     * @memberof AccountAggregatedTradeUpdate
     */
    'trade': Trade;
}
/**
 * 
 * @export
 * @interface AccountAuthorizationRequest
 */
export interface AccountAuthorizationRequest {
    /**
     * 
     * @type {AccountAuthorizationRequestSignedFields}
     * @memberof AccountAuthorizationRequest
     */
    'signedFields': AccountAuthorizationRequestSignedFields;
    /**
     * The signature of the request, encoded from the signedFields
     * @type {string}
     * @memberof AccountAuthorizationRequest
     */
    'signature': string;
}
/**
 * 
 * @export
 * @interface AccountAuthorizationRequestSignedFields
 */
export interface AccountAuthorizationRequestSignedFields {
    /**
     * The account address of the parent account that is authorizing/deauthorizing this account
     * @type {string}
     * @memberof AccountAuthorizationRequestSignedFields
     */
    'accountAddress': string;
    /**
     * The address of the account that should be authorized/deauthorized
     * @type {string}
     * @memberof AccountAuthorizationRequestSignedFields
     */
    'authorizedAccountAddress': string;
    /**
     * The random generated salt. Should always be a number
     * @type {string}
     * @memberof AccountAuthorizationRequestSignedFields
     */
    'salt': string;
    /**
     * the ID of the internal datastore for the target network
     * @type {string}
     * @memberof AccountAuthorizationRequestSignedFields
     */
    'idsId': string;
    /**
     * The timestamp when the request was signed
     * @type {number}
     * @memberof AccountAuthorizationRequestSignedFields
     */
    'signedAtMillis': number;
}
/**
 * Details about a failure during an account command execution.
 * @export
 * @interface AccountCommandFailureUpdate
 */
export interface AccountCommandFailureUpdate {
    /**
     * The reason for the failure.
     * @type {string}
     * @memberof AccountCommandFailureUpdate
     */
    'reason': string;
    /**
     * The type of command that failed.
     * @type {string}
     * @memberof AccountCommandFailureUpdate
     */
    'failedCommandType': string;
    /**
     * The timestamp when the command failed in milliseconds.
     * @type {number}
     * @memberof AccountCommandFailureUpdate
     */
    'failedAtMillis': number;
}
/**
 * Represents the type of account data stream.
 * @export
 * @enum {string}
 */

export const AccountDataStream = {
    AccountOrderUpdate: 'AccountOrderUpdate',
    AccountTradeUpdate: 'AccountTradeUpdate',
    AccountAggregatedTradeUpdate: 'AccountAggregatedTradeUpdate',
    AccountPositionUpdate: 'AccountPositionUpdate',
    AccountUpdate: 'AccountUpdate',
    AccountTransactionUpdate: 'AccountTransactionUpdate',
    AccountCommandFailureUpdate: 'AccountCommandFailureUpdate'
} as const;

export type AccountDataStream = typeof AccountDataStream[keyof typeof AccountDataStream];


/**
 * The reason for the account-related event.
 * @export
 * @enum {string}
 */

export const AccountEventReason = {
    Deposit: 'Deposit',
    Withdraw: 'Withdraw',
    OrderCreated: 'OrderCreated',
    OrderMatched: 'OrderMatched',
    OrderCancelled: 'OrderCancelled',
    OrdersForMarketCancelled: 'OrdersForMarketCancelled',
    LeverageUpdated: 'LeverageUpdated',
    IsolatedMarginUpdated: 'IsolatedMarginUpdated',
    FundingRatePayment: 'FundingRatePayment'
} as const;

export type AccountEventReason = typeof AccountEventReason[keyof typeof AccountEventReason];


/**
 * The type of account-related event.
 * @export
 * @enum {string}
 */

export const AccountEventType = {
    AccountUpdate: 'AccountUpdate',
    AccountTradeUpdate: 'AccountTradeUpdate',
    AccountAggregatedTradeUpdate: 'AccountAggregatedTradeUpdate',
    AccountOrderUpdate: 'AccountOrderUpdate',
    AccountPositionUpdate: 'AccountPositionUpdate',
    AccountTransactionUpdate: 'AccountTransactionUpdate',
    AccountLeverageFailureUpdate: 'AccountLeverageFailureUpdate'
} as const;

export type AccountEventType = typeof AccountEventType[keyof typeof AccountEventType];


/**
 * 
 * @export
 * @interface AccountFundingRateHistory
 */
export interface AccountFundingRateHistory {
    /**
     * 
     * @type {Array<AccountFundingRateHistoryData>}
     * @memberof AccountFundingRateHistory
     */
    'data': Array<AccountFundingRateHistoryData>;
}
/**
 * 
 * @export
 * @interface AccountFundingRateHistoryData
 */
export interface AccountFundingRateHistoryData {
    /**
     * Payment amount in e9 format.
     * @type {string}
     * @memberof AccountFundingRateHistoryData
     */
    'paymentAmountE9': string;
    /**
     * 
     * @type {PositionSide}
     * @memberof AccountFundingRateHistoryData
     */
    'positionSide': PositionSide;
    /**
     * Funding rate value (e9 format).
     * @type {string}
     * @memberof AccountFundingRateHistoryData
     */
    'rateE9': string;
    /**
     * Market address.
     * @type {string}
     * @memberof AccountFundingRateHistoryData
     */
    'symbol': string;
    /**
     * Execution timestamp in milliseconds since Unix epoch.
     * @type {number}
     * @memberof AccountFundingRateHistoryData
     */
    'executedAtMillis': number;
    /**
     * Computed timestamp in milliseconds since Unix epoch.
     * @type {number}
     * @memberof AccountFundingRateHistoryData
     */
    'computedAtMillis': number;
}


/**
 * 
 * @export
 * @interface AccountMarketPreference
 */
export interface AccountMarketPreference {
    /**
     * 
     * @type {MarginType}
     * @memberof AccountMarketPreference
     */
    'marginType'?: MarginType;
    /**
     * User set leverage (e.g., 10x).
     * @type {number}
     * @memberof AccountMarketPreference
     */
    'setLeverage'?: number;
}


/**
 * @type AccountOrderUpdate
 * A message containing order update information.
 * @export
 */
export type AccountOrderUpdate = ActiveOrderUpdate | OrderCancellationUpdate;

/**
 * 
 * @export
 * @interface AccountPositionLeverageUpdateRequest
 */
export interface AccountPositionLeverageUpdateRequest {
    /**
     * 
     * @type {AccountPositionLeverageUpdateRequestSignedFields}
     * @memberof AccountPositionLeverageUpdateRequest
     */
    'signedFields': AccountPositionLeverageUpdateRequestSignedFields;
    /**
     * The signature of the request, encoded from the signedFields
     * @type {string}
     * @memberof AccountPositionLeverageUpdateRequest
     */
    'signature': string;
}
/**
 * 
 * @export
 * @interface AccountPositionLeverageUpdateRequestSignedFields
 */
export interface AccountPositionLeverageUpdateRequestSignedFields {
    /**
     * The Account Address from which to update leverage
     * @type {string}
     * @memberof AccountPositionLeverageUpdateRequestSignedFields
     */
    'accountAddress': string;
    /**
     * Symbol of the perpetual of the positions for which to update the leverage
     * @type {string}
     * @memberof AccountPositionLeverageUpdateRequestSignedFields
     */
    'symbol': string;
    /**
     * The leverage to set for the account positions (Must be a number in base e9)
     * @type {string}
     * @memberof AccountPositionLeverageUpdateRequestSignedFields
     */
    'leverageE9': string;
    /**
     * The random generated SALT. Should always be a number
     * @type {string}
     * @memberof AccountPositionLeverageUpdateRequestSignedFields
     */
    'salt': string;
    /**
     * the ID of the internal datastore for the target network
     * @type {string}
     * @memberof AccountPositionLeverageUpdateRequestSignedFields
     */
    'idsId': string;
    /**
     * The timestamp in millis at which the request was signed
     * @type {number}
     * @memberof AccountPositionLeverageUpdateRequestSignedFields
     */
    'signedAtMillis': number;
}
/**
 * Details about an account position update.
 * @export
 * @interface AccountPositionUpdate
 */
export interface AccountPositionUpdate {
    /**
     * The symbol of the market.
     * @type {string}
     * @memberof AccountPositionUpdate
     */
    'symbol': string;
    /**
     * The average entry price for the position.
     * @type {string}
     * @memberof AccountPositionUpdate
     */
    'avgEntryPriceE9': string;
    /**
     * The leverage applied to the position.
     * @type {string}
     * @memberof AccountPositionUpdate
     */
    'clientSetLeverageE9': string;
    /**
     * The liquidation price of the position.
     * @type {string}
     * @memberof AccountPositionUpdate
     */
    'liquidationPriceE9': string;
    /**
     * The current mark price of the position.
     * @type {string}
     * @memberof AccountPositionUpdate
     */
    'markPriceE9': string;
    /**
     * The notional value of the position.
     * @type {string}
     * @memberof AccountPositionUpdate
     */
    'notionalValueE9': string;
    /**
     * The size of the position.
     * @type {string}
     * @memberof AccountPositionUpdate
     */
    'sizeE9': string;
    /**
     * The unrealized profit and loss for the position.
     * @type {string}
     * @memberof AccountPositionUpdate
     */
    'unrealizedPnlE9': string;
    /**
     * 
     * @type {PositionSide}
     * @memberof AccountPositionUpdate
     */
    'side': PositionSide;
    /**
     * The margin required for the position.
     * @type {string}
     * @memberof AccountPositionUpdate
     */
    'marginRequiredE9': string;
    /**
     * The maintenance margin required for the position.
     * @type {string}
     * @memberof AccountPositionUpdate
     */
    'maintenanceMarginE9': string;
    /**
     * Indicates if the position is isolated.
     * @type {boolean}
     * @memberof AccountPositionUpdate
     */
    'isIsolated': boolean;
    /**
     * The isolated margin applied to the position.
     * @type {string}
     * @memberof AccountPositionUpdate
     */
    'isolatedMarginE9': string;
    /**
     * The last update time for the position in milliseconds.
     * @type {number}
     * @memberof AccountPositionUpdate
     */
    'updatedAtMillis': number;
}


/**
 * 
 * @export
 * @interface AccountPreference
 */
export interface AccountPreference {
    /**
     * User preferred language.
     * @type {string}
     * @memberof AccountPreference
     */
    'language'?: string;
    /**
     * User preferred theme.
     * @type {string}
     * @memberof AccountPreference
     */
    'theme'?: string;
    /**
     * 
     * @type {Array<AccountMarketPreference>}
     * @memberof AccountPreference
     */
    'market'?: Array<AccountMarketPreference>;
}
/**
 * Account stream message for account-related events. The payload depends on the event type. 
 * @export
 * @interface AccountStreamMessage
 */
export interface AccountStreamMessage {
    /**
     * 
     * @type {AccountEventType}
     * @memberof AccountStreamMessage
     */
    'event': AccountEventType;
    /**
     * 
     * @type {AccountEventReason}
     * @memberof AccountStreamMessage
     */
    'reason': AccountEventReason;
    /**
     * 
     * @type {AccountStreamMessagePayload}
     * @memberof AccountStreamMessage
     */
    'payload': AccountStreamMessagePayload;
}


/**
 * @type AccountStreamMessagePayload
 * The payload of the message, which varies based on the event type.
 * @export
 */
export type AccountStreamMessagePayload = AccountAggregatedTradeUpdate | AccountCommandFailureUpdate | AccountOrderUpdate | AccountPositionUpdate | AccountTradeUpdate | AccountTransactionUpdate | AccountUpdate;

/**
 * Subscription message for account data streams.
 * @export
 * @interface AccountSubscriptionMessage
 */
export interface AccountSubscriptionMessage {
    /**
     * The authentication token for the account.
     * @type {string}
     * @memberof AccountSubscriptionMessage
     */
    'authToken'?: string;
    /**
     * 
     * @type {SubscriptionType}
     * @memberof AccountSubscriptionMessage
     */
    'method': SubscriptionType;
    /**
     * List of account data streams to subscribe or unsubscribe from.
     * @type {Array<AccountDataStream>}
     * @memberof AccountSubscriptionMessage
     */
    'dataStreams': Array<AccountDataStream>;
}


/**
 * Details about a trade in the account.
 * @export
 * @interface AccountTradeUpdate
 */
export interface AccountTradeUpdate {
    /**
     * 
     * @type {Trade}
     * @memberof AccountTradeUpdate
     */
    'trade': Trade;
}
/**
 * Details about a transaction in the account.
 * @export
 * @interface AccountTransactionUpdate
 */
export interface AccountTransactionUpdate {
    /**
     * The symbol of the market.
     * @type {string}
     * @memberof AccountTransactionUpdate
     */
    'symbol'?: string;
    /**
     * 
     * @type {TransactionType}
     * @memberof AccountTransactionUpdate
     */
    'transactionType': TransactionType;
    /**
     * The amount of the transaction in scientific notation with 9 decimal places.
     * @type {string}
     * @memberof AccountTransactionUpdate
     */
    'amountE9': string;
    /**
     * The symbol of the asset.
     * @type {string}
     * @memberof AccountTransactionUpdate
     */
    'assetSymbol'?: string;
    /**
     * The trade ID associated with the transaction.
     * @type {string}
     * @memberof AccountTransactionUpdate
     */
    'tradeId'?: string;
    /**
     * The timestamp when the transaction was executed in milliseconds.
     * @type {number}
     * @memberof AccountTransactionUpdate
     */
    'executedAtMillis': number;
}


/**
 * Account information for the data stream.
 * @export
 * @interface AccountUpdate
 */
export interface AccountUpdate {
    /**
     * 
     * @type {TradingFees}
     * @memberof AccountUpdate
     */
    'tradingFees'?: TradingFees;
    /**
     * If the user can trade.
     * @type {boolean}
     * @memberof AccountUpdate
     */
    'canTrade': boolean;
    /**
     * If the current user can deposit to the account.
     * @type {boolean}
     * @memberof AccountUpdate
     */
    'canDeposit': boolean;
    /**
     * If the current user can withdraw from the account.
     * @type {boolean}
     * @memberof AccountUpdate
     */
    'canWithdraw': boolean;
    /**
     * Total effective balance in USD (e9 format).
     * @type {string}
     * @memberof AccountUpdate
     */
    'crossEffectiveBalanceE9': string;
    /**
     * The sum of initial margin required across all cross positions (e9 format).
     * @type {string}
     * @memberof AccountUpdate
     */
    'crossMarginRequiredE9': string;
    /**
     * The sum of initial margin required across all open orders (e9 format).
     * @type {string}
     * @memberof AccountUpdate
     */
    'totalOrderMarginRequiredE9': string;
    /**
     * The amount of margin available to open new positions and orders (e9 format).
     * @type {string}
     * @memberof AccountUpdate
     */
    'marginAvailableE9': string;
    /**
     * The sum of maintenance margin required across all cross positions (e9 format).
     * @type {string}
     * @memberof AccountUpdate
     */
    'crossMaintenanceMarginRequiredE9': string;
    /**
     * The amount of margin available before liquidation (e9 format).
     * @type {string}
     * @memberof AccountUpdate
     */
    'crossMaintenanceMarginAvailableE9': string;
    /**
     * The ratio of the maintenance margin required to the account value (e9 format).
     * @type {string}
     * @memberof AccountUpdate
     */
    'crossMaintenanceMarginRatioE9': string;
    /**
     * The leverage of the account (e9 format).
     * @type {string}
     * @memberof AccountUpdate
     */
    'crossLeverageE9': string;
    /**
     * Total unrealized profit (e9 format).
     * @type {string}
     * @memberof AccountUpdate
     */
    'totalUnrealizedPnlE9': string;
    /**
     * Unrealized profit of cross positions (e9 format).
     * @type {string}
     * @memberof AccountUpdate
     */
    'crossUnrealizedPnlE9': string;
    /**
     * An implicitly negative number that sums only the losses of all cross positions.
     * @type {string}
     * @memberof AccountUpdate
     */
    'crossUnrealizedLossE9': string;
    /**
     * The total value of the cross account, combining the cross effective balance and unrealized PnL across all cross positions, and subtracting any pending funding payments on any cross position. 
     * @type {string}
     * @memberof AccountUpdate
     */
    'crossAccountValueE9': string;
    /**
     * The total value of the account, combining the total effective balance and unrealized PnL across all positions, and subtracting any pending funding payments on any position. 
     * @type {string}
     * @memberof AccountUpdate
     */
    'totalAccountValueE9': string;
    /**
     * Last update time in milliseconds since Unix epoch.
     * @type {number}
     * @memberof AccountUpdate
     */
    'updatedAtMillis': number;
    /**
     * 
     * @type {Array<Asset>}
     * @memberof AccountUpdate
     */
    'assets': Array<Asset>;
    /**
     * The accounts that are authorized to trade on behalf of the current account.
     * @type {Array<string>}
     * @memberof AccountUpdate
     */
    'authorizedAccounts': Array<string>;
}
/**
 * Information about an order update.
 * @export
 * @interface ActiveOrderUpdate
 */
export interface ActiveOrderUpdate {
    /**
     * The unique hash of the order.
     * @type {string}
     * @memberof ActiveOrderUpdate
     */
    'orderHash': string;
    /**
     * The client-provided order ID.
     * @type {string}
     * @memberof ActiveOrderUpdate
     */
    'clientOrderId'?: string;
    /**
     * The symbol of the market.
     * @type {string}
     * @memberof ActiveOrderUpdate
     */
    'symbol': string;
    /**
     * The address of the account.
     * @type {string}
     * @memberof ActiveOrderUpdate
     */
    'accountAddress': string;
    /**
     * The price of the order in scientific notation with 9 decimal places.
     * @type {string}
     * @memberof ActiveOrderUpdate
     */
    'priceE9': string;
    /**
     * The quantity of the order in scientific notation with 9 decimal places.
     * @type {string}
     * @memberof ActiveOrderUpdate
     */
    'quantityE9': string;
    /**
     * The filled quantity of the order in scientific notation with 9 decimal places.
     * @type {string}
     * @memberof ActiveOrderUpdate
     */
    'filledQuantityE9': string;
    /**
     * 
     * @type {TradeSide}
     * @memberof ActiveOrderUpdate
     */
    'side': TradeSide;
    /**
     * The leverage of the order in scientific notation with 9 decimal places.
     * @type {string}
     * @memberof ActiveOrderUpdate
     */
    'leverageE9': string;
    /**
     * Indicates if the order is isolated.
     * @type {boolean}
     * @memberof ActiveOrderUpdate
     */
    'isIsolated': boolean;
    /**
     * A unique salt for the order.
     * @type {string}
     * @memberof ActiveOrderUpdate
     */
    'salt': string;
    /**
     * The expiration timestamp of the order in milliseconds.
     * @type {number}
     * @memberof ActiveOrderUpdate
     */
    'expiresAtMillis': number;
    /**
     * The signing timestamp of the order in milliseconds.
     * @type {number}
     * @memberof ActiveOrderUpdate
     */
    'signedAtMillis': number;
    /**
     * 
     * @type {OrderType}
     * @memberof ActiveOrderUpdate
     */
    'type': OrderType;
    /**
     * Indicates if the order is reduce-only.
     * @type {boolean}
     * @memberof ActiveOrderUpdate
     */
    'reduceOnly': boolean;
    /**
     * Indicates if the order is post-only.
     * @type {boolean}
     * @memberof ActiveOrderUpdate
     */
    'postOnly': boolean;
    /**
     * 
     * @type {OrderTimeInForce}
     * @memberof ActiveOrderUpdate
     */
    'timeInForce': OrderTimeInForce;
    /**
     * The trigger price for stop-limit or stop-market orders.
     * @type {string}
     * @memberof ActiveOrderUpdate
     */
    'triggerPriceE9'?: string;
    /**
     * 
     * @type {OrderStatus}
     * @memberof ActiveOrderUpdate
     */
    'status': OrderStatus;
    /**
     * 
     * @type {SelfTradePreventionType}
     * @memberof ActiveOrderUpdate
     */
    'selfTradePreventionType': SelfTradePreventionType;
    /**
     * The timestamp when the order was placed, in milliseconds.
     * @type {number}
     * @memberof ActiveOrderUpdate
     */
    'createdAtMillis': number;
    /**
     * The timestamp of the last update of the order in milliseconds.
     * @type {number}
     * @memberof ActiveOrderUpdate
     */
    'updatedAtMillis': number;
}


/**
 * 
 * @export
 * @interface AdjustIsolatedMarginRequest
 */
export interface AdjustIsolatedMarginRequest {
    /**
     * 
     * @type {AdjustIsolatedMarginRequestSignedFields}
     * @memberof AdjustIsolatedMarginRequest
     */
    'signedFields': AdjustIsolatedMarginRequestSignedFields;
    /**
     * The signature of the request, encoded from the signedFields
     * @type {string}
     * @memberof AdjustIsolatedMarginRequest
     */
    'signature': string;
}
/**
 * 
 * @export
 * @interface AdjustIsolatedMarginRequestSignedFields
 */
export interface AdjustIsolatedMarginRequestSignedFields {
    /**
     * the ID of the internal datastore for the target network
     * @type {string}
     * @memberof AdjustIsolatedMarginRequestSignedFields
     */
    'idsId': string;
    /**
     * The account address of the account for which to adjust margin
     * @type {string}
     * @memberof AdjustIsolatedMarginRequestSignedFields
     */
    'accountAddress': string;
    /**
     * The symbol of the isolated position for which to adjust margin
     * @type {string}
     * @memberof AdjustIsolatedMarginRequestSignedFields
     */
    'symbol': string;
    /**
     * 
     * @type {AdjustMarginOperation}
     * @memberof AdjustIsolatedMarginRequestSignedFields
     */
    'operation': AdjustMarginOperation;
    /**
     * The quantity of margin to adjust for the isolated position
     * @type {string}
     * @memberof AdjustIsolatedMarginRequestSignedFields
     */
    'quantityE9': string;
    /**
     * The random generated SALT. Should always be a number
     * @type {string}
     * @memberof AdjustIsolatedMarginRequestSignedFields
     */
    'salt': string;
    /**
     * The timestamp in millis at which the request was signed
     * @type {number}
     * @memberof AdjustIsolatedMarginRequestSignedFields
     */
    'signedAtMillis': number;
}


/**
 * The operation to perform on the margin
 * @export
 * @enum {string}
 */

export const AdjustMarginOperation = {
    Add: 'ADD',
    Subtract: 'SUBTRACT'
} as const;

export type AdjustMarginOperation = typeof AdjustMarginOperation[keyof typeof AdjustMarginOperation];


/**
 * Details about an asset in the account.
 * @export
 * @interface Asset
 */
export interface Asset {
    /**
     * The symbol of the asset.
     * @type {string}
     * @memberof Asset
     */
    'symbol': string;
    /**
     * The quantity of the asset.
     * @type {string}
     * @memberof Asset
     */
    'quantityE9': string;
    /**
     * The effective balance of the asset.
     * @type {string}
     * @memberof Asset
     */
    'effectiveBalanceE9': string;
    /**
     * The maximum quantity that can be withdrawn.
     * @type {string}
     * @memberof Asset
     */
    'maxWithdrawQuantityE9': string;
    /**
     * The timestamp of the last update in milliseconds.
     * @type {number}
     * @memberof Asset
     */
    'updatedAtMillis': number;
}
/**
 * 
 * @export
 * @interface AssetConfig
 */
export interface AssetConfig {
    /**
     * The bank address of the asset.
     * @type {string}
     * @memberof AssetConfig
     */
    'assetType': string;
    /**
     * Asset symbol.
     * @type {string}
     * @memberof AssetConfig
     */
    'symbol': string;
    /**
     * Default precision for rendering this asset.
     * @type {number}
     * @memberof AssetConfig
     */
    'decimals': number;
    /**
     * Weight applied to asset to use as margin in Multi-Assets mode.
     * @type {string}
     * @memberof AssetConfig
     */
    'weight': string;
    /**
     * Indicates if the asset can be used as margin in Multi-Assets mode.
     * @type {boolean}
     * @memberof AssetConfig
     */
    'marginAvailable': boolean;
}
/**
 * 
 * @export
 * @interface CampaignMetadata
 */
export interface CampaignMetadata {
    /**
     * 
     * @type {string}
     * @memberof CampaignMetadata
     */
    'Status': CampaignMetadataStatusEnum;
    /**
     * Name of the campaign.
     * @type {string}
     * @memberof CampaignMetadata
     */
    'CampaignName': string;
    /**
     * Name of the parent campaign.
     * @type {string}
     * @memberof CampaignMetadata
     */
    'ParentCampaignName': string;
    /**
     * Time in milliseconds for campaign start date.
     * @type {number}
     * @memberof CampaignMetadata
     */
    'StartDate': number;
    /**
     * Time in milliseconds for campaign end date.
     * @type {number}
     * @memberof CampaignMetadata
     */
    'EndDate': number;
}

export const CampaignMetadataStatusEnum = {
    Active: 'ACTIVE',
    Inactive: 'INACTIVE'
} as const;

export type CampaignMetadataStatusEnum = typeof CampaignMetadataStatusEnum[keyof typeof CampaignMetadataStatusEnum];

/**
 * 
 * @export
 * @interface CampaignRewards
 */
export interface CampaignRewards {
    /**
     * 
     * @type {UserCampaignRewards}
     * @memberof CampaignRewards
     */
    'rewards'?: UserCampaignRewards;
}
/**
 * Cancelling Orders for a specific symbol. If order hashes are not specified, all orders are canceled for this symbol
 * @export
 * @interface CancelOrdersRequest
 */
export interface CancelOrdersRequest {
    /**
     * The symbol of the perpetual for which to cancel orders.
     * @type {string}
     * @memberof CancelOrdersRequest
     */
    'symbol': string;
    /**
     * List of order hashes of the orders to be cancelled. All orders must belong to accountAddress. Max 10 order hashes
     * @type {Array<string>}
     * @memberof CancelOrdersRequest
     */
    'orderHashes'?: Array<string>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const CandlePriceType = {
    Last: 'Last',
    Market: 'Market',
    Oracle: 'Oracle',
    Unspecified: 'UNSPECIFIED'
} as const;

export type CandlePriceType = typeof CandlePriceType[keyof typeof CandlePriceType];


/**
 * Represents a candlestick for a specific market and interval.
 * @export
 * @interface CandlestickUpdate
 */
export interface CandlestickUpdate {
    /**
     * The symbol of the market for this candlestick.
     * @type {string}
     * @memberof CandlestickUpdate
     */
    'symbol': string;
    /**
     * The start time of the candlestick in milliseconds since epoch.
     * @type {number}
     * @memberof CandlestickUpdate
     */
    'startTime': number;
    /**
     * The end time of the candlestick in milliseconds since epoch.
     * @type {number}
     * @memberof CandlestickUpdate
     */
    'endTime': number;
    /**
     * The interval of the candlestick (e.g., 1m, 5m, 1h).
     * @type {string}
     * @memberof CandlestickUpdate
     */
    'interval': string;
    /**
     * The opening price of the candlestick.
     * @type {string}
     * @memberof CandlestickUpdate
     */
    'openPriceE9': string;
    /**
     * The closing price of the candlestick.
     * @type {string}
     * @memberof CandlestickUpdate
     */
    'closePriceE9': string;
    /**
     * The highest price during the candlestick interval.
     * @type {string}
     * @memberof CandlestickUpdate
     */
    'highPriceE9': string;
    /**
     * The lowest price during the candlestick interval.
     * @type {string}
     * @memberof CandlestickUpdate
     */
    'lowPriceE9': string;
    /**
     * The total trading volume during the candlestick interval.
     * @type {string}
     * @memberof CandlestickUpdate
     */
    'volumeE9': string;
    /**
     * The total quote volume traded during the candlestick interval.
     * @type {string}
     * @memberof CandlestickUpdate
     */
    'quoteVolumeE9': string;
    /**
     * The number of trades that occurred during the candlestick interval.
     * @type {number}
     * @memberof CandlestickUpdate
     */
    'numTrades': number;
}
/**
 * Contract configuration for the exchange.
 * @export
 * @interface ContractsConfig
 */
export interface ContractsConfig {
    /**
     * External Data Store Address
     * @type {string}
     * @memberof ContractsConfig
     */
    'edsId': string;
    /**
     * External Data Store Address
     * @type {string}
     * @memberof ContractsConfig
     */
    'idsId': string;
    /**
     * Network environment
     * @type {string}
     * @memberof ContractsConfig
     */
    'network': ContractsConfigNetworkEnum;
    /**
     * Base contract address
     * @type {string}
     * @memberof ContractsConfig
     */
    'baseContractAddress': string;
    /**
     * Current contract address
     * @type {string}
     * @memberof ContractsConfig
     */
    'currentContractAddress': string;
    /**
     * 
     * @type {Operators}
     * @memberof ContractsConfig
     */
    'operators': Operators;
}

export const ContractsConfigNetworkEnum = {
    Mainnet: 'mainnet',
    Testnet: 'testnet',
    Devnet: 'devnet'
} as const;

export type ContractsConfigNetworkEnum = typeof ContractsConfigNetworkEnum[keyof typeof ContractsConfigNetworkEnum];

/**
 * 
 * @export
 * @interface CreateOrderRequest
 */
export interface CreateOrderRequest {
    /**
     * 
     * @type {CreateOrderRequestSignedFields}
     * @memberof CreateOrderRequest
     */
    'signedFields': CreateOrderRequestSignedFields;
    /**
     * The signature of the request, encoded from the signedFields
     * @type {string}
     * @memberof CreateOrderRequest
     */
    'signature': string;
    /**
     * The client-defined unique identifier of this order used for lookup. This should always be unique; however, the server will not gurantee this or impose any checks.
     * @type {string}
     * @memberof CreateOrderRequest
     */
    'clientOrderId'?: string;
    /**
     * 
     * @type {OrderType}
     * @memberof CreateOrderRequest
     */
    'type': OrderType;
    /**
     * Is this order to only reduce a position? Default false
     * @type {boolean}
     * @memberof CreateOrderRequest
     */
    'reduceOnly': boolean;
    /**
     * If set to TRUE, the order can only be a maker order
     * @type {boolean}
     * @memberof CreateOrderRequest
     */
    'postOnly'?: boolean;
    /**
     * Omit or set to null for market orders; otherwise, choose a valid time-in-force value. GTT: Good Til Time  IOC: Immediate Or Cancel  FOK: Fill Or Kill 
     * @type {OrderTimeInForce}
     * @memberof CreateOrderRequest
     */
    'timeInForce'?: OrderTimeInForce;
    /**
     * Trigger price in base e9 for stop orders. This should always be a number
     * @type {string}
     * @memberof CreateOrderRequest
     */
    'triggerPriceE9'?: string;
    /**
     * 
     * @type {SelfTradePreventionType}
     * @memberof CreateOrderRequest
     */
    'selfTradePreventionType'?: SelfTradePreventionType;
}


/**
 * 
 * @export
 * @interface CreateOrderRequestSignedFields
 */
export interface CreateOrderRequestSignedFields {
    /**
     * The symbol of the perpetual for which to create the order
     * @type {string}
     * @memberof CreateOrderRequestSignedFields
     */
    'symbol': string;
    /**
     * The account address of the order. May be an account user is authorized for.
     * @type {string}
     * @memberof CreateOrderRequestSignedFields
     */
    'accountAddress': string;
    /**
     * The price in base e9 of the asset to be traded. Should always be a number
     * @type {string}
     * @memberof CreateOrderRequestSignedFields
     */
    'priceE9': string;
    /**
     * The quantity in base e9 of the asset to be traded. Should always be a number
     * @type {string}
     * @memberof CreateOrderRequestSignedFields
     */
    'quantityE9': string;
    /**
     * 
     * @type {OrderSide}
     * @memberof CreateOrderRequestSignedFields
     */
    'side': OrderSide;
    /**
     * The leverage in base e9 of the order to be traded. Should always be a number
     * @type {string}
     * @memberof CreateOrderRequestSignedFields
     */
    'leverageE9': string;
    /**
     * Is this order isolated or cross margin. Note market must be set to the same mode.
     * @type {boolean}
     * @memberof CreateOrderRequestSignedFields
     */
    'isIsolated': boolean;
    /**
     * The random generated SALT. Should always be a number
     * @type {string}
     * @memberof CreateOrderRequestSignedFields
     */
    'salt': string;
    /**
     * the ID of the internal datastore for the target network
     * @type {string}
     * @memberof CreateOrderRequestSignedFields
     */
    'idsId': string;
    /**
     * timestamp in millis at which order will expire. Defaults to 1 month for LIMIT orders if not provided
     * @type {number}
     * @memberof CreateOrderRequestSignedFields
     */
    'expiresAtMillis': number;
    /**
     * The timestamp in millis at which the request was signed
     * @type {number}
     * @memberof CreateOrderRequestSignedFields
     */
    'signedAtMillis': number;
}


/**
 * 
 * @export
 * @interface EpochConfigs
 */
export interface EpochConfigs {
    /**
     * The name of the campaign.
     * @type {string}
     * @memberof EpochConfigs
     */
    'campaignName': string;
    /**
     * Duration of the epoch in milliseconds.
     * @type {number}
     * @memberof EpochConfigs
     */
    'epochDuration': number;
    /**
     * Allocation of Sui token rewards in the epoch (e9 format).
     * @type {string}
     * @memberof EpochConfigs
     */
    'suiRewardsAllocation': string;
    /**
     * Allocation of Blue token rewards in the epoch (e9 format).
     * @type {string}
     * @memberof EpochConfigs
     */
    'blueRewardsAllocation': string;
    /**
     * Allocation of cash token rewards in the epoch (e9 format)
     * @type {string}
     * @memberof EpochConfigs
     */
    'cashRewardsAllocation': string;
    /**
     * Object to add custom configurations for campaigns.
     * @type {{ [key: string]: any | undefined; }}
     * @memberof EpochConfigs
     */
    'config': { [key: string]: any | undefined; };
}
/**
 * 
 * @export
 * @interface EpochMetadata
 */
export interface EpochMetadata {
    /**
     * 
     * @type {string}
     * @memberof EpochMetadata
     */
    'Status': EpochMetadataStatusEnum;
    /**
     * Name of the campaign.
     * @type {string}
     * @memberof EpochMetadata
     */
    'CampaignName': string;
    /**
     * Epoch Id of the epoch.
     * @type {number}
     * @memberof EpochMetadata
     */
    'EpochId': number;
    /**
     * Epoch number for the queried epoch.
     * @type {number}
     * @memberof EpochMetadata
     */
    'EpochNumber': number;
    /**
     * Time in milliseconds for campaign start date.
     * @type {number}
     * @memberof EpochMetadata
     */
    'StartDate': number;
    /**
     * Time in milliseconds for campaign end date.
     * @type {number}
     * @memberof EpochMetadata
     */
    'EndDate': number;
}

export const EpochMetadataStatusEnum = {
    Active: 'ACTIVE',
    NotStarted: 'NOT_STARTED',
    Finalized: 'FINALIZED',
    Cooldown: 'COOLDOWN'
} as const;

export type EpochMetadataStatusEnum = typeof EpochMetadataStatusEnum[keyof typeof EpochMetadataStatusEnum];

/**
 * 
 * @export
 * @interface ExchangeInfoResponse
 */
export interface ExchangeInfoResponse {
    /**
     * List of assets available on the exchange.
     * @type {Array<AssetConfig>}
     * @memberof ExchangeInfoResponse
     */
    'assets': Array<AssetConfig>;
    /**
     * 
     * @type {ContractsConfig}
     * @memberof ExchangeInfoResponse
     */
    'contractsConfig'?: ContractsConfig;
    /**
     * List of markets available on the exchange.
     * @type {Array<Market>}
     * @memberof ExchangeInfoResponse
     */
    'markets': Array<Market>;
    /**
     * Current gas fee set for subsidized trades (e9 format)
     * @type {string}
     * @memberof ExchangeInfoResponse
     */
    'tradingGasFeeE9': string;
    /**
     * Server time in milliseconds.
     * @type {number}
     * @memberof ExchangeInfoResponse
     */
    'serverTimeAtMillis': number;
    /**
     * Timezone of the exchange.
     * @type {string}
     * @memberof ExchangeInfoResponse
     */
    'timezone': string;
}
/**
 * 
 * @export
 * @interface FundingRateEntry
 */
export interface FundingRateEntry {
    /**
     * The market symbol.
     * @type {string}
     * @memberof FundingRateEntry
     */
    'symbol': string;
    /**
     * Timestamp of the funding time in milliseconds.
     * @type {number}
     * @memberof FundingRateEntry
     */
    'fundingTimeAtMillis': number;
    /**
     * Funding rate for the market address.
     * @type {string}
     * @memberof FundingRateEntry
     */
    'fundingRateE9': string;
}
/**
 * 
 * @export
 * @interface IntervalMetadata
 */
export interface IntervalMetadata {
    /**
     * 
     * @type {string}
     * @memberof IntervalMetadata
     */
    'Status': IntervalMetadataStatusEnum;
    /**
     * Time in milliseconds for interval start date.
     * @type {number}
     * @memberof IntervalMetadata
     */
    'StartDate': number;
    /**
     * Time in milliseconds for interval end date.
     * @type {number}
     * @memberof IntervalMetadata
     */
    'EndDate': number;
    /**
     * Interval Id of the interval.
     * @type {number}
     * @memberof IntervalMetadata
     */
    'IntervalId': number;
    /**
     * Type of the interval.
     * @type {string}
     * @memberof IntervalMetadata
     */
    'IntervalType': string;
}

export const IntervalMetadataStatusEnum = {
    Active: 'ACTIVE',
    NotStarted: 'NOT_STARTED',
    Finalized: 'FINALIZED',
    Cooldown: 'COOLDOWN'
} as const;

export type IntervalMetadataStatusEnum = typeof IntervalMetadataStatusEnum[keyof typeof IntervalMetadataStatusEnum];

/**
 * 
 * @export
 * @interface IntervalRewards
 */
export interface IntervalRewards {
    /**
     * User address for the rewards earned data.
     * @type {string}
     * @memberof IntervalRewards
     */
    'UserAddress': string;
    /**
     * 
     * @type {string}
     * @memberof IntervalRewards
     */
    'Status': IntervalRewardsStatusEnum;
    /**
     * Total Blue token rewards earned in the interval (e9 format).
     * @type {string}
     * @memberof IntervalRewards
     */
    'BlueRewards': string;
    /**
     * Total Sui token rewards earned in the interval (e9 format).
     * @type {string}
     * @memberof IntervalRewards
     */
    'SuiRewards': string;
    /**
     * Total cash rewards earned in the interval (e9 format).
     * @type {string}
     * @memberof IntervalRewards
     */
    'CashRewards': string;
    /**
     * Interval Id of the interval for the rewards earned data.
     * @type {number}
     * @memberof IntervalRewards
     */
    'IntervalNumber': number;
}

export const IntervalRewardsStatusEnum = {
    Active: 'ACTIVE',
    NotStarted: 'NOT_STARTED',
    Finalized: 'FINALIZED',
    Cooldown: 'COOLDOWN'
} as const;

export type IntervalRewardsStatusEnum = typeof IntervalRewardsStatusEnum[keyof typeof IntervalRewardsStatusEnum];

/**
 * 
 * @export
 * @enum {string}
 */

export const KlineInterval = {
    _1m: '1m',
    _3m: '3m',
    _5m: '5m',
    _15m: '15m',
    _30m: '30m',
    _1h: '1h',
    _2h: '2h',
    _4h: '4h',
    _6h: '6h',
    _8h: '8h',
    _12h: '12h',
    _1d: '1d',
    _1w: '1w',
    _1Mo: '1Mo',
    Unspecified: 'UNSPECIFIED'
} as const;

export type KlineInterval = typeof KlineInterval[keyof typeof KlineInterval];


/**
 * User is expected to sign this payload and sends is signature in login api as header and payload itself in request body 
 * @export
 * @interface LoginRequest
 */
export interface LoginRequest {
    /**
     * The address of the account.
     * @type {string}
     * @memberof LoginRequest
     */
    'accountAddress': string;
    /**
     * The timestamp in millis when the login was signed.
     * @type {number}
     * @memberof LoginRequest
     */
    'signedAtMillis': number;
    /**
     * The intended audience of the login request.
     * @type {string}
     * @memberof LoginRequest
     */
    'audience': string;
}
/**
 * 
 * @export
 * @interface LoginResponse
 */
export interface LoginResponse {
    /**
     * 
     * @type {string}
     * @memberof LoginResponse
     */
    'accessToken': string;
    /**
     * 
     * @type {number}
     * @memberof LoginResponse
     */
    'accessTokenValidForSeconds': number;
    /**
     * 
     * @type {string}
     * @memberof LoginResponse
     */
    'refreshToken': string;
    /**
     * 
     * @type {number}
     * @memberof LoginResponse
     */
    'refreshTokenValidForSeconds': number;
}
/**
 * Margin type.
 * @export
 * @enum {string}
 */

export const MarginType = {
    Cross: 'CROSS',
    Isolated: 'ISOLATED',
    Unspecified: 'UNSPECIFIED'
} as const;

export type MarginType = typeof MarginType[keyof typeof MarginType];


/**
 * 
 * @export
 * @interface MarkPriceUpdate
 */
export interface MarkPriceUpdate {
    /**
     * The symbol of the market.
     * @type {string}
     * @memberof MarkPriceUpdate
     */
    'symbol': string;
    /**
     * The price in scientific notation with 9 decimal places of precision.
     * @type {string}
     * @memberof MarkPriceUpdate
     */
    'priceE9': string;
    /**
     * 
     * @type {string}
     * @memberof MarkPriceUpdate
     */
    'source': MarkPriceUpdateSourceEnum;
    /**
     * The timestamp of the price update.
     * @type {number}
     * @memberof MarkPriceUpdate
     */
    'updatedAtMillis': number;
}

export const MarkPriceUpdateSourceEnum = {
    Mark: 'Mark'
} as const;

export type MarkPriceUpdateSourceEnum = typeof MarkPriceUpdateSourceEnum[keyof typeof MarkPriceUpdateSourceEnum];

/**
 * 
 * @export
 * @interface Market
 */
export interface Market {
    /**
     * Symbol of the market.
     * @type {string}
     * @memberof Market
     */
    'symbol': string;
    /**
     * Market address.
     * @type {string}
     * @memberof Market
     */
    'marketAddress': string;
    /**
     * 
     * @type {MarketStatus}
     * @memberof Market
     */
    'status': MarketStatus;
    /**
     * Base asset symbol.
     * @type {string}
     * @memberof Market
     */
    'baseAssetSymbol': string;
    /**
     * Base asset name.
     * @type {string}
     * @memberof Market
     */
    'baseAssetName': string;
    /**
     * Precision of the base asset.
     * @type {number}
     * @memberof Market
     */
    'baseAssetDecimals': number;
    /**
     * Step size for the quantity (e9 format).
     * @type {string}
     * @memberof Market
     */
    'stepSizeE9': string;
    /**
     * Price increment size (e9 format).
     * @type {string}
     * @memberof Market
     */
    'tickSizeE9': string;
    /**
     * Minimum order size (e9 format).
     * @type {string}
     * @memberof Market
     */
    'minOrderQuantityE9': string;
    /**
     * Maximum limit order size (e9 format).
     * @type {string}
     * @memberof Market
     */
    'maxLimitOrderQuantityE9': string;
    /**
     * Maximum market order size (e9 format).
     * @type {string}
     * @memberof Market
     */
    'maxMarketOrderQuantityE9': string;
    /**
     * Minimum order price (e9 format).
     * @type {string}
     * @memberof Market
     */
    'minOrderPriceE9': string;
    /**
     * Maximum order price (e9 format).
     * @type {string}
     * @memberof Market
     */
    'maxOrderPriceE9': string;
    /**
     * Maintenance margin ratio (MMR, e9 format).
     * @type {string}
     * @memberof Market
     */
    'maintenanceMarginRatioE9': string;
    /**
     * Initial margin ratio (IMR), e9 format).
     * @type {string}
     * @memberof Market
     */
    'initialMarginRatioE9': string;
    /**
     * Insurance pool ratio (e9 format).
     * @type {string}
     * @memberof Market
     */
    'insurancePoolRatioE9': string;
    /**
     * Default leverage (e9 format).
     * @type {string}
     * @memberof Market
     */
    'defaultLeverageE9': string;
    /**
     * Maximum notional value at current leverage. Index 0 is max notional value for leverage set to 1x, index 1 is for leverage 2x, etc...
     * @type {Array<string>}
     * @memberof Market
     */
    'maxNotionalAtOpenE9': Array<string>;
    /**
     * Minimum trade quantity allowed (e9 format).
     * @type {string}
     * @memberof Market
     */
    'minTradeQuantityE9': string;
    /**
     * Max trade quantity allowed (e9 format).
     * @type {string}
     * @memberof Market
     */
    'maxTradeQuantityE9': string;
    /**
     * Minimum trade price allowed (e9 format).
     * @type {string}
     * @memberof Market
     */
    'minTradePriceE9': string;
    /**
     * Maximum trade price allowed (e9 format).
     * @type {string}
     * @memberof Market
     */
    'maxTradePriceE9': string;
    /**
     * Maximum allowed funding rate (e9 format).
     * @type {string}
     * @memberof Market
     */
    'maxFundingRateE9': string;
    /**
     * Default maker fee (e9 format).
     * @type {string}
     * @memberof Market
     */
    'defaultMakerFeeE9': string;
    /**
     * Default taker fee (e9 format).
     * @type {string}
     * @memberof Market
     */
    'defaultTakerFeeE9': string;
    /**
     * Insurance pool address.
     * @type {string}
     * @memberof Market
     */
    'insurancePoolAddress': string;
    /**
     * Fee pool address.
     * @type {string}
     * @memberof Market
     */
    'feePoolAddress': string;
    /**
     * The time when trading will start/have started on the market.
     * @type {string}
     * @memberof Market
     */
    'tradingStartTimeAtMillis': string;
    /**
     * Maximum take bound for long positions (e9 format).
     * @type {string}
     * @memberof Market
     */
    'mtbLongE9': string;
    /**
     * Maximum take bound for short positions (e9 format).
     * @type {string}
     * @memberof Market
     */
    'mtbShortE9': string;
    /**
     * Delisting price (e9 format).
     * @type {string}
     * @memberof Market
     */
    'delistingPriceE9': string;
    /**
     * Indicates whether the market only allows isolated margin.
     * @type {boolean}
     * @memberof Market
     */
    'isolatedOnly': boolean;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const MarketDataStreamName = {
    RecentTrade: 'Recent_Trade',
    Ticker: 'Ticker',
    TickerAll: 'Ticker_All',
    DiffDepth10Ms: 'Diff_Depth_10_ms',
    DiffDepth200Ms: 'Diff_Depth_200_ms',
    DiffDepth500Ms: 'Diff_Depth_500_ms',
    PartialDepth5: 'Partial_Depth_5',
    PartialDepth10: 'Partial_Depth_10',
    PartialDepth20: 'Partial_Depth_20',
    OraclePrice: 'Oracle_Price',
    MarkPrice: 'Mark_Price',
    MarketPrice: 'Market_Price',
    Candlestick1mLast: 'Candlestick_1m_Last',
    Candlestick3mLast: 'Candlestick_3m_Last',
    Candlestick5mLast: 'Candlestick_5m_Last',
    Candlestick15mLast: 'Candlestick_15m_Last',
    Candlestick30mLast: 'Candlestick_30m_Last',
    Candlestick1hLast: 'Candlestick_1h_Last',
    Candlestick2hLast: 'Candlestick_2h_Last',
    Candlestick4hLast: 'Candlestick_4h_Last',
    Candlestick6hLast: 'Candlestick_6h_Last',
    Candlestick8hLast: 'Candlestick_8h_Last',
    Candlestick12hLast: 'Candlestick_12h_Last',
    Candlestick1dLast: 'Candlestick_1d_Last',
    Candlestick1wLast: 'Candlestick_1w_Last',
    Candlestick1MoLast: 'Candlestick_1Mo_Last',
    Candlestick1mOracle: 'Candlestick_1m_Oracle',
    Candlestick3mOracle: 'Candlestick_3m_Oracle',
    Candlestick5mOracle: 'Candlestick_5m_Oracle',
    Candlestick15mOracle: 'Candlestick_15m_Oracle',
    Candlestick30mOracle: 'Candlestick_30m_Oracle',
    Candlestick1hOracle: 'Candlestick_1h_Oracle',
    Candlestick2hOracle: 'Candlestick_2h_Oracle',
    Candlestick4hOracle: 'Candlestick_4h_Oracle',
    Candlestick6hOracle: 'Candlestick_6h_Oracle',
    Candlestick8hOracle: 'Candlestick_8h_Oracle',
    Candlestick12hOracle: 'Candlestick_12h_Oracle',
    Candlestick1dOracle: 'Candlestick_1d_Oracle',
    Candlestick1wOracle: 'Candlestick_1w_Oracle',
    Candlestick1MoOracle: 'Candlestick_1Mo_Oracle',
    Candlestick1mMark: 'Candlestick_1m_Mark',
    Candlestick3mMark: 'Candlestick_3m_Mark',
    Candlestick5mMark: 'Candlestick_5m_Mark',
    Candlestick15mMark: 'Candlestick_15m_Mark',
    Candlestick30mMark: 'Candlestick_30m_Mark',
    Candlestick1hMark: 'Candlestick_1h_Mark',
    Candlestick2hMark: 'Candlestick_2h_Mark',
    Candlestick4hMark: 'Candlestick_4h_Mark',
    Candlestick6hMark: 'Candlestick_6h_Mark',
    Candlestick8hMark: 'Candlestick_8h_Mark',
    Candlestick12hMark: 'Candlestick_12h_Mark',
    Candlestick1dMark: 'Candlestick_1d_Mark',
    Candlestick1wMark: 'Candlestick_1w_Mark',
    Candlestick1MoMark: 'Candlestick_1Mo_Mark',
    Candlestick1mMarket: 'Candlestick_1m_Market',
    Candlestick3mMarket: 'Candlestick_3m_Market',
    Candlestick5mMarket: 'Candlestick_5m_Market',
    Candlestick15mMarket: 'Candlestick_15m_Market',
    Candlestick30mMarket: 'Candlestick_30m_Market',
    Candlestick1hMarket: 'Candlestick_1h_Market',
    Candlestick2hMarket: 'Candlestick_2h_Market',
    Candlestick4hMarket: 'Candlestick_4h_Market',
    Candlestick6hMarket: 'Candlestick_6h_Market',
    Candlestick8hMarket: 'Candlestick_8h_Market',
    Candlestick12hMarket: 'Candlestick_12h_Market',
    Candlestick1dMarket: 'Candlestick_1d_Market',
    Candlestick1wMarket: 'Candlestick_1w_Market',
    Candlestick1MoMarket: 'Candlestick_1Mo_Market'
} as const;

export type MarketDataStreamName = typeof MarketDataStreamName[keyof typeof MarketDataStreamName];


/**
 * The type of event communicated in the WebSocket message.
 * @export
 * @enum {string}
 */

export const MarketEventType = {
    RecentTradesUpdates: 'RecentTradesUpdates',
    TickerUpdate: 'TickerUpdate',
    TickerAllUpdate: 'TickerAllUpdate',
    OraclePriceUpdate: 'OraclePriceUpdate',
    MarkPriceUpdate: 'MarkPriceUpdate',
    MarketPriceUpdate: 'MarketPriceUpdate',
    CandlestickUpdate: 'CandlestickUpdate',
    OrderbookDiffDepthUpdate: 'OrderbookDiffDepthUpdate',
    OrderbookPartialDepthUpdate: 'OrderbookPartialDepthUpdate'
} as const;

export type MarketEventType = typeof MarketEventType[keyof typeof MarketEventType];


/**
 * 
 * @export
 * @interface MarketPriceUpdate
 */
export interface MarketPriceUpdate {
    /**
     * The symbol of the market.
     * @type {string}
     * @memberof MarketPriceUpdate
     */
    'symbol': string;
    /**
     * The price in scientific notation with 9 decimal places of precision.
     * @type {string}
     * @memberof MarketPriceUpdate
     */
    'priceE9': string;
    /**
     * 
     * @type {string}
     * @memberof MarketPriceUpdate
     */
    'source': MarketPriceUpdateSourceEnum;
    /**
     * The timestamp of the price update.
     * @type {number}
     * @memberof MarketPriceUpdate
     */
    'updatedAtMillis': number;
}

export const MarketPriceUpdateSourceEnum = {
    Market: 'Market'
} as const;

export type MarketPriceUpdateSourceEnum = typeof MarketPriceUpdateSourceEnum[keyof typeof MarketPriceUpdateSourceEnum];

/**
 * 
 * @export
 * @enum {string}
 */

export const MarketStatus = {
    Active: 'ACTIVE',
    Beta: 'BETA',
    Maintenance: 'MAINTENANCE',
    Delisted: 'DELISTED',
    Unspecified: 'UNSPECIFIED'
} as const;

export type MarketStatus = typeof MarketStatus[keyof typeof MarketStatus];


/**
 * A market stream message containing an event type and a payload. The payload structure depends on the event type. 
 * @export
 * @interface MarketStreamMessage
 */
export interface MarketStreamMessage {
    /**
     * 
     * @type {MarketEventType}
     * @memberof MarketStreamMessage
     */
    'event': MarketEventType;
    /**
     * 
     * @type {MarketStreamMessagePayload}
     * @memberof MarketStreamMessage
     */
    'payload': MarketStreamMessagePayload;
}


/**
 * @type MarketStreamMessagePayload
 * The payload of the message, which varies based on the event type.
 * @export
 */
export type MarketStreamMessagePayload = CandlestickUpdate | MarkPriceUpdate | MarketPriceUpdate | OraclePriceUpdate | OrderbookDiffDepthUpdate | OrderbookPartialDepthUpdate | RecentTradesUpdates | TickerAllUpdate | TickerUpdate;

/**
 * Subscription message for market data streams.
 * @export
 * @interface MarketSubscriptionMessage
 */
export interface MarketSubscriptionMessage {
    /**
     * 
     * @type {SubscriptionType}
     * @memberof MarketSubscriptionMessage
     */
    'method': SubscriptionType;
    /**
     * List of market data streams to subscribe or unsubscribe from.
     * @type {Array<MarketSubscriptionStreams>}
     * @memberof MarketSubscriptionMessage
     */
    'dataStreams': Array<MarketSubscriptionStreams>;
}


/**
 * Represents the type of market data stream and its parameters.
 * @export
 * @interface MarketSubscriptionStreams
 */
export interface MarketSubscriptionStreams {
    /**
     * The symbol of the market stream to subscribe to (Leave empty for TickerAll stream)
     * @type {string}
     * @memberof MarketSubscriptionStreams
     */
    'symbol': string;
    /**
     * 
     * @type {Array<MarketDataStreamName>}
     * @memberof MarketSubscriptionStreams
     */
    'streams': Array<MarketDataStreamName>;
}
/**
 * 
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * A code representing the type of error.
     * @type {string}
     * @memberof ModelError
     */
    'errorCode'?: string;
    /**
     * A human-readable message describing the error.
     * @type {string}
     * @memberof ModelError
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface OpenOrderResponse
 */
export interface OpenOrderResponse {
    /**
     * The Order Hash, which is the default way to uniquely identify an order in the system
     * @type {string}
     * @memberof OpenOrderResponse
     */
    'orderHash': string;
    /**
     * The Client Order ID, which is used a unique identifier for an order, provided by the client, in case of proprietary order management systems
     * @type {string}
     * @memberof OpenOrderResponse
     */
    'clientOrderId'?: string;
    /**
     * The market symbol
     * @type {string}
     * @memberof OpenOrderResponse
     */
    'symbol': string;
    /**
     * The account address of the order. May be an account user is authorized for.
     * @type {string}
     * @memberof OpenOrderResponse
     */
    'accountAddress': string;
    /**
     * The price in base e9 of the asset to be traded. Should always be a number
     * @type {string}
     * @memberof OpenOrderResponse
     */
    'priceE9': string;
    /**
     * The quantity in base e9 of the asset to be traded. Should always be a number
     * @type {string}
     * @memberof OpenOrderResponse
     */
    'quantityE9': string;
    /**
     * 
     * @type {OrderSide}
     * @memberof OpenOrderResponse
     */
    'side': OrderSide;
    /**
     * The leverage in base e9  of the order to be traded. Should always be a number
     * @type {string}
     * @memberof OpenOrderResponse
     */
    'leverageE9': string;
    /**
     * Is this order isolated or cross margin. Note market must be set to the same mode.
     * @type {boolean}
     * @memberof OpenOrderResponse
     */
    'isIsolated': boolean;
    /**
     * The random generated SALT. Should always be a number
     * @type {string}
     * @memberof OpenOrderResponse
     */
    'salt': string;
    /**
     * Unix timestamp in millis at which order will expire. Defaults to 1 month for LIMIT orders if not provided
     * @type {number}
     * @memberof OpenOrderResponse
     */
    'expiresAtMillis': number;
    /**
     * The timestamp in millis at which the request was signed
     * @type {number}
     * @memberof OpenOrderResponse
     */
    'signedAtMillis': number;
    /**
     * 
     * @type {OrderType}
     * @memberof OpenOrderResponse
     */
    'type': OrderType;
    /**
     * Is this order to only reduce a position? Default false
     * @type {boolean}
     * @memberof OpenOrderResponse
     */
    'reduceOnly': boolean;
    /**
     * If set to TRUE, the order can only be a maker order
     * @type {boolean}
     * @memberof OpenOrderResponse
     */
    'postOnly': boolean;
    /**
     * 
     * @type {OrderTimeInForce}
     * @memberof OpenOrderResponse
     */
    'timeInForce': OrderTimeInForce;
    /**
     * Trigger price in base e9 for stop orders. This should always be a number
     * @type {string}
     * @memberof OpenOrderResponse
     */
    'triggerPriceE9'?: string;
    /**
     * The quantity in base e9 of the asset currently filled. This should always be a number
     * @type {string}
     * @memberof OpenOrderResponse
     */
    'filledQuantityE9': string;
    /**
     * 
     * @type {OrderStatus}
     * @memberof OpenOrderResponse
     */
    'status': OrderStatus;
    /**
     * 
     * @type {SelfTradePreventionType}
     * @memberof OpenOrderResponse
     */
    'selfTradePreventionType': SelfTradePreventionType;
    /**
     * The timestamp in millis when the order was opened
     * @type {number}
     * @memberof OpenOrderResponse
     */
    'orderTimeAtMillis': number;
    /**
     * The timestamp in millis that this order was last updated (including status updates)
     * @type {number}
     * @memberof OpenOrderResponse
     */
    'updatedAtMillis': number;
}


/**
 * 
 * @export
 * @interface Operators
 */
export interface Operators {
    /**
     * Admin operator address
     * @type {string}
     * @memberof Operators
     */
    'admin': string;
    /**
     * General operator address; AKA Guardian
     * @type {string}
     * @memberof Operators
     * @deprecated
     */
    'operator': string;
    /**
     * Sequencer operator address
     * @type {string}
     * @memberof Operators
     */
    'sequencer': string;
    /**
     * Funding operator address
     * @type {string}
     * @memberof Operators
     * @deprecated
     */
    'funding': string;
    /**
     * Fee operator address
     * @type {string}
     * @memberof Operators
     * @deprecated
     */
    'fee': string;
}
/**
 * 
 * @export
 * @interface OraclePriceUpdate
 */
export interface OraclePriceUpdate {
    /**
     * The symbol of the market.
     * @type {string}
     * @memberof OraclePriceUpdate
     */
    'symbol': string;
    /**
     * The price in scientific notation with 9 decimal places of precision.
     * @type {string}
     * @memberof OraclePriceUpdate
     */
    'priceE9': string;
    /**
     * 
     * @type {string}
     * @memberof OraclePriceUpdate
     */
    'source': OraclePriceUpdateSourceEnum;
    /**
     * The timestamp of the price update.
     * @type {number}
     * @memberof OraclePriceUpdate
     */
    'updatedAtMillis': number;
}

export const OraclePriceUpdateSourceEnum = {
    Oracle: 'Oracle'
} as const;

export type OraclePriceUpdateSourceEnum = typeof OraclePriceUpdateSourceEnum[keyof typeof OraclePriceUpdateSourceEnum];

/**
 * The reason for an order cancellation.
 * @export
 * @enum {string}
 */

export const OrderCancelReason = {
    Unspecified: 'UNSPECIFIED',
    InsufficientMargin: 'INSUFFICIENT_MARGIN',
    DuplicateOrder: 'DUPLICATE_ORDER',
    PostOnlyWouldTrade: 'POST_ONLY_WOULD_TRADE',
    InvalidSymbol: 'INVALID_SYMBOL',
    SignedAtTooOld: 'SIGNED_AT_TOO_OLD',
    OrderExpired: 'ORDER_EXPIRED',
    InvalidLeverage: 'INVALID_LEVERAGE',
    InvalidInput: 'INVALID_INPUT',
    PriceOutOfBound: 'PRICE_OUT_OF_BOUND',
    QuantityOutOfBound: 'QUANTITY_OUT_OF_BOUND',
    PriceOutOfTickSize: 'PRICE_OUT_OF_TICK_SIZE',
    QuantityOutOfStepSize: 'QUANTITY_OUT_OF_STEP_SIZE',
    ReduceOnlyWouldOpen: 'REDUCE_ONLY_WOULD_OPEN',
    TooManyOpenOrdersOnMarket: 'TOO_MANY_OPEN_ORDERS_ON_MARKET',
    UserCancelled: 'USER_CANCELLED',
    UserCancelledAllOnMarket: 'USER_CANCELLED_ALL_ON_MARKET',
    SelfTradePrevention: 'SELF_TRADE_PREVENTION',
    LeverageUpdate: 'LEVERAGE_UPDATE',
    AccountNotFound: 'ACCOUNT_NOT_FOUND',
    MarketNotTrading: 'MARKET_NOT_TRADING',
    InsufficientLiquidity: 'INSUFFICIENT_LIQUIDITY',
    PositionNotFound: 'POSITION_NOT_FOUND',
    LiquidationOutOfOrder: 'LIQUIDATION_OUT_OF_ORDER',
    AccountNotLiquidatable: 'ACCOUNT_NOT_LIQUIDATABLE'
} as const;

export type OrderCancelReason = typeof OrderCancelReason[keyof typeof OrderCancelReason];


/**
 * The reason for failure to cancel an order.
 * @export
 * @enum {string}
 */

export const OrderCancellationFailureReason = {
    OrderNotFound: 'ORDER_NOT_FOUND',
    MarketNotFound: 'MARKET_NOT_FOUND',
    AccountNotFound: 'ACCOUNT_NOT_FOUND',
    NoOpenOrdersOnMarket: 'NO_OPEN_ORDERS_ON_MARKET',
    NoFailure: 'NO_FAILURE',
    Unspecified: 'UNSPECIFIED'
} as const;

export type OrderCancellationFailureReason = typeof OrderCancellationFailureReason[keyof typeof OrderCancellationFailureReason];


/**
 * Details of an order cancellation.
 * @export
 * @interface OrderCancellationUpdate
 */
export interface OrderCancellationUpdate {
    /**
     * The unique hash of the order.
     * @type {string}
     * @memberof OrderCancellationUpdate
     */
    'orderHash': string;
    /**
     * The client-provided order ID.
     * @type {string}
     * @memberof OrderCancellationUpdate
     */
    'clientOrderId'?: string;
    /**
     * The symbol of the market.
     * @type {string}
     * @memberof OrderCancellationUpdate
     */
    'symbol': string;
    /**
     * The address of the account.
     * @type {string}
     * @memberof OrderCancellationUpdate
     */
    'accountAddress': string;
    /**
     * The timestamp of the order creation in milliseconds.
     * @type {number}
     * @memberof OrderCancellationUpdate
     */
    'createdAtMillis': number;
    /**
     * 
     * @type {OrderCancelReason}
     * @memberof OrderCancellationUpdate
     */
    'cancellationReason': OrderCancelReason;
    /**
     * 
     * @type {OrderCancellationFailureReason}
     * @memberof OrderCancellationUpdate
     */
    'failureToCancelReason'?: OrderCancellationFailureReason;
    /**
     * The remaining quantity of the order.
     * @type {string}
     * @memberof OrderCancellationUpdate
     */
    'remainingQuantityE9': string;
}


/**
 * Side of the order
 * @export
 * @enum {string}
 */

export const OrderSide = {
    Long: 'LONG',
    Short: 'SHORT',
    Unspecified: 'UNSPECIFIED'
} as const;

export type OrderSide = typeof OrderSide[keyof typeof OrderSide];


/**
 * The current status of the order.
 * @export
 * @enum {string}
 */

export const OrderStatus = {
    Open: 'OPEN',
    PartiallyFilledOpen: 'PARTIALLY_FILLED_OPEN',
    PartiallyFilledCanceled: 'PARTIALLY_FILLED_CANCELED',
    Filled: 'FILLED',
    Cancelled: 'CANCELLED',
    Expired: 'EXPIRED',
    PartiallyFilledExpired: 'PARTIALLY_FILLED_EXPIRED',
    Unspecified: 'UNSPECIFIED'
} as const;

export type OrderStatus = typeof OrderStatus[keyof typeof OrderStatus];


/**
 * The time-in-force policy for the order. By default, all orders are GTT. UNSPECIFIED is set to default.  GTT: Good Til Time  IOC: Immediate Or Cancel  FOK: Fill Or Kill     
 * @export
 * @enum {string}
 */

export const OrderTimeInForce = {
    Gtt: 'GTT',
    Ioc: 'IOC',
    Fok: 'FOK',
    Unspecified: 'UNSPECIFIED'
} as const;

export type OrderTimeInForce = typeof OrderTimeInForce[keyof typeof OrderTimeInForce];


/**
 * The type of order.
 * @export
 * @enum {string}
 */

export const OrderType = {
    Limit: 'LIMIT',
    Market: 'MARKET',
    StopLimit: 'STOP_LIMIT',
    StopMarket: 'STOP_MARKET',
    Liquidation: 'LIQUIDATION',
    BankruptcyLiquidation: 'BANKRUPTCY_LIQUIDATION',
    Unspecified: 'UNSPECIFIED'
} as const;

export type OrderType = typeof OrderType[keyof typeof OrderType];


/**
 * 
 * @export
 * @interface OrderbookDepthResponse
 */
export interface OrderbookDepthResponse {
    /**
     * Market symbol.
     * @type {string}
     * @memberof OrderbookDepthResponse
     */
    'symbol': string;
    /**
     * Count indicating the number of changes in orderbook state.
     * @type {number}
     * @memberof OrderbookDepthResponse
     */
    'lastUpdateId': number;
    /**
     * Timestamp at which the last change in orderbook state took place, in milliseconds.
     * @type {number}
     * @memberof OrderbookDepthResponse
     */
    'updatedAtMillis': number;
    /**
     * The time at which the orderbook server sent the response, in milliseconds.
     * @type {number}
     * @memberof OrderbookDepthResponse
     */
    'responseSentAtMillis': number;
    /**
     * The best bid price on orderbook at the moment (e9 format).
     * @type {string}
     * @memberof OrderbookDepthResponse
     */
    'bestBidPriceE9': string;
    /**
     * The best bid quantity on orderbook at the moment (e9 format).
     * @type {string}
     * @memberof OrderbookDepthResponse
     */
    'bestBidQuantityE9': string;
    /**
     * The best ask price on orderbook at the moment (e9 format).
     * @type {string}
     * @memberof OrderbookDepthResponse
     */
    'bestAskPriceE9': string;
    /**
     * The best ask quantity on orderbook at the moment (e9 format).
     * @type {string}
     * @memberof OrderbookDepthResponse
     */
    'bestAskQuantityE9': string;
    /**
     * Bids to be filled. Index 0 is price, index 1 is quantity at price bin. Prices are in e9 format.
     * @type {Array<Array<string>>}
     * @memberof OrderbookDepthResponse
     */
    'bidsE9': Array<Array<string>>;
    /**
     * Asks to be filled. Index 0 is price, index 1 is quantity at price bin. Prices are in e9 format.
     * @type {Array<Array<string>>}
     * @memberof OrderbookDepthResponse
     */
    'asksE9': Array<Array<string>>;
}
/**
 * 
 * @export
 * @interface OrderbookDiffDepthUpdate
 */
export interface OrderbookDiffDepthUpdate {
    /**
     * The timestamp of the orderbook update.
     * @type {number}
     * @memberof OrderbookDiffDepthUpdate
     */
    'updatedAtMillis': number;
    /**
     * The symbol of the market for the orderbook update.
     * @type {string}
     * @memberof OrderbookDiffDepthUpdate
     */
    'symbol': string;
    /**
     * 
     * @type {Array<Array<string>>}
     * @memberof OrderbookDiffDepthUpdate
     */
    'bidsE9': Array<Array<string>>;
    /**
     * 
     * @type {Array<Array<string>>}
     * @memberof OrderbookDiffDepthUpdate
     */
    'asksE9': Array<Array<string>>;
    /**
     * The ID of the first update in this batch.
     * @type {number}
     * @memberof OrderbookDiffDepthUpdate
     */
    'firstUpdateId': number;
    /**
     * The ID of the last update in this batch.
     * @type {number}
     * @memberof OrderbookDiffDepthUpdate
     */
    'lastUpdateId': number;
}
/**
 * 
 * @export
 * @interface OrderbookPartialDepthUpdate
 */
export interface OrderbookPartialDepthUpdate {
    /**
     * The timestamp of the partial depth update.
     * @type {number}
     * @memberof OrderbookPartialDepthUpdate
     */
    'updatedAtMillis': number;
    /**
     * The symbol of the market for the partial depth update.
     * @type {string}
     * @memberof OrderbookPartialDepthUpdate
     */
    'symbol': string;
    /**
     * 
     * @type {Array<Array<string>>}
     * @memberof OrderbookPartialDepthUpdate
     */
    'bidsE9': Array<Array<string>>;
    /**
     * 
     * @type {Array<Array<string>>}
     * @memberof OrderbookPartialDepthUpdate
     */
    'asksE9': Array<Array<string>>;
    /**
     * The unique identifier for the orderbook update.
     * @type {number}
     * @memberof OrderbookPartialDepthUpdate
     */
    'orderbookUpdateId': number;
    /**
     * The depth level of the orderbook snapshot.
     * @type {string}
     * @memberof OrderbookPartialDepthUpdate
     */
    'depthLevel': OrderbookPartialDepthUpdateDepthLevelEnum;
}

export const OrderbookPartialDepthUpdateDepthLevelEnum = {
    _5: '5',
    _10: '10',
    _20: '20'
} as const;

export type OrderbookPartialDepthUpdateDepthLevelEnum = typeof OrderbookPartialDepthUpdateDepthLevelEnum[keyof typeof OrderbookPartialDepthUpdateDepthLevelEnum];

/**
 * 
 * @export
 * @interface Position
 */
export interface Position {
    /**
     * Market address.
     * @type {string}
     * @memberof Position
     */
    'symbol': string;
    /**
     * Average entry price determined by a simple average of all entry prices resulting in this position size (e9 format).
     * @type {string}
     * @memberof Position
     */
    'avgEntryPriceE9': string;
    /**
     * Isolated position leverage (e9 format).
     * @type {string}
     * @memberof Position
     */
    'clientSetLeverageE9': string;
    /**
     * Liquidation price (e9 format).
     * @type {string}
     * @memberof Position
     */
    'liquidationPriceE9': string;
    /**
     * Mark price (e9 format).
     * @type {string}
     * @memberof Position
     */
    'markPriceE9': string;
    /**
     * Notional value (e9 format).
     * @type {string}
     * @memberof Position
     */
    'notionalValueE9': string;
    /**
     * Position size (e9 format).
     * @type {string}
     * @memberof Position
     */
    'sizeE9': string;
    /**
     * Unrealized profit (e9 format).
     * @type {string}
     * @memberof Position
     */
    'unrealizedPnlE9': string;
    /**
     * 
     * @type {PositionSide}
     * @memberof Position
     */
    'side': PositionSide;
    /**
     * Initial margin required with current mark price (e9 format).
     * @type {string}
     * @memberof Position
     */
    'marginRequiredE9': string;
    /**
     * Maintenance margin required with current mark price (e9 format).
     * @type {string}
     * @memberof Position
     */
    'maintenanceMarginE9': string;
    /**
     * If the position is isolated.
     * @type {boolean}
     * @memberof Position
     */
    'isIsolated': boolean;
    /**
     * Margin value present if margin type is isolated (e9 format).
     * @type {string}
     * @memberof Position
     */
    'isolatedMarginE9': string;
    /**
     * Last update time.
     * @type {number}
     * @memberof Position
     */
    'updatedAtMillis': number;
    /**
     * Total funding rate payment (e9 format).
     * @type {string}
     * @memberof Position
     */
    'fundingRatePaymentAllTimeE9': string;
    /**
     * Funding rate payment since last position change (e9 format).
     * @type {string}
     * @memberof Position
     */
    'fundingRatePaymentSinceChangeE9': string;
    /**
     * Funding rate payment since position opened (e9 format).
     * @type {string}
     * @memberof Position
     */
    'fundingRatePaymentSinceOpenedE9': string;
}


/**
 * The side of the position, either long or short
 * @export
 * @enum {string}
 */

export const PositionSide = {
    Long: 'LONG',
    Short: 'SHORT',
    Unspecified: 'UNSPECIFIED'
} as const;

export type PositionSide = typeof PositionSide[keyof typeof PositionSide];


/**
 * 
 * @export
 * @interface PostCreateOrder202Response
 */
export interface PostCreateOrder202Response {
    /**
     * The unique identifier of this order, to be used as a lookup key
     * @type {string}
     * @memberof PostCreateOrder202Response
     */
    'orderHash': string;
}
/**
 * 
 * @export
 * @interface RecentTradesUpdates
 */
export interface RecentTradesUpdates {
    /**
     * 
     * @type {Array<Trade>}
     * @memberof RecentTradesUpdates
     */
    'trades': Array<Trade>;
}
/**
 * 
 * @export
 * @interface RefreshTokenRequest
 */
export interface RefreshTokenRequest {
    /**
     * 
     * @type {string}
     * @memberof RefreshTokenRequest
     */
    'refreshToken': string;
}
/**
 * 
 * @export
 * @interface RefreshTokenResponse
 */
export interface RefreshTokenResponse {
    /**
     * 
     * @type {string}
     * @memberof RefreshTokenResponse
     */
    'accessToken': string;
    /**
     * 
     * @type {number}
     * @memberof RefreshTokenResponse
     */
    'accessTokenValidForSeconds': number;
    /**
     * 
     * @type {string}
     * @memberof RefreshTokenResponse
     */
    'refreshToken': string;
    /**
     * 
     * @type {number}
     * @memberof RefreshTokenResponse
     */
    'refreshTokenValidForSeconds': number;
}
/**
 * 
 * @export
 * @interface RewardsSummary
 */
export interface RewardsSummary {
    /**
     * User address for the rewards earned data.
     * @type {string}
     * @memberof RewardsSummary
     */
    'UserAddress': string;
    /**
     * Total Blue token rewards earned by the user (e9 format).
     * @type {string}
     * @memberof RewardsSummary
     */
    'BlueRewards': string;
    /**
     * Total Sui token rewards earned by the user (e9 format).
     * @type {string}
     * @memberof RewardsSummary
     */
    'SuiRewards': string;
    /**
     * Total cash rewards earned by the user (e9 format).
     * @type {string}
     * @memberof RewardsSummary
     */
    'CashRewards': string;
}
/**
 * The strategy used to resolve self trades.   TAKER: On a self trade, the taker order will be cancelled  MAKER: On a self trade, the maker order will be cancelled  BOTH: On a self trade, both the taker and the maker order will be cancelled  UNSPECIFIED: set to default value 
 * @export
 * @enum {string}
 */

export const SelfTradePreventionType = {
    Taker: 'TAKER',
    Maker: 'MAKER',
    Both: 'BOTH',
    Unspecified: 'UNSPECIFIED'
} as const;

export type SelfTradePreventionType = typeof SelfTradePreventionType[keyof typeof SelfTradePreventionType];


/**
 * Response message indicating the success or failure of a subscription operation.
 * @export
 * @interface SubscriptionResponseMessage
 */
export interface SubscriptionResponseMessage {
    /**
     * Indicates if the subscription operation was successful.
     * @type {boolean}
     * @memberof SubscriptionResponseMessage
     */
    'success': boolean;
    /**
     * Additional information about the subscription operation.
     * @type {string}
     * @memberof SubscriptionResponseMessage
     */
    'message': string;
}
/**
 * Indicates the type of subscription action.
 * @export
 * @enum {string}
 */

export const SubscriptionType = {
    Subscribe: 'Subscribe',
    Unsubscribe: 'Unsubscribe'
} as const;

export type SubscriptionType = typeof SubscriptionType[keyof typeof SubscriptionType];


/**
 * 
 * @export
 * @interface TickerAllUpdate
 */
export interface TickerAllUpdate {
    /**
     * Array of detailed market ticker information for all markets.
     * @type {Array<TickerUpdate>}
     * @memberof TickerAllUpdate
     */
    'tickerAll': Array<TickerUpdate>;
}
/**
 * 
 * @export
 * @interface TickerResponse
 */
export interface TickerResponse {
    /**
     * Market symbol.
     * @type {string}
     * @memberof TickerResponse
     */
    'symbol': string;
    /**
     * Last trade quantity (e9 format).
     * @type {string}
     * @memberof TickerResponse
     */
    'lastQuantityE9': string;
    /**
     * Last trade time in milliseconds.
     * @type {number}
     * @memberof TickerResponse
     */
    'lastTimeAtMillis': number;
    /**
     * Last trade price (e9 format).
     * @type {string}
     * @memberof TickerResponse
     */
    'lastPriceE9': string;
    /**
     * Funding rate value (e9 format).
     * @type {string}
     * @memberof TickerResponse
     */
    'lastFundingRateE9': string;
    /**
     * Time in milliseconds of next funding rate update.
     * @type {number}
     * @memberof TickerResponse
     */
    'nextFundingTimeAtMillis': number;
    /**
     * 8 hr average funding rate (e9 format).
     * @type {string}
     * @memberof TickerResponse
     */
    'avgFundingRate8hrE9': string;
    /**
     * Oracle price of the asset (e9 format).
     * @type {string}
     * @memberof TickerResponse
     */
    'oraclePriceE9': string;
    /**
     * Direction of oracle price computed by comparing current oracle price to last oracle price. 0 = no change, -1 = negative trend (current < last), 1 positive trend (current > last).
     * @type {number}
     * @memberof TickerResponse
     */
    'oraclePriceDirection': number;
    /**
     * Mark price on the exchange (e9 format).
     * @type {string}
     * @memberof TickerResponse
     */
    'markPriceE9': string;
    /**
     * Direction of mark price computed by comparing current mark price to last mark price. 0 = no change, -1 = negative trend (current < last), 1 positive trend (current > last).
     * @type {number}
     * @memberof TickerResponse
     */
    'markPriceDirection': number;
    /**
     * Simple average of bestBid and bestAsk. lastPrice if either is not present (e9 format).
     * @type {string}
     * @memberof TickerResponse
     */
    'marketPriceE9': string;
    /**
     * Direction of market price computed by comparing current market price to last market price. 0 = no change, -1 = negative trend (current < last), 1 positive trend (current > last).
     * @type {number}
     * @memberof TickerResponse
     */
    'marketPriceDirection': number;
    /**
     * Best bid price (e9 format).
     * @type {string}
     * @memberof TickerResponse
     */
    'bestBidPriceE9': string;
    /**
     * Best bid quantity (e9 format).
     * @type {string}
     * @memberof TickerResponse
     */
    'bestBidQuantityE9': string;
    /**
     * Best ask price (e9 format).
     * @type {string}
     * @memberof TickerResponse
     */
    'bestAskPriceE9': string;
    /**
     * Best ask quantity (e9 format).
     * @type {string}
     * @memberof TickerResponse
     */
    'bestAskQuantityE9': string;
    /**
     * Open interest value (e9 format).
     * @type {string}
     * @memberof TickerResponse
     */
    'openInterestE9': string;
    /**
     * Highest Price in the last 24hrs (e9 format).
     * @type {string}
     * @memberof TickerResponse
     */
    'highPrice24hrE9': string;
    /**
     * Lowest Price in the last 24hrs (e9 format).
     * @type {string}
     * @memberof TickerResponse
     */
    'lowPrice24hrE9': string;
    /**
     * Total market volume in last 24hrs of asset (e9 format).
     * @type {string}
     * @memberof TickerResponse
     */
    'volume24hrE9': string;
    /**
     * Total market volume in last 24hrs in USDC (e9 format).
     * @type {string}
     * @memberof TickerResponse
     */
    'quoteVolume24hrE9': string;
    /**
     * Close price 24hrs ago (e9 format).
     * @type {string}
     * @memberof TickerResponse
     */
    'closePrice24hrE9': string;
    /**
     * Open price in the last 24hrs (e9 format).
     * @type {string}
     * @memberof TickerResponse
     */
    'openPrice24hrE9': string;
    /**
     * 24 hour close time in milliseconds.
     * @type {number}
     * @memberof TickerResponse
     */
    'closeTime24hrAtMillis': number;
    /**
     * 24 hour open time in milliseconds.
     * @type {number}
     * @memberof TickerResponse
     */
    'openTime24hrAtMillis': number;
    /**
     * First trade id in 24hr.
     * @type {number}
     * @memberof TickerResponse
     */
    'firstId24hr': number;
    /**
     * Last trade id in 24hr.
     * @type {number}
     * @memberof TickerResponse
     */
    'lastId24hr': number;
    /**
     * Total number of trades in 24hr.
     * @type {string}
     * @memberof TickerResponse
     */
    'count24hr': string;
    /**
     * 24hr Market price change (e9 format).
     * @type {string}
     * @memberof TickerResponse
     */
    'priceChange24hrE9': string;
    /**
     * 24hr Market price change in percentage (e9 format).
     * @type {string}
     * @memberof TickerResponse
     */
    'priceChangePercent24hrE9': string;
    /**
     * Last update time in milliseconds.
     * @type {number}
     * @memberof TickerResponse
     */
    'updatedAtMillis': number;
}
/**
 * Represents detailed market ticker information.
 * @export
 * @interface TickerUpdate
 */
export interface TickerUpdate {
    /**
     * Market symbol.
     * @type {string}
     * @memberof TickerUpdate
     */
    'symbol': string;
    /**
     * Last trade quantity (e9 format).
     * @type {string}
     * @memberof TickerUpdate
     */
    'lastQuantityE9': string;
    /**
     * Last trade time in milliseconds.
     * @type {number}
     * @memberof TickerUpdate
     */
    'lastTimeAtMillis': number;
    /**
     * Last trade price (e9 format).
     * @type {string}
     * @memberof TickerUpdate
     */
    'lastPriceE9': string;
    /**
     * Funding rate value (e9 format).
     * @type {string}
     * @memberof TickerUpdate
     */
    'lastFundingRateE9': string;
    /**
     * Time in milliseconds of next funding rate update.
     * @type {number}
     * @memberof TickerUpdate
     */
    'nextFundingTimeAtMillis': number;
    /**
     * 8 hr average funding rate (e9 format).
     * @type {string}
     * @memberof TickerUpdate
     */
    'avgFundingRate8hrE9': string;
    /**
     * Oracle price of the asset (e9 format).
     * @type {string}
     * @memberof TickerUpdate
     */
    'oraclePriceE9': string;
    /**
     * Direction of oracle price computed by comparing current oracle price to last oracle price. 0 = no change, -1 = negative trend (current < last), 1 = positive trend (current > last).
     * @type {number}
     * @memberof TickerUpdate
     */
    'oraclePriceDirection': number;
    /**
     * Mark price on the exchange (e9 format).
     * @type {string}
     * @memberof TickerUpdate
     */
    'markPriceE9': string;
    /**
     * Direction of mark price computed by comparing current mark price to last mark price. 0 = no change, -1 = negative trend (current < last), 1 = positive trend (current > last).
     * @type {number}
     * @memberof TickerUpdate
     */
    'markPriceDirection': number;
    /**
     * Simple average of bestBid and bestAsk, or lastPrice if either is not present (e9 format).
     * @type {string}
     * @memberof TickerUpdate
     */
    'marketPriceE9': string;
    /**
     * Direction of market price computed by comparing current market price to last market price. 0 = no change, -1 = negative trend (current < last), 1 = positive trend (current > last).
     * @type {number}
     * @memberof TickerUpdate
     */
    'marketPriceDirection': number;
    /**
     * Best bid price (e9 format).
     * @type {string}
     * @memberof TickerUpdate
     */
    'bestBidPriceE9': string;
    /**
     * Best bid quantity (e9 format).
     * @type {string}
     * @memberof TickerUpdate
     */
    'bestBidQuantityE9': string;
    /**
     * Best ask price (e9 format).
     * @type {string}
     * @memberof TickerUpdate
     */
    'bestAskPriceE9': string;
    /**
     * Best ask quantity (e9 format).
     * @type {string}
     * @memberof TickerUpdate
     */
    'bestAskQuantityE9': string;
    /**
     * Open interest value (e9 format).
     * @type {string}
     * @memberof TickerUpdate
     */
    'openInterestE9': string;
    /**
     * Highest Price in the last 24 hours (e9 format).
     * @type {string}
     * @memberof TickerUpdate
     */
    'highPrice24hrE9': string;
    /**
     * Lowest Price in the last 24 hours (e9 format).
     * @type {string}
     * @memberof TickerUpdate
     */
    'lowPrice24hrE9': string;
    /**
     * Total market volume in last 24 hours of asset (e9 format).
     * @type {string}
     * @memberof TickerUpdate
     */
    'volume24hrE9': string;
    /**
     * Total market volume in last 24 hours in USDC (e9 format).
     * @type {string}
     * @memberof TickerUpdate
     */
    'quoteVolume24hrE9': string;
    /**
     * Close price 24 hours ago (e9 format).
     * @type {string}
     * @memberof TickerUpdate
     */
    'closePrice24hrE9': string;
    /**
     * Open price in the last 24 hours (e9 format).
     * @type {string}
     * @memberof TickerUpdate
     */
    'openPrice24hrE9': string;
    /**
     * 24 hour close timestamp in milliseconds.
     * @type {number}
     * @memberof TickerUpdate
     */
    'closeTime24hrAtMillis': number;
    /**
     * 24 hour open timetamp in milliseconds.
     * @type {number}
     * @memberof TickerUpdate
     */
    'openTime24hrAtMillis': number;
    /**
     * First trade ID in the last 24 hours.
     * @type {number}
     * @memberof TickerUpdate
     */
    'firstId24hr': number;
    /**
     * Last trade ID in the last 24 hours.
     * @type {number}
     * @memberof TickerUpdate
     */
    'lastId24hr': number;
    /**
     * Total number of trades in the last 24 hours.
     * @type {string}
     * @memberof TickerUpdate
     */
    'count24hr': string;
    /**
     * 24 hour Market price change (e9 format).
     * @type {string}
     * @memberof TickerUpdate
     */
    'priceChange24hrE9': string;
    /**
     * 24 hour Market price change as a percentage (e9 format).
     * @type {string}
     * @memberof TickerUpdate
     */
    'priceChangePercent24hrE9': string;
    /**
     * Last update timestamp in milliseconds.
     * @type {number}
     * @memberof TickerUpdate
     */
    'updatedAtMillis': number;
}
/**
 * 
 * @export
 * @interface Trade
 */
export interface Trade {
    /**
     * Trade ID
     * @type {string}
     * @memberof Trade
     */
    'id': string;
    /**
     * Client order ID.
     * @type {string}
     * @memberof Trade
     */
    'clientOrderId'?: string;
    /**
     * Market address.
     * @type {string}
     * @memberof Trade
     */
    'symbol'?: string;
    /**
     * Order hash.
     * @type {string}
     * @memberof Trade
     */
    'orderHash'?: string;
    /**
     * 
     * @type {TradeType}
     * @memberof Trade
     */
    'tradeType'?: TradeType;
    /**
     * 
     * @type {TradeSide}
     * @memberof Trade
     */
    'side': TradeSide;
    /**
     * Indicates if the user was a maker to the trade.
     * @type {boolean}
     * @memberof Trade
     */
    'isMaker'?: boolean;
    /**
     * Trade price (e9 format).
     * @type {string}
     * @memberof Trade
     */
    'priceE9': string;
    /**
     * Trade quantity (e9 format).
     * @type {string}
     * @memberof Trade
     */
    'quantityE9': string;
    /**
     * Quote quantity (e9 format).
     * @type {string}
     * @memberof Trade
     */
    'quoteQuantityE9': string;
    /**
     * Realized profit and loss (e9 format).
     * @type {string}
     * @memberof Trade
     */
    'realizedPnlE9'?: string;
    /**
     * 
     * @type {PositionSide}
     * @memberof Trade
     */
    'positionSide'?: PositionSide;
    /**
     * Trading fee (e9 format).
     * @type {string}
     * @memberof Trade
     */
    'tradingFeeE9'?: string;
    /**
     * Asset used for trading fee.
     * @type {string}
     * @memberof Trade
     */
    'tradingFeeAsset'?: string;
    /**
     * Gas fee.
     * @type {string}
     * @memberof Trade
     */
    'gasFeeE9'?: string;
    /**
     * Asset used for gas fee.
     * @type {string}
     * @memberof Trade
     */
    'gasFeeAsset'?: string;
    /**
     * Trade timestamp in milliseconds since Unix epoch.
     * @type {number}
     * @memberof Trade
     */
    'executedAtMillis': number;
}


/**
 * Trade side based on the user order in this trade.
 * @export
 * @enum {string}
 */

export const TradeSide = {
    Long: 'LONG',
    Short: 'SHORT',
    Unspecified: 'UNSPECIFIED'
} as const;

export type TradeSide = typeof TradeSide[keyof typeof TradeSide];


/**
 * Type of trade.
 * @export
 * @enum {string}
 */

export const TradeType = {
    Order: 'ORDER',
    Liquidation: 'LIQUIDATION',
    Deleverage: 'DELEVERAGE',
    Unspecified: 'UNSPECIFIED'
} as const;

export type TradeType = typeof TradeType[keyof typeof TradeType];


/**
 * 
 * @export
 * @interface TradingFees
 */
export interface TradingFees {
    /**
     * The Account Maker Fee (e9 format).
     * @type {string}
     * @memberof TradingFees
     */
    'makerFeeE9': string;
    /**
     * The Account Taker Fee (e9 format).
     * @type {string}
     * @memberof TradingFees
     */
    'takerFeeE9': string;
    /**
     * Are the fees applied on the account?
     * @type {boolean}
     * @memberof TradingFees
     */
    'isApplied': boolean;
}
/**
 * 
 * @export
 * @interface Transaction
 */
export interface Transaction {
    /**
     * Transaction ID.
     * @type {string}
     * @memberof Transaction
     */
    'id': string;
    /**
     * Market address.
     * @type {string}
     * @memberof Transaction
     */
    'symbol'?: string;
    /**
     * 
     * @type {TransactionType}
     * @memberof Transaction
     */
    'type': TransactionType;
    /**
     * Amount in e9 format (positive or negative).
     * @type {string}
     * @memberof Transaction
     */
    'amountE9': string;
    /**
     * Transaction status (SUCCESS, REJECTED).
     * @type {string}
     * @memberof Transaction
     */
    'status'?: string;
    /**
     * Asset bank address.
     * @type {string}
     * @memberof Transaction
     */
    'assetSymbol': string;
    /**
     * Trade ID
     * @type {string}
     * @memberof Transaction
     */
    'tradeId'?: string;
    /**
     * Transaction timestamp in milliseconds since Unix epoch.
     * @type {number}
     * @memberof Transaction
     */
    'executedAtMillis': number;
}


/**
 * Transaction type (what caused the change in the asset balance).
 * @export
 * @enum {string}
 */

export const TransactionType = {
    Transfer: 'TRANSFER',
    Deposit: 'DEPOSIT',
    Withdraw: 'WITHDRAW',
    RealizedPnl: 'REALIZED_PNL',
    FundingFee: 'FUNDING_FEE',
    TradingFee: 'TRADING_FEE',
    TradingGasFee: 'TRADING_GAS_FEE',
    Bonus: 'BONUS',
    Unspecified: 'UNSPECIFIED'
} as const;

export type TransactionType = typeof TransactionType[keyof typeof TransactionType];


/**
 * 
 * @export
 * @interface UserCampaignRewards
 */
export interface UserCampaignRewards {
    /**
     * User address for the rewards earned data.
     * @type {string}
     * @memberof UserCampaignRewards
     */
    'UserAddress': string;
    /**
     * Name of the campaign.
     * @type {string}
     * @memberof UserCampaignRewards
     */
    'CampaignName': string;
    /**
     * Epoch number for the rewards earned data.
     * @type {number}
     * @memberof UserCampaignRewards
     */
    'EpochNumber': number;
    /**
     * Interval number for the rewards earned data.
     * @type {number}
     * @memberof UserCampaignRewards
     */
    'IntervalNumber': number;
    /**
     * Market Symbol.
     * @type {string}
     * @memberof UserCampaignRewards
     */
    'Symbol': string;
    /**
     * 
     * @type {string}
     * @memberof UserCampaignRewards
     */
    'Status': UserCampaignRewardsStatusEnum;
    /**
     * Total Blue token rewards earned in the epoch (e9 format).
     * @type {string}
     * @memberof UserCampaignRewards
     */
    'BlueRewards': string;
    /**
     * Total Sui token rewards earned in the epoch (e9 format).
     * @type {string}
     * @memberof UserCampaignRewards
     */
    'SuiRewards': string;
    /**
     * Total cash rewards earned in the epoch (e9 format).
     * @type {string}
     * @memberof UserCampaignRewards
     */
    'CashRewards': string;
}

export const UserCampaignRewardsStatusEnum = {
    Active: 'ACTIVE',
    NotStarted: 'NOT_STARTED',
    Finalized: 'FINALIZED',
    Cooldown: 'COOLDOWN'
} as const;

export type UserCampaignRewardsStatusEnum = typeof UserCampaignRewardsStatusEnum[keyof typeof UserCampaignRewardsStatusEnum];

/**
 * 
 * @export
 * @interface WithdrawRequest
 */
export interface WithdrawRequest {
    /**
     * 
     * @type {WithdrawRequestSignedFields}
     * @memberof WithdrawRequest
     */
    'signedFields': WithdrawRequestSignedFields;
    /**
     * The signature of the request, encoded from the signedFields
     * @type {string}
     * @memberof WithdrawRequest
     */
    'signature': string;
}
/**
 * 
 * @export
 * @interface WithdrawRequestSignedFields
 */
export interface WithdrawRequestSignedFields {
    /**
     * Asset symbol of the withdrawn asset
     * @type {string}
     * @memberof WithdrawRequestSignedFields
     */
    'assetSymbol': string;
    /**
     * The Account Address from which to withdraw assets
     * @type {string}
     * @memberof WithdrawRequestSignedFields
     */
    'accountAddress': string;
    /**
     * The amount in e9 of the asset that the User will withdraw from their account
     * @type {string}
     * @memberof WithdrawRequestSignedFields
     */
    'amountE9': string;
    /**
     * A uniqueness modifier for the request. This is added to guarantee uniqueness of the request. Usually a mix of timestamp and a random number
     * @type {string}
     * @memberof WithdrawRequestSignedFields
     */
    'salt': string;
    /**
     * the ID of the external datastore for the target network
     * @type {string}
     * @memberof WithdrawRequestSignedFields
     */
    'edsId': string;
    /**
     * The timestamp in milliseconds when the HTTP Request payload has been signed
     * @type {number}
     * @memberof WithdrawRequestSignedFields
     */
    'signedAtMillis': number;
}

/**
 * AccountDataApi - axios parameter creator
 * @export
 */
export const AccountDataApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get user\'s account details.
         * @param {string} [accountAddress] Account address to fetch account details by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountDetails: async (accountAddress?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/account`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountAddress !== undefined) {
                localVarQueryParameter['accountAddress'] = accountAddress;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get user\'s funding rate history
         * @param {string} [accountAddress] Account address to filter funding rate history by.
         * @param {number} [limit] Default 500; max 1000.
         * @param {number} [page] The page number to retrieve in a paginated response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountFundingRateHistory: async (accountAddress?: string, limit?: number, page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/account/fundingRateHistory`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accountAddress !== undefined) {
                localVarQueryParameter['accountAddress'] = accountAddress;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get user\'s account preferences.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountPreferences: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/account/preferences`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get user\'s trade history.
         * @param {string} [symbol] Market address to filter trades by. If not specified, returns trades for all markets.
         * @param {number} [startTimeAtMillis] Start time in milliseconds. Defaults to 7 days ago if not specified.
         * @param {number} [endTimeAtMillis] End time in milliseconds. Defaults to now if not specified. Must be greater than start time and must be less than 7 days apart.
         * @param {number} [limit] Default 500; max 1000.
         * @param {TradeType} [tradeType] Type of trade. By default returns all. UNSPECIFIED returns all.
         * @param {number} [page] The page number to retrieve in a paginated response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountTrades: async (symbol?: string, startTimeAtMillis?: number, endTimeAtMillis?: number, limit?: number, tradeType?: TradeType, page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/account/trades`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (startTimeAtMillis !== undefined) {
                localVarQueryParameter['startTimeAtMillis'] = startTimeAtMillis;
            }

            if (endTimeAtMillis !== undefined) {
                localVarQueryParameter['endTimeAtMillis'] = endTimeAtMillis;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (tradeType !== undefined) {
                localVarQueryParameter['tradeType'] = tradeType;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get user\'s transaction history (any change in balance).
         * @param {Array<TransactionType>} [types] Optional query parameter to filter transactions by type.
         * @param {string} [assetSymbol] Optional query parameter to filter transactions by asset bank address.
         * @param {number} [startTimeAtMillis] Start time in milliseconds. Defaults to 7 days ago if not specified.
         * @param {number} [endTimeAtMillis] End time in milliseconds. Defaults to now if not specified. Must be greater than start time and must be less than 7 days apart.
         * @param {number} [limit] Default 500; max 1000.
         * @param {number} [page] The page number to retrieve in a paginated response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountTransactionHistory: async (types?: Array<TransactionType>, assetSymbol?: string, startTimeAtMillis?: number, endTimeAtMillis?: number, limit?: number, page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/account/transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (types) {
                localVarQueryParameter['types'] = types;
            }

            if (assetSymbol !== undefined) {
                localVarQueryParameter['assetSymbol'] = assetSymbol;
            }

            if (startTimeAtMillis !== undefined) {
                localVarQueryParameter['startTimeAtMillis'] = startTimeAtMillis;
            }

            if (endTimeAtMillis !== undefined) {
                localVarQueryParameter['endTimeAtMillis'] = endTimeAtMillis;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountDataApi - functional programming interface
 * @export
 */
export const AccountDataApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountDataApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get user\'s account details.
         * @param {string} [accountAddress] Account address to fetch account details by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountDetails(accountAddress?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Account>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountDetails(accountAddress, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountDataApi.getAccountDetails']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get user\'s funding rate history
         * @param {string} [accountAddress] Account address to filter funding rate history by.
         * @param {number} [limit] Default 500; max 1000.
         * @param {number} [page] The page number to retrieve in a paginated response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountFundingRateHistory(accountAddress?: string, limit?: number, page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountFundingRateHistory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountFundingRateHistory(accountAddress, limit, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountDataApi.getAccountFundingRateHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get user\'s account preferences.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountPreferences(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountPreference>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountPreferences(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountDataApi.getAccountPreferences']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get user\'s trade history.
         * @param {string} [symbol] Market address to filter trades by. If not specified, returns trades for all markets.
         * @param {number} [startTimeAtMillis] Start time in milliseconds. Defaults to 7 days ago if not specified.
         * @param {number} [endTimeAtMillis] End time in milliseconds. Defaults to now if not specified. Must be greater than start time and must be less than 7 days apart.
         * @param {number} [limit] Default 500; max 1000.
         * @param {TradeType} [tradeType] Type of trade. By default returns all. UNSPECIFIED returns all.
         * @param {number} [page] The page number to retrieve in a paginated response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountTrades(symbol?: string, startTimeAtMillis?: number, endTimeAtMillis?: number, limit?: number, tradeType?: TradeType, page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Trade>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountTrades(symbol, startTimeAtMillis, endTimeAtMillis, limit, tradeType, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountDataApi.getAccountTrades']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Get user\'s transaction history (any change in balance).
         * @param {Array<TransactionType>} [types] Optional query parameter to filter transactions by type.
         * @param {string} [assetSymbol] Optional query parameter to filter transactions by asset bank address.
         * @param {number} [startTimeAtMillis] Start time in milliseconds. Defaults to 7 days ago if not specified.
         * @param {number} [endTimeAtMillis] End time in milliseconds. Defaults to now if not specified. Must be greater than start time and must be less than 7 days apart.
         * @param {number} [limit] Default 500; max 1000.
         * @param {number} [page] The page number to retrieve in a paginated response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountTransactionHistory(types?: Array<TransactionType>, assetSymbol?: string, startTimeAtMillis?: number, endTimeAtMillis?: number, limit?: number, page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Transaction>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountTransactionHistory(types, assetSymbol, startTimeAtMillis, endTimeAtMillis, limit, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountDataApi.getAccountTransactionHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AccountDataApi - factory interface
 * @export
 */
export const AccountDataApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountDataApiFp(configuration)
    return {
        /**
         * 
         * @summary Get user\'s account details.
         * @param {string} [accountAddress] Account address to fetch account details by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountDetails(accountAddress?: string, options?: RawAxiosRequestConfig): AxiosPromise<Account> {
            return localVarFp.getAccountDetails(accountAddress, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get user\'s funding rate history
         * @param {string} [accountAddress] Account address to filter funding rate history by.
         * @param {number} [limit] Default 500; max 1000.
         * @param {number} [page] The page number to retrieve in a paginated response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountFundingRateHistory(accountAddress?: string, limit?: number, page?: number, options?: RawAxiosRequestConfig): AxiosPromise<AccountFundingRateHistory> {
            return localVarFp.getAccountFundingRateHistory(accountAddress, limit, page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get user\'s account preferences.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountPreferences(options?: RawAxiosRequestConfig): AxiosPromise<AccountPreference> {
            return localVarFp.getAccountPreferences(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get user\'s trade history.
         * @param {string} [symbol] Market address to filter trades by. If not specified, returns trades for all markets.
         * @param {number} [startTimeAtMillis] Start time in milliseconds. Defaults to 7 days ago if not specified.
         * @param {number} [endTimeAtMillis] End time in milliseconds. Defaults to now if not specified. Must be greater than start time and must be less than 7 days apart.
         * @param {number} [limit] Default 500; max 1000.
         * @param {TradeType} [tradeType] Type of trade. By default returns all. UNSPECIFIED returns all.
         * @param {number} [page] The page number to retrieve in a paginated response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountTrades(symbol?: string, startTimeAtMillis?: number, endTimeAtMillis?: number, limit?: number, tradeType?: TradeType, page?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<Trade>> {
            return localVarFp.getAccountTrades(symbol, startTimeAtMillis, endTimeAtMillis, limit, tradeType, page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get user\'s transaction history (any change in balance).
         * @param {Array<TransactionType>} [types] Optional query parameter to filter transactions by type.
         * @param {string} [assetSymbol] Optional query parameter to filter transactions by asset bank address.
         * @param {number} [startTimeAtMillis] Start time in milliseconds. Defaults to 7 days ago if not specified.
         * @param {number} [endTimeAtMillis] End time in milliseconds. Defaults to now if not specified. Must be greater than start time and must be less than 7 days apart.
         * @param {number} [limit] Default 500; max 1000.
         * @param {number} [page] The page number to retrieve in a paginated response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountTransactionHistory(types?: Array<TransactionType>, assetSymbol?: string, startTimeAtMillis?: number, endTimeAtMillis?: number, limit?: number, page?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<Transaction>> {
            return localVarFp.getAccountTransactionHistory(types, assetSymbol, startTimeAtMillis, endTimeAtMillis, limit, page, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccountDataApi - object-oriented interface
 * @export
 * @class AccountDataApi
 * @extends {BaseAPI}
 */
export class AccountDataApi extends BaseAPI {
    /**
     * 
     * @summary Get user\'s account details.
     * @param {string} [accountAddress] Account address to fetch account details by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountDataApi
     */
    public getAccountDetails(accountAddress?: string, options?: RawAxiosRequestConfig) {
        return AccountDataApiFp(this.configuration).getAccountDetails(accountAddress, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get user\'s funding rate history
     * @param {string} [accountAddress] Account address to filter funding rate history by.
     * @param {number} [limit] Default 500; max 1000.
     * @param {number} [page] The page number to retrieve in a paginated response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountDataApi
     */
    public getAccountFundingRateHistory(accountAddress?: string, limit?: number, page?: number, options?: RawAxiosRequestConfig) {
        return AccountDataApiFp(this.configuration).getAccountFundingRateHistory(accountAddress, limit, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get user\'s account preferences.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountDataApi
     */
    public getAccountPreferences(options?: RawAxiosRequestConfig) {
        return AccountDataApiFp(this.configuration).getAccountPreferences(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get user\'s trade history.
     * @param {string} [symbol] Market address to filter trades by. If not specified, returns trades for all markets.
     * @param {number} [startTimeAtMillis] Start time in milliseconds. Defaults to 7 days ago if not specified.
     * @param {number} [endTimeAtMillis] End time in milliseconds. Defaults to now if not specified. Must be greater than start time and must be less than 7 days apart.
     * @param {number} [limit] Default 500; max 1000.
     * @param {TradeType} [tradeType] Type of trade. By default returns all. UNSPECIFIED returns all.
     * @param {number} [page] The page number to retrieve in a paginated response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountDataApi
     */
    public getAccountTrades(symbol?: string, startTimeAtMillis?: number, endTimeAtMillis?: number, limit?: number, tradeType?: TradeType, page?: number, options?: RawAxiosRequestConfig) {
        return AccountDataApiFp(this.configuration).getAccountTrades(symbol, startTimeAtMillis, endTimeAtMillis, limit, tradeType, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get user\'s transaction history (any change in balance).
     * @param {Array<TransactionType>} [types] Optional query parameter to filter transactions by type.
     * @param {string} [assetSymbol] Optional query parameter to filter transactions by asset bank address.
     * @param {number} [startTimeAtMillis] Start time in milliseconds. Defaults to 7 days ago if not specified.
     * @param {number} [endTimeAtMillis] End time in milliseconds. Defaults to now if not specified. Must be greater than start time and must be less than 7 days apart.
     * @param {number} [limit] Default 500; max 1000.
     * @param {number} [page] The page number to retrieve in a paginated response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountDataApi
     */
    public getAccountTransactionHistory(types?: Array<TransactionType>, assetSymbol?: string, startTimeAtMillis?: number, endTimeAtMillis?: number, limit?: number, page?: number, options?: RawAxiosRequestConfig) {
        return AccountDataApiFp(this.configuration).getAccountTransactionHistory(types, assetSymbol, startTimeAtMillis, endTimeAtMillis, limit, page, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authJwksGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/jwks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * login with token
         * @param {string} payloadSignature 
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authTokenPost: async (payloadSignature: string, loginRequest: LoginRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'payloadSignature' is not null or undefined
            assertParamExists('authTokenPost', 'payloadSignature', payloadSignature)
            // verify required parameter 'loginRequest' is not null or undefined
            assertParamExists('authTokenPost', 'loginRequest', loginRequest)
            const localVarPath = `/auth/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (payloadSignature != null) {
                localVarHeaderParameter['payloadSignature'] = String(payloadSignature);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {RefreshTokenRequest} refreshTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authTokenRefreshPut: async (refreshTokenRequest: RefreshTokenRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'refreshTokenRequest' is not null or undefined
            assertParamExists('authTokenRefreshPut', 'refreshTokenRequest', refreshTokenRequest)
            const localVarPath = `/auth/token/refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(refreshTokenRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * login compatible with BCS payload with intent bytes
         * @param {string} payloadSignature 
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authV2TokenPost: async (payloadSignature: string, loginRequest: LoginRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'payloadSignature' is not null or undefined
            assertParamExists('authV2TokenPost', 'payloadSignature', payloadSignature)
            // verify required parameter 'loginRequest' is not null or undefined
            assertParamExists('authV2TokenPost', 'loginRequest', loginRequest)
            const localVarPath = `/auth/v2/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (payloadSignature != null) {
                localVarHeaderParameter['payloadSignature'] = String(payloadSignature);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authJwksGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any | undefined; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authJwksGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authJwksGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * login with token
         * @param {string} payloadSignature 
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authTokenPost(payloadSignature: string, loginRequest: LoginRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authTokenPost(payloadSignature, loginRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authTokenPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {RefreshTokenRequest} refreshTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authTokenRefreshPut(refreshTokenRequest: RefreshTokenRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RefreshTokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authTokenRefreshPut(refreshTokenRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authTokenRefreshPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * login compatible with BCS payload with intent bytes
         * @param {string} payloadSignature 
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authV2TokenPost(payloadSignature: string, loginRequest: LoginRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authV2TokenPost(payloadSignature, loginRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authV2TokenPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authJwksGet(options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any | undefined; }> {
            return localVarFp.authJwksGet(options).then((request) => request(axios, basePath));
        },
        /**
         * login with token
         * @param {string} payloadSignature 
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authTokenPost(payloadSignature: string, loginRequest: LoginRequest, options?: RawAxiosRequestConfig): AxiosPromise<LoginResponse> {
            return localVarFp.authTokenPost(payloadSignature, loginRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {RefreshTokenRequest} refreshTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authTokenRefreshPut(refreshTokenRequest: RefreshTokenRequest, options?: RawAxiosRequestConfig): AxiosPromise<RefreshTokenResponse> {
            return localVarFp.authTokenRefreshPut(refreshTokenRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * login compatible with BCS payload with intent bytes
         * @param {string} payloadSignature 
         * @param {LoginRequest} loginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authV2TokenPost(payloadSignature: string, loginRequest: LoginRequest, options?: RawAxiosRequestConfig): AxiosPromise<LoginResponse> {
            return localVarFp.authV2TokenPost(payloadSignature, loginRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authJwksGet(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authJwksGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * login with token
     * @param {string} payloadSignature 
     * @param {LoginRequest} loginRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authTokenPost(payloadSignature: string, loginRequest: LoginRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authTokenPost(payloadSignature, loginRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {RefreshTokenRequest} refreshTokenRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authTokenRefreshPut(refreshTokenRequest: RefreshTokenRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authTokenRefreshPut(refreshTokenRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * login compatible with BCS payload with intent bytes
     * @param {string} payloadSignature 
     * @param {LoginRequest} loginRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authV2TokenPost(payloadSignature: string, loginRequest: LoginRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authV2TokenPost(payloadSignature, loginRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ExchangeApi - axios parameter creator
 * @export
 */
export const ExchangeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get all market ticker information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllMarketTicker: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/exchange/tickers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Kline/candlestick data.
         * @param {string} symbol The market symbol to get the klines for.
         * @param {KlineInterval} interval The interval to get the klines for.
         * @param {CandlePriceType} type Candle price type (last price, market price or oracle).
         * @param {number} [startTimeAtMillis] Timestamp in milliseconds in ms to get klines from.
         * @param {number} [endTimeAtMillis] Timestamp in milliseconds in ms to get klines until.
         * @param {number} [limit] Default 50; max 1000.
         * @param {number} [page] The page number to retrieve in a paginated response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCandlestickData: async (symbol: string, interval: KlineInterval, type: CandlePriceType, startTimeAtMillis?: number, endTimeAtMillis?: number, limit?: number, page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getCandlestickData', 'symbol', symbol)
            // verify required parameter 'interval' is not null or undefined
            assertParamExists('getCandlestickData', 'interval', interval)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('getCandlestickData', 'type', type)
            const localVarPath = `/v1/exchange/candlesticks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (startTimeAtMillis !== undefined) {
                localVarQueryParameter['startTimeAtMillis'] = startTimeAtMillis;
            }

            if (endTimeAtMillis !== undefined) {
                localVarQueryParameter['endTimeAtMillis'] = endTimeAtMillis;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the current exchange information including available margin assets, markets, and rules.
         * @summary Get exchange information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExchangeInfo: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/exchange/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the funding rate history for a specific market address.
         * @summary Get funding rate history
         * @param {string} symbol The market symbol to get funding rate history for
         * @param {number} [limit] Number of records to return. Default is 100; max is 1000.
         * @param {number} [startTimeAtMillis] The timestamp specifies the earliest point in time for which data should be returned. The value is not included.
         * @param {number} [endTimeAtMillis] The timestamp specifies the latest point in time for which data should be returned. The value is included.
         * @param {number} [page] The page number to retrieve in a paginated response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFundingRateHistory: async (symbol: string, limit?: number, startTimeAtMillis?: number, endTimeAtMillis?: number, page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getFundingRateHistory', 'symbol', symbol)
            const localVarPath = `/v1/exchange/fundingRateHistory`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startTimeAtMillis !== undefined) {
                localVarQueryParameter['startTimeAtMillis'] = startTimeAtMillis;
            }

            if (endTimeAtMillis !== undefined) {
                localVarQueryParameter['endTimeAtMillis'] = endTimeAtMillis;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Aggregated market ticker information
         * @param {string} symbol Market symbol.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarketTicker: async (symbol: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getMarketTicker', 'symbol', symbol)
            const localVarPath = `/v1/exchange/ticker`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Orderbook depth
         * @param {string} symbol Market symbol to get the orderbook depth for.
         * @param {number} [limit] Maximum number of bids and asks to return. Default 500; max 1000.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderbookDepth: async (symbol: string, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getOrderbookDepth', 'symbol', symbol)
            const localVarPath = `/v1/exchange/depth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Recent trades list
         * @param {string} symbol The market symbol to get the trades for.
         * @param {GetRecentTradesTradeTypeEnum} [tradeType] Type of trade.
         * @param {number} [limit] Default 500; max 1000.
         * @param {number} [startTimeAtMillis] The timestamp specifies the earliest point in time for which data should be returned. The value is not included.
         * @param {number} [endTimeAtMillis] The timestamp specifies the latest point in time for which data should be returned. The value is included.
         * @param {number} [page] The page number to retrieve in a paginated response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecentTrades: async (symbol: string, tradeType?: GetRecentTradesTradeTypeEnum, limit?: number, startTimeAtMillis?: number, endTimeAtMillis?: number, page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getRecentTrades', 'symbol', symbol)
            const localVarPath = `/v1/exchange/trades`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (tradeType !== undefined) {
                localVarQueryParameter['tradeType'] = tradeType;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startTimeAtMillis !== undefined) {
                localVarQueryParameter['startTimeAtMillis'] = startTimeAtMillis;
            }

            if (endTimeAtMillis !== undefined) {
                localVarQueryParameter['endTimeAtMillis'] = endTimeAtMillis;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ExchangeApi - functional programming interface
 * @export
 */
export const ExchangeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ExchangeApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get all market ticker information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllMarketTicker(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TickerResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllMarketTicker(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExchangeApi.getAllMarketTicker']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Kline/candlestick data.
         * @param {string} symbol The market symbol to get the klines for.
         * @param {KlineInterval} interval The interval to get the klines for.
         * @param {CandlePriceType} type Candle price type (last price, market price or oracle).
         * @param {number} [startTimeAtMillis] Timestamp in milliseconds in ms to get klines from.
         * @param {number} [endTimeAtMillis] Timestamp in milliseconds in ms to get klines until.
         * @param {number} [limit] Default 50; max 1000.
         * @param {number} [page] The page number to retrieve in a paginated response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCandlestickData(symbol: string, interval: KlineInterval, type: CandlePriceType, startTimeAtMillis?: number, endTimeAtMillis?: number, limit?: number, page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Array<string>>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCandlestickData(symbol, interval, type, startTimeAtMillis, endTimeAtMillis, limit, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExchangeApi.getCandlestickData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the current exchange information including available margin assets, markets, and rules.
         * @summary Get exchange information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExchangeInfo(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExchangeInfoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExchangeInfo(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExchangeApi.getExchangeInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the funding rate history for a specific market address.
         * @summary Get funding rate history
         * @param {string} symbol The market symbol to get funding rate history for
         * @param {number} [limit] Number of records to return. Default is 100; max is 1000.
         * @param {number} [startTimeAtMillis] The timestamp specifies the earliest point in time for which data should be returned. The value is not included.
         * @param {number} [endTimeAtMillis] The timestamp specifies the latest point in time for which data should be returned. The value is included.
         * @param {number} [page] The page number to retrieve in a paginated response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFundingRateHistory(symbol: string, limit?: number, startTimeAtMillis?: number, endTimeAtMillis?: number, page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FundingRateEntry>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFundingRateHistory(symbol, limit, startTimeAtMillis, endTimeAtMillis, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExchangeApi.getFundingRateHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Aggregated market ticker information
         * @param {string} symbol Market symbol.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMarketTicker(symbol: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TickerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMarketTicker(symbol, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExchangeApi.getMarketTicker']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Orderbook depth
         * @param {string} symbol Market symbol to get the orderbook depth for.
         * @param {number} [limit] Maximum number of bids and asks to return. Default 500; max 1000.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrderbookDepth(symbol: string, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderbookDepthResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrderbookDepth(symbol, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExchangeApi.getOrderbookDepth']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary Recent trades list
         * @param {string} symbol The market symbol to get the trades for.
         * @param {GetRecentTradesTradeTypeEnum} [tradeType] Type of trade.
         * @param {number} [limit] Default 500; max 1000.
         * @param {number} [startTimeAtMillis] The timestamp specifies the earliest point in time for which data should be returned. The value is not included.
         * @param {number} [endTimeAtMillis] The timestamp specifies the latest point in time for which data should be returned. The value is included.
         * @param {number} [page] The page number to retrieve in a paginated response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecentTrades(symbol: string, tradeType?: GetRecentTradesTradeTypeEnum, limit?: number, startTimeAtMillis?: number, endTimeAtMillis?: number, page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Trade>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRecentTrades(symbol, tradeType, limit, startTimeAtMillis, endTimeAtMillis, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExchangeApi.getRecentTrades']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ExchangeApi - factory interface
 * @export
 */
export const ExchangeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ExchangeApiFp(configuration)
    return {
        /**
         * 
         * @summary Get all market ticker information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllMarketTicker(options?: RawAxiosRequestConfig): AxiosPromise<Array<TickerResponse>> {
            return localVarFp.getAllMarketTicker(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Kline/candlestick data.
         * @param {string} symbol The market symbol to get the klines for.
         * @param {KlineInterval} interval The interval to get the klines for.
         * @param {CandlePriceType} type Candle price type (last price, market price or oracle).
         * @param {number} [startTimeAtMillis] Timestamp in milliseconds in ms to get klines from.
         * @param {number} [endTimeAtMillis] Timestamp in milliseconds in ms to get klines until.
         * @param {number} [limit] Default 50; max 1000.
         * @param {number} [page] The page number to retrieve in a paginated response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCandlestickData(symbol: string, interval: KlineInterval, type: CandlePriceType, startTimeAtMillis?: number, endTimeAtMillis?: number, limit?: number, page?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<Array<string>>> {
            return localVarFp.getCandlestickData(symbol, interval, type, startTimeAtMillis, endTimeAtMillis, limit, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the current exchange information including available margin assets, markets, and rules.
         * @summary Get exchange information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExchangeInfo(options?: RawAxiosRequestConfig): AxiosPromise<ExchangeInfoResponse> {
            return localVarFp.getExchangeInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the funding rate history for a specific market address.
         * @summary Get funding rate history
         * @param {string} symbol The market symbol to get funding rate history for
         * @param {number} [limit] Number of records to return. Default is 100; max is 1000.
         * @param {number} [startTimeAtMillis] The timestamp specifies the earliest point in time for which data should be returned. The value is not included.
         * @param {number} [endTimeAtMillis] The timestamp specifies the latest point in time for which data should be returned. The value is included.
         * @param {number} [page] The page number to retrieve in a paginated response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFundingRateHistory(symbol: string, limit?: number, startTimeAtMillis?: number, endTimeAtMillis?: number, page?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<FundingRateEntry>> {
            return localVarFp.getFundingRateHistory(symbol, limit, startTimeAtMillis, endTimeAtMillis, page, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Aggregated market ticker information
         * @param {string} symbol Market symbol.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarketTicker(symbol: string, options?: RawAxiosRequestConfig): AxiosPromise<TickerResponse> {
            return localVarFp.getMarketTicker(symbol, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Orderbook depth
         * @param {string} symbol Market symbol to get the orderbook depth for.
         * @param {number} [limit] Maximum number of bids and asks to return. Default 500; max 1000.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderbookDepth(symbol: string, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<OrderbookDepthResponse> {
            return localVarFp.getOrderbookDepth(symbol, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Recent trades list
         * @param {string} symbol The market symbol to get the trades for.
         * @param {GetRecentTradesTradeTypeEnum} [tradeType] Type of trade.
         * @param {number} [limit] Default 500; max 1000.
         * @param {number} [startTimeAtMillis] The timestamp specifies the earliest point in time for which data should be returned. The value is not included.
         * @param {number} [endTimeAtMillis] The timestamp specifies the latest point in time for which data should be returned. The value is included.
         * @param {number} [page] The page number to retrieve in a paginated response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecentTrades(symbol: string, tradeType?: GetRecentTradesTradeTypeEnum, limit?: number, startTimeAtMillis?: number, endTimeAtMillis?: number, page?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<Trade>> {
            return localVarFp.getRecentTrades(symbol, tradeType, limit, startTimeAtMillis, endTimeAtMillis, page, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ExchangeApi - object-oriented interface
 * @export
 * @class ExchangeApi
 * @extends {BaseAPI}
 */
export class ExchangeApi extends BaseAPI {
    /**
     * 
     * @summary Get all market ticker information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExchangeApi
     */
    public getAllMarketTicker(options?: RawAxiosRequestConfig) {
        return ExchangeApiFp(this.configuration).getAllMarketTicker(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Kline/candlestick data.
     * @param {string} symbol The market symbol to get the klines for.
     * @param {KlineInterval} interval The interval to get the klines for.
     * @param {CandlePriceType} type Candle price type (last price, market price or oracle).
     * @param {number} [startTimeAtMillis] Timestamp in milliseconds in ms to get klines from.
     * @param {number} [endTimeAtMillis] Timestamp in milliseconds in ms to get klines until.
     * @param {number} [limit] Default 50; max 1000.
     * @param {number} [page] The page number to retrieve in a paginated response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExchangeApi
     */
    public getCandlestickData(symbol: string, interval: KlineInterval, type: CandlePriceType, startTimeAtMillis?: number, endTimeAtMillis?: number, limit?: number, page?: number, options?: RawAxiosRequestConfig) {
        return ExchangeApiFp(this.configuration).getCandlestickData(symbol, interval, type, startTimeAtMillis, endTimeAtMillis, limit, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the current exchange information including available margin assets, markets, and rules.
     * @summary Get exchange information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExchangeApi
     */
    public getExchangeInfo(options?: RawAxiosRequestConfig) {
        return ExchangeApiFp(this.configuration).getExchangeInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the funding rate history for a specific market address.
     * @summary Get funding rate history
     * @param {string} symbol The market symbol to get funding rate history for
     * @param {number} [limit] Number of records to return. Default is 100; max is 1000.
     * @param {number} [startTimeAtMillis] The timestamp specifies the earliest point in time for which data should be returned. The value is not included.
     * @param {number} [endTimeAtMillis] The timestamp specifies the latest point in time for which data should be returned. The value is included.
     * @param {number} [page] The page number to retrieve in a paginated response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExchangeApi
     */
    public getFundingRateHistory(symbol: string, limit?: number, startTimeAtMillis?: number, endTimeAtMillis?: number, page?: number, options?: RawAxiosRequestConfig) {
        return ExchangeApiFp(this.configuration).getFundingRateHistory(symbol, limit, startTimeAtMillis, endTimeAtMillis, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Aggregated market ticker information
     * @param {string} symbol Market symbol.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExchangeApi
     */
    public getMarketTicker(symbol: string, options?: RawAxiosRequestConfig) {
        return ExchangeApiFp(this.configuration).getMarketTicker(symbol, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Orderbook depth
     * @param {string} symbol Market symbol to get the orderbook depth for.
     * @param {number} [limit] Maximum number of bids and asks to return. Default 500; max 1000.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExchangeApi
     */
    public getOrderbookDepth(symbol: string, limit?: number, options?: RawAxiosRequestConfig) {
        return ExchangeApiFp(this.configuration).getOrderbookDepth(symbol, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Recent trades list
     * @param {string} symbol The market symbol to get the trades for.
     * @param {GetRecentTradesTradeTypeEnum} [tradeType] Type of trade.
     * @param {number} [limit] Default 500; max 1000.
     * @param {number} [startTimeAtMillis] The timestamp specifies the earliest point in time for which data should be returned. The value is not included.
     * @param {number} [endTimeAtMillis] The timestamp specifies the latest point in time for which data should be returned. The value is included.
     * @param {number} [page] The page number to retrieve in a paginated response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExchangeApi
     */
    public getRecentTrades(symbol: string, tradeType?: GetRecentTradesTradeTypeEnum, limit?: number, startTimeAtMillis?: number, endTimeAtMillis?: number, page?: number, options?: RawAxiosRequestConfig) {
        return ExchangeApiFp(this.configuration).getRecentTrades(symbol, tradeType, limit, startTimeAtMillis, endTimeAtMillis, page, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetRecentTradesTradeTypeEnum = {
    Order: 'Order',
    Liquidation: 'Liquidation',
    Deleverage: 'Deleverage',
    Unspecified: 'UNSPECIFIED'
} as const;
export type GetRecentTradesTradeTypeEnum = typeof GetRecentTradesTradeTypeEnum[keyof typeof GetRecentTradesTradeTypeEnum];


/**
 * RewardsApi - axios parameter creator
 * @export
 */
export const RewardsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns the rewards earned by users for a specific campaign
         * @summary Get rewards information for a specific campaign
         * @param {string} campaignName Specify the campaign name
         * @param {number} [epochNumber] Optionally specify epoch number.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCampaignRewards: async (campaignName: string, epochNumber?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'campaignName' is not null or undefined
            assertParamExists('getCampaignRewards', 'campaignName', campaignName)
            const localVarPath = `/v1/rewards/campaign`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (campaignName !== undefined) {
                localVarQueryParameter['campaignName'] = campaignName;
            }

            if (epochNumber !== undefined) {
                localVarQueryParameter['epochNumber'] = epochNumber;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the rewards earned by users for the intervals .
         * @summary Get rewards information for the intervals
         * @param {number} [intervalNumber] Optionally specify interval number.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRewards: async (intervalNumber?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/rewards`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (intervalNumber !== undefined) {
                localVarQueryParameter['intervalNumber'] = intervalNumber;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the metadata for the rewards campaigns.
         * @summary Get rewards metadata for the campaigns
         * @param {string} [campaignName] Specify the campaign name
         * @param {GetRewardsCampaignMetadataStatusEnum} [status] Optionally specify the status of the campaigns.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRewardsCampaignMetadata: async (campaignName?: string, status?: GetRewardsCampaignMetadataStatusEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/rewards/metadata/campaign`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (campaignName !== undefined) {
                localVarQueryParameter['campaignName'] = campaignName;
            }

            if (status !== undefined) {
                localVarQueryParameter['Status'] = status;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the latest epoch configs for the campaigns
         * @summary Gets the latest epoch configs for the campaigns
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRewardsEpochConfigMetadata: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/rewards/metadata/epoch/configs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the latest or next epocht epoch for campaign.
         * @summary Gets the latest or next epoch for campaign.
         * @param {string} [campaignName] Specify the campaign name
         * @param {GetRewardsEpochMetadataEpochEnum} [epoch] Specify the string \&quot;next\&quot; or \&quot;latest\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRewardsEpochMetadata: async (campaignName?: string, epoch?: GetRewardsEpochMetadataEpochEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/rewards/metadata/epoch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (campaignName !== undefined) {
                localVarQueryParameter['campaignName'] = campaignName;
            }

            if (epoch !== undefined) {
                localVarQueryParameter['epoch'] = epoch;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the interval metadata for provided parameters
         * @summary Gets the interval metadata for provided parameters
         * @param {number} [interval] Either specify an interval number or the string \&quot;next\&quot; or \&quot;latest\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRewardsIntervalMetadata: async (interval?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/rewards/metadata/interval`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the all time rewards earned by users.
         * @summary Get rewards information for all time rewards earned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRewardsSummary: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/rewards/summary`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RewardsApi - functional programming interface
 * @export
 */
export const RewardsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RewardsApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns the rewards earned by users for a specific campaign
         * @summary Get rewards information for a specific campaign
         * @param {string} campaignName Specify the campaign name
         * @param {number} [epochNumber] Optionally specify epoch number.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCampaignRewards(campaignName: string, epochNumber?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CampaignRewards>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCampaignRewards(campaignName, epochNumber, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RewardsApi.getCampaignRewards']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the rewards earned by users for the intervals .
         * @summary Get rewards information for the intervals
         * @param {number} [intervalNumber] Optionally specify interval number.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRewards(intervalNumber?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<IntervalRewards>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRewards(intervalNumber, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RewardsApi.getRewards']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the metadata for the rewards campaigns.
         * @summary Get rewards metadata for the campaigns
         * @param {string} [campaignName] Specify the campaign name
         * @param {GetRewardsCampaignMetadataStatusEnum} [status] Optionally specify the status of the campaigns.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRewardsCampaignMetadata(campaignName?: string, status?: GetRewardsCampaignMetadataStatusEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CampaignMetadata>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRewardsCampaignMetadata(campaignName, status, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RewardsApi.getRewardsCampaignMetadata']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the latest epoch configs for the campaigns
         * @summary Gets the latest epoch configs for the campaigns
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRewardsEpochConfigMetadata(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EpochConfigs>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRewardsEpochConfigMetadata(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RewardsApi.getRewardsEpochConfigMetadata']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the latest or next epocht epoch for campaign.
         * @summary Gets the latest or next epoch for campaign.
         * @param {string} [campaignName] Specify the campaign name
         * @param {GetRewardsEpochMetadataEpochEnum} [epoch] Specify the string \&quot;next\&quot; or \&quot;latest\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRewardsEpochMetadata(campaignName?: string, epoch?: GetRewardsEpochMetadataEpochEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EpochMetadata>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRewardsEpochMetadata(campaignName, epoch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RewardsApi.getRewardsEpochMetadata']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the interval metadata for provided parameters
         * @summary Gets the interval metadata for provided parameters
         * @param {number} [interval] Either specify an interval number or the string \&quot;next\&quot; or \&quot;latest\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRewardsIntervalMetadata(interval?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<IntervalMetadata>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRewardsIntervalMetadata(interval, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RewardsApi.getRewardsIntervalMetadata']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the all time rewards earned by users.
         * @summary Get rewards information for all time rewards earned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRewardsSummary(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RewardsSummary>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRewardsSummary(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RewardsApi.getRewardsSummary']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RewardsApi - factory interface
 * @export
 */
export const RewardsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RewardsApiFp(configuration)
    return {
        /**
         * Returns the rewards earned by users for a specific campaign
         * @summary Get rewards information for a specific campaign
         * @param {string} campaignName Specify the campaign name
         * @param {number} [epochNumber] Optionally specify epoch number.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCampaignRewards(campaignName: string, epochNumber?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<CampaignRewards>> {
            return localVarFp.getCampaignRewards(campaignName, epochNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the rewards earned by users for the intervals .
         * @summary Get rewards information for the intervals
         * @param {number} [intervalNumber] Optionally specify interval number.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRewards(intervalNumber?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<IntervalRewards>> {
            return localVarFp.getRewards(intervalNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the metadata for the rewards campaigns.
         * @summary Get rewards metadata for the campaigns
         * @param {string} [campaignName] Specify the campaign name
         * @param {GetRewardsCampaignMetadataStatusEnum} [status] Optionally specify the status of the campaigns.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRewardsCampaignMetadata(campaignName?: string, status?: GetRewardsCampaignMetadataStatusEnum, options?: RawAxiosRequestConfig): AxiosPromise<Array<CampaignMetadata>> {
            return localVarFp.getRewardsCampaignMetadata(campaignName, status, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the latest epoch configs for the campaigns
         * @summary Gets the latest epoch configs for the campaigns
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRewardsEpochConfigMetadata(options?: RawAxiosRequestConfig): AxiosPromise<Array<EpochConfigs>> {
            return localVarFp.getRewardsEpochConfigMetadata(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the latest or next epocht epoch for campaign.
         * @summary Gets the latest or next epoch for campaign.
         * @param {string} [campaignName] Specify the campaign name
         * @param {GetRewardsEpochMetadataEpochEnum} [epoch] Specify the string \&quot;next\&quot; or \&quot;latest\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRewardsEpochMetadata(campaignName?: string, epoch?: GetRewardsEpochMetadataEpochEnum, options?: RawAxiosRequestConfig): AxiosPromise<Array<EpochMetadata>> {
            return localVarFp.getRewardsEpochMetadata(campaignName, epoch, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the interval metadata for provided parameters
         * @summary Gets the interval metadata for provided parameters
         * @param {number} [interval] Either specify an interval number or the string \&quot;next\&quot; or \&quot;latest\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRewardsIntervalMetadata(interval?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<IntervalMetadata>> {
            return localVarFp.getRewardsIntervalMetadata(interval, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the all time rewards earned by users.
         * @summary Get rewards information for all time rewards earned
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRewardsSummary(options?: RawAxiosRequestConfig): AxiosPromise<Array<RewardsSummary>> {
            return localVarFp.getRewardsSummary(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RewardsApi - object-oriented interface
 * @export
 * @class RewardsApi
 * @extends {BaseAPI}
 */
export class RewardsApi extends BaseAPI {
    /**
     * Returns the rewards earned by users for a specific campaign
     * @summary Get rewards information for a specific campaign
     * @param {string} campaignName Specify the campaign name
     * @param {number} [epochNumber] Optionally specify epoch number.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RewardsApi
     */
    public getCampaignRewards(campaignName: string, epochNumber?: number, options?: RawAxiosRequestConfig) {
        return RewardsApiFp(this.configuration).getCampaignRewards(campaignName, epochNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the rewards earned by users for the intervals .
     * @summary Get rewards information for the intervals
     * @param {number} [intervalNumber] Optionally specify interval number.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RewardsApi
     */
    public getRewards(intervalNumber?: number, options?: RawAxiosRequestConfig) {
        return RewardsApiFp(this.configuration).getRewards(intervalNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the metadata for the rewards campaigns.
     * @summary Get rewards metadata for the campaigns
     * @param {string} [campaignName] Specify the campaign name
     * @param {GetRewardsCampaignMetadataStatusEnum} [status] Optionally specify the status of the campaigns.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RewardsApi
     */
    public getRewardsCampaignMetadata(campaignName?: string, status?: GetRewardsCampaignMetadataStatusEnum, options?: RawAxiosRequestConfig) {
        return RewardsApiFp(this.configuration).getRewardsCampaignMetadata(campaignName, status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the latest epoch configs for the campaigns
     * @summary Gets the latest epoch configs for the campaigns
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RewardsApi
     */
    public getRewardsEpochConfigMetadata(options?: RawAxiosRequestConfig) {
        return RewardsApiFp(this.configuration).getRewardsEpochConfigMetadata(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the latest or next epocht epoch for campaign.
     * @summary Gets the latest or next epoch for campaign.
     * @param {string} [campaignName] Specify the campaign name
     * @param {GetRewardsEpochMetadataEpochEnum} [epoch] Specify the string \&quot;next\&quot; or \&quot;latest\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RewardsApi
     */
    public getRewardsEpochMetadata(campaignName?: string, epoch?: GetRewardsEpochMetadataEpochEnum, options?: RawAxiosRequestConfig) {
        return RewardsApiFp(this.configuration).getRewardsEpochMetadata(campaignName, epoch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the interval metadata for provided parameters
     * @summary Gets the interval metadata for provided parameters
     * @param {number} [interval] Either specify an interval number or the string \&quot;next\&quot; or \&quot;latest\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RewardsApi
     */
    public getRewardsIntervalMetadata(interval?: number, options?: RawAxiosRequestConfig) {
        return RewardsApiFp(this.configuration).getRewardsIntervalMetadata(interval, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the all time rewards earned by users.
     * @summary Get rewards information for all time rewards earned
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RewardsApi
     */
    public getRewardsSummary(options?: RawAxiosRequestConfig) {
        return RewardsApiFp(this.configuration).getRewardsSummary(options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetRewardsCampaignMetadataStatusEnum = {
    Active: 'ACTIVE',
    Inactive: 'INACTIVE'
} as const;
export type GetRewardsCampaignMetadataStatusEnum = typeof GetRewardsCampaignMetadataStatusEnum[keyof typeof GetRewardsCampaignMetadataStatusEnum];
/**
 * @export
 */
export const GetRewardsEpochMetadataEpochEnum = {
    Next: 'next',
    Latest: 'latest'
} as const;
export type GetRewardsEpochMetadataEpochEnum = typeof GetRewardsEpochMetadataEpochEnum[keyof typeof GetRewardsEpochMetadataEpochEnum];


/**
 * StreamsApi - axios parameter creator
 * @export
 */
export const StreamsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * WebSocket Account Streams URL.
         * @summary WebSocket Account Streams
         * @param {string} authorization 
         * @param {WebSocketAccountDataUpgradeEnum} upgrade 
         * @param {string} secWebSocketKey WebSocket key used during the handshake.
         * @param {WebSocketAccountDataSecWebSocketVersionEnum} secWebSocketVersion WebSocket protocol version.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webSocketAccountData: async (authorization: string, upgrade: WebSocketAccountDataUpgradeEnum, secWebSocketKey: string, secWebSocketVersion: WebSocketAccountDataSecWebSocketVersionEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('webSocketAccountData', 'authorization', authorization)
            // verify required parameter 'upgrade' is not null or undefined
            assertParamExists('webSocketAccountData', 'upgrade', upgrade)
            // verify required parameter 'secWebSocketKey' is not null or undefined
            assertParamExists('webSocketAccountData', 'secWebSocketKey', secWebSocketKey)
            // verify required parameter 'secWebSocketVersion' is not null or undefined
            assertParamExists('webSocketAccountData', 'secWebSocketVersion', secWebSocketVersion)
            const localVarPath = `/ws/account`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            if (upgrade != null) {
                localVarHeaderParameter['Upgrade'] = String(upgrade);
            }
            if (secWebSocketKey != null) {
                localVarHeaderParameter['Sec-WebSocket-Key'] = String(secWebSocketKey);
            }
            if (secWebSocketVersion != null) {
                localVarHeaderParameter['Sec-WebSocket-Version'] = String(secWebSocketVersion);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * WebSocket Market Streams URL.
         * @summary WebSocket Market Streams
         * @param {WebSocketMarketDataUpgradeEnum} upgrade 
         * @param {string} secWebSocketKey WebSocket key used during the handshake.
         * @param {WebSocketMarketDataSecWebSocketVersionEnum} secWebSocketVersion WebSocket protocol version.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webSocketMarketData: async (upgrade: WebSocketMarketDataUpgradeEnum, secWebSocketKey: string, secWebSocketVersion: WebSocketMarketDataSecWebSocketVersionEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'upgrade' is not null or undefined
            assertParamExists('webSocketMarketData', 'upgrade', upgrade)
            // verify required parameter 'secWebSocketKey' is not null or undefined
            assertParamExists('webSocketMarketData', 'secWebSocketKey', secWebSocketKey)
            // verify required parameter 'secWebSocketVersion' is not null or undefined
            assertParamExists('webSocketMarketData', 'secWebSocketVersion', secWebSocketVersion)
            const localVarPath = `/ws/market`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (upgrade != null) {
                localVarHeaderParameter['Upgrade'] = String(upgrade);
            }
            if (secWebSocketKey != null) {
                localVarHeaderParameter['Sec-WebSocket-Key'] = String(secWebSocketKey);
            }
            if (secWebSocketVersion != null) {
                localVarHeaderParameter['Sec-WebSocket-Version'] = String(secWebSocketVersion);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StreamsApi - functional programming interface
 * @export
 */
export const StreamsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StreamsApiAxiosParamCreator(configuration)
    return {
        /**
         * WebSocket Account Streams URL.
         * @summary WebSocket Account Streams
         * @param {string} authorization 
         * @param {WebSocketAccountDataUpgradeEnum} upgrade 
         * @param {string} secWebSocketKey WebSocket key used during the handshake.
         * @param {WebSocketAccountDataSecWebSocketVersionEnum} secWebSocketVersion WebSocket protocol version.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webSocketAccountData(authorization: string, upgrade: WebSocketAccountDataUpgradeEnum, secWebSocketKey: string, secWebSocketVersion: WebSocketAccountDataSecWebSocketVersionEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webSocketAccountData(authorization, upgrade, secWebSocketKey, secWebSocketVersion, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StreamsApi.webSocketAccountData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * WebSocket Market Streams URL.
         * @summary WebSocket Market Streams
         * @param {WebSocketMarketDataUpgradeEnum} upgrade 
         * @param {string} secWebSocketKey WebSocket key used during the handshake.
         * @param {WebSocketMarketDataSecWebSocketVersionEnum} secWebSocketVersion WebSocket protocol version.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webSocketMarketData(upgrade: WebSocketMarketDataUpgradeEnum, secWebSocketKey: string, secWebSocketVersion: WebSocketMarketDataSecWebSocketVersionEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webSocketMarketData(upgrade, secWebSocketKey, secWebSocketVersion, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StreamsApi.webSocketMarketData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * StreamsApi - factory interface
 * @export
 */
export const StreamsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StreamsApiFp(configuration)
    return {
        /**
         * WebSocket Account Streams URL.
         * @summary WebSocket Account Streams
         * @param {string} authorization 
         * @param {WebSocketAccountDataUpgradeEnum} upgrade 
         * @param {string} secWebSocketKey WebSocket key used during the handshake.
         * @param {WebSocketAccountDataSecWebSocketVersionEnum} secWebSocketVersion WebSocket protocol version.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webSocketAccountData(authorization: string, upgrade: WebSocketAccountDataUpgradeEnum, secWebSocketKey: string, secWebSocketVersion: WebSocketAccountDataSecWebSocketVersionEnum, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.webSocketAccountData(authorization, upgrade, secWebSocketKey, secWebSocketVersion, options).then((request) => request(axios, basePath));
        },
        /**
         * WebSocket Market Streams URL.
         * @summary WebSocket Market Streams
         * @param {WebSocketMarketDataUpgradeEnum} upgrade 
         * @param {string} secWebSocketKey WebSocket key used during the handshake.
         * @param {WebSocketMarketDataSecWebSocketVersionEnum} secWebSocketVersion WebSocket protocol version.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webSocketMarketData(upgrade: WebSocketMarketDataUpgradeEnum, secWebSocketKey: string, secWebSocketVersion: WebSocketMarketDataSecWebSocketVersionEnum, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.webSocketMarketData(upgrade, secWebSocketKey, secWebSocketVersion, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StreamsApi - object-oriented interface
 * @export
 * @class StreamsApi
 * @extends {BaseAPI}
 */
export class StreamsApi extends BaseAPI {
    /**
     * WebSocket Account Streams URL.
     * @summary WebSocket Account Streams
     * @param {string} authorization 
     * @param {WebSocketAccountDataUpgradeEnum} upgrade 
     * @param {string} secWebSocketKey WebSocket key used during the handshake.
     * @param {WebSocketAccountDataSecWebSocketVersionEnum} secWebSocketVersion WebSocket protocol version.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StreamsApi
     */
    public webSocketAccountData(authorization: string, upgrade: WebSocketAccountDataUpgradeEnum, secWebSocketKey: string, secWebSocketVersion: WebSocketAccountDataSecWebSocketVersionEnum, options?: RawAxiosRequestConfig) {
        return StreamsApiFp(this.configuration).webSocketAccountData(authorization, upgrade, secWebSocketKey, secWebSocketVersion, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * WebSocket Market Streams URL.
     * @summary WebSocket Market Streams
     * @param {WebSocketMarketDataUpgradeEnum} upgrade 
     * @param {string} secWebSocketKey WebSocket key used during the handshake.
     * @param {WebSocketMarketDataSecWebSocketVersionEnum} secWebSocketVersion WebSocket protocol version.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StreamsApi
     */
    public webSocketMarketData(upgrade: WebSocketMarketDataUpgradeEnum, secWebSocketKey: string, secWebSocketVersion: WebSocketMarketDataSecWebSocketVersionEnum, options?: RawAxiosRequestConfig) {
        return StreamsApiFp(this.configuration).webSocketMarketData(upgrade, secWebSocketKey, secWebSocketVersion, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const WebSocketAccountDataUpgradeEnum = {
    Websocket: 'websocket'
} as const;
export type WebSocketAccountDataUpgradeEnum = typeof WebSocketAccountDataUpgradeEnum[keyof typeof WebSocketAccountDataUpgradeEnum];
/**
 * @export
 */
export const WebSocketAccountDataSecWebSocketVersionEnum = {
    _13: '13'
} as const;
export type WebSocketAccountDataSecWebSocketVersionEnum = typeof WebSocketAccountDataSecWebSocketVersionEnum[keyof typeof WebSocketAccountDataSecWebSocketVersionEnum];
/**
 * @export
 */
export const WebSocketMarketDataUpgradeEnum = {
    Websocket: 'websocket'
} as const;
export type WebSocketMarketDataUpgradeEnum = typeof WebSocketMarketDataUpgradeEnum[keyof typeof WebSocketMarketDataUpgradeEnum];
/**
 * @export
 */
export const WebSocketMarketDataSecWebSocketVersionEnum = {
    _13: '13'
} as const;
export type WebSocketMarketDataSecWebSocketVersionEnum = typeof WebSocketMarketDataSecWebSocketVersionEnum[keyof typeof WebSocketMarketDataSecWebSocketVersionEnum];


/**
 * TradeApi - axios parameter creator
 * @export
 */
export const TradeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * - May be a single order hash or a list of order hashes. - All orders must belong to the same account. - If no order hashes are specified, then will cancel all orders for the given market  - All orders being cancelled by request will receive the same time priority. 
         * @summary Cancel orders for a market using order hashes
         * @param {CancelOrdersRequest} cancelOrdersRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelOrders: async (cancelOrdersRequest: CancelOrdersRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cancelOrdersRequest' is not null or undefined
            assertParamExists('cancelOrders', 'cancelOrdersRequest', cancelOrdersRequest)
            const localVarPath = `/api/v1/trade/orders/cancel`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cancelOrdersRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve details of open orders for a specific account.
         * @summary Get Open Orders
         * @param {string} [symbol] Filter by specific perpetual symbol (optional)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpenOrders: async (symbol?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/trade/openOrders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Submit a new order for execution.
         * @summary Create a new order
         * @param {CreateOrderRequest} createOrderRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCreateOrder: async (createOrderRequest: CreateOrderRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createOrderRequest' is not null or undefined
            assertParamExists('postCreateOrder', 'createOrderRequest', createOrderRequest)
            const localVarPath = `/api/v1/trade/orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createOrderRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Initiates a withdraw action to withdraw some amount of assets from a user\'s account
         * @summary Initiate a withdraw
         * @param {WithdrawRequest} withdrawRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postWithdraw: async (withdrawRequest: WithdrawRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'withdrawRequest' is not null or undefined
            assertParamExists('postWithdraw', 'withdrawRequest', withdrawRequest)
            const localVarPath = `/api/v1/trade/withdraw`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(withdrawRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adjust margin for an isolated position for a symbol
         * @summary Adjust margin for an isolated position for a symbol
         * @param {AdjustIsolatedMarginRequest} adjustIsolatedMarginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putAdjustIsolatedMargin: async (adjustIsolatedMarginRequest: AdjustIsolatedMarginRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adjustIsolatedMarginRequest' is not null or undefined
            assertParamExists('putAdjustIsolatedMargin', 'adjustIsolatedMarginRequest', adjustIsolatedMarginRequest)
            const localVarPath = `/api/v1/trade/adjustIsolatedMargin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(adjustIsolatedMarginRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Authorizes an account to trade, perform liquidations and more, on behalf of another account
         * @summary Authorizes an account
         * @param {AccountAuthorizationRequest} accountAuthorizationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putAuthorizeAccount: async (accountAuthorizationRequest: AccountAuthorizationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountAuthorizationRequest' is not null or undefined
            assertParamExists('putAuthorizeAccount', 'accountAuthorizationRequest', accountAuthorizationRequest)
            const localVarPath = `/api/v1/trade/accounts/authorize`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accountAuthorizationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deauthorizes an account to trade, perform liquidations and more, on behalf of another account
         * @summary Deauthorizes an account
         * @param {AccountAuthorizationRequest} accountAuthorizationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putDeauthorizeAccount: async (accountAuthorizationRequest: AccountAuthorizationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountAuthorizationRequest' is not null or undefined
            assertParamExists('putDeauthorizeAccount', 'accountAuthorizationRequest', accountAuthorizationRequest)
            const localVarPath = `/api/v1/trade/accounts/deauthorize`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accountAuthorizationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates leverage for positions of a given market, closes all open orders for that market
         * @summary Updates leverage for positions
         * @param {AccountPositionLeverageUpdateRequest} accountPositionLeverageUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putLeverageUpdate: async (accountPositionLeverageUpdateRequest: AccountPositionLeverageUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountPositionLeverageUpdateRequest' is not null or undefined
            assertParamExists('putLeverageUpdate', 'accountPositionLeverageUpdateRequest', accountPositionLeverageUpdateRequest)
            const localVarPath = `/api/v1/trade/leverage`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accountPositionLeverageUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TradeApi - functional programming interface
 * @export
 */
export const TradeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TradeApiAxiosParamCreator(configuration)
    return {
        /**
         * - May be a single order hash or a list of order hashes. - All orders must belong to the same account. - If no order hashes are specified, then will cancel all orders for the given market  - All orders being cancelled by request will receive the same time priority. 
         * @summary Cancel orders for a market using order hashes
         * @param {CancelOrdersRequest} cancelOrdersRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelOrders(cancelOrdersRequest: CancelOrdersRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelOrders(cancelOrdersRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.cancelOrders']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve details of open orders for a specific account.
         * @summary Get Open Orders
         * @param {string} [symbol] Filter by specific perpetual symbol (optional)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOpenOrders(symbol?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OpenOrderResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOpenOrders(symbol, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.getOpenOrders']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Submit a new order for execution.
         * @summary Create a new order
         * @param {CreateOrderRequest} createOrderRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCreateOrder(createOrderRequest: CreateOrderRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PostCreateOrder202Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postCreateOrder(createOrderRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.postCreateOrder']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Initiates a withdraw action to withdraw some amount of assets from a user\'s account
         * @summary Initiate a withdraw
         * @param {WithdrawRequest} withdrawRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postWithdraw(withdrawRequest: WithdrawRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postWithdraw(withdrawRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.postWithdraw']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Adjust margin for an isolated position for a symbol
         * @summary Adjust margin for an isolated position for a symbol
         * @param {AdjustIsolatedMarginRequest} adjustIsolatedMarginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putAdjustIsolatedMargin(adjustIsolatedMarginRequest: AdjustIsolatedMarginRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putAdjustIsolatedMargin(adjustIsolatedMarginRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.putAdjustIsolatedMargin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Authorizes an account to trade, perform liquidations and more, on behalf of another account
         * @summary Authorizes an account
         * @param {AccountAuthorizationRequest} accountAuthorizationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putAuthorizeAccount(accountAuthorizationRequest: AccountAuthorizationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putAuthorizeAccount(accountAuthorizationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.putAuthorizeAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deauthorizes an account to trade, perform liquidations and more, on behalf of another account
         * @summary Deauthorizes an account
         * @param {AccountAuthorizationRequest} accountAuthorizationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putDeauthorizeAccount(accountAuthorizationRequest: AccountAuthorizationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putDeauthorizeAccount(accountAuthorizationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.putDeauthorizeAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates leverage for positions of a given market, closes all open orders for that market
         * @summary Updates leverage for positions
         * @param {AccountPositionLeverageUpdateRequest} accountPositionLeverageUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putLeverageUpdate(accountPositionLeverageUpdateRequest: AccountPositionLeverageUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putLeverageUpdate(accountPositionLeverageUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.putLeverageUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TradeApi - factory interface
 * @export
 */
export const TradeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TradeApiFp(configuration)
    return {
        /**
         * - May be a single order hash or a list of order hashes. - All orders must belong to the same account. - If no order hashes are specified, then will cancel all orders for the given market  - All orders being cancelled by request will receive the same time priority. 
         * @summary Cancel orders for a market using order hashes
         * @param {CancelOrdersRequest} cancelOrdersRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelOrders(cancelOrdersRequest: CancelOrdersRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.cancelOrders(cancelOrdersRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve details of open orders for a specific account.
         * @summary Get Open Orders
         * @param {string} [symbol] Filter by specific perpetual symbol (optional)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpenOrders(symbol?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<OpenOrderResponse>> {
            return localVarFp.getOpenOrders(symbol, options).then((request) => request(axios, basePath));
        },
        /**
         * Submit a new order for execution.
         * @summary Create a new order
         * @param {CreateOrderRequest} createOrderRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCreateOrder(createOrderRequest: CreateOrderRequest, options?: RawAxiosRequestConfig): AxiosPromise<PostCreateOrder202Response> {
            return localVarFp.postCreateOrder(createOrderRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Initiates a withdraw action to withdraw some amount of assets from a user\'s account
         * @summary Initiate a withdraw
         * @param {WithdrawRequest} withdrawRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postWithdraw(withdrawRequest: WithdrawRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.postWithdraw(withdrawRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Adjust margin for an isolated position for a symbol
         * @summary Adjust margin for an isolated position for a symbol
         * @param {AdjustIsolatedMarginRequest} adjustIsolatedMarginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putAdjustIsolatedMargin(adjustIsolatedMarginRequest: AdjustIsolatedMarginRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.putAdjustIsolatedMargin(adjustIsolatedMarginRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Authorizes an account to trade, perform liquidations and more, on behalf of another account
         * @summary Authorizes an account
         * @param {AccountAuthorizationRequest} accountAuthorizationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putAuthorizeAccount(accountAuthorizationRequest: AccountAuthorizationRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.putAuthorizeAccount(accountAuthorizationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Deauthorizes an account to trade, perform liquidations and more, on behalf of another account
         * @summary Deauthorizes an account
         * @param {AccountAuthorizationRequest} accountAuthorizationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putDeauthorizeAccount(accountAuthorizationRequest: AccountAuthorizationRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.putDeauthorizeAccount(accountAuthorizationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates leverage for positions of a given market, closes all open orders for that market
         * @summary Updates leverage for positions
         * @param {AccountPositionLeverageUpdateRequest} accountPositionLeverageUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putLeverageUpdate(accountPositionLeverageUpdateRequest: AccountPositionLeverageUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.putLeverageUpdate(accountPositionLeverageUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TradeApi - object-oriented interface
 * @export
 * @class TradeApi
 * @extends {BaseAPI}
 */
export class TradeApi extends BaseAPI {
    /**
     * - May be a single order hash or a list of order hashes. - All orders must belong to the same account. - If no order hashes are specified, then will cancel all orders for the given market  - All orders being cancelled by request will receive the same time priority. 
     * @summary Cancel orders for a market using order hashes
     * @param {CancelOrdersRequest} cancelOrdersRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public cancelOrders(cancelOrdersRequest: CancelOrdersRequest, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).cancelOrders(cancelOrdersRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve details of open orders for a specific account.
     * @summary Get Open Orders
     * @param {string} [symbol] Filter by specific perpetual symbol (optional)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public getOpenOrders(symbol?: string, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).getOpenOrders(symbol, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Submit a new order for execution.
     * @summary Create a new order
     * @param {CreateOrderRequest} createOrderRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public postCreateOrder(createOrderRequest: CreateOrderRequest, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).postCreateOrder(createOrderRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Initiates a withdraw action to withdraw some amount of assets from a user\'s account
     * @summary Initiate a withdraw
     * @param {WithdrawRequest} withdrawRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public postWithdraw(withdrawRequest: WithdrawRequest, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).postWithdraw(withdrawRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adjust margin for an isolated position for a symbol
     * @summary Adjust margin for an isolated position for a symbol
     * @param {AdjustIsolatedMarginRequest} adjustIsolatedMarginRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public putAdjustIsolatedMargin(adjustIsolatedMarginRequest: AdjustIsolatedMarginRequest, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).putAdjustIsolatedMargin(adjustIsolatedMarginRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Authorizes an account to trade, perform liquidations and more, on behalf of another account
     * @summary Authorizes an account
     * @param {AccountAuthorizationRequest} accountAuthorizationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public putAuthorizeAccount(accountAuthorizationRequest: AccountAuthorizationRequest, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).putAuthorizeAccount(accountAuthorizationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deauthorizes an account to trade, perform liquidations and more, on behalf of another account
     * @summary Deauthorizes an account
     * @param {AccountAuthorizationRequest} accountAuthorizationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public putDeauthorizeAccount(accountAuthorizationRequest: AccountAuthorizationRequest, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).putDeauthorizeAccount(accountAuthorizationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates leverage for positions of a given market, closes all open orders for that market
     * @summary Updates leverage for positions
     * @param {AccountPositionLeverageUpdateRequest} accountPositionLeverageUpdateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public putLeverageUpdate(accountPositionLeverageUpdateRequest: AccountPositionLeverageUpdateRequest, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).putLeverageUpdate(accountPositionLeverageUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



