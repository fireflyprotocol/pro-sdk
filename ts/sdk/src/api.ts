/* tslint:disable */
/* eslint-disable */
/**
 * Bluefin API
 * Bluefin API
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface Account
 */
export interface Account {
    /**
     * The (optional) group ID of the account. Accounts belonging to the same group cannot trade against each other. 
     * @type {string}
     * @memberof Account
     */
    'groupId'?: string;
    /**
     * 
     * @type {TradingFees}
     * @memberof Account
     */
    'tradingFees': TradingFees;
    /**
     * If the user can trade.
     * @type {boolean}
     * @memberof Account
     */
    'canTrade': boolean;
    /**
     * If the current user can deposit to the account.
     * @type {boolean}
     * @memberof Account
     */
    'canDeposit': boolean;
    /**
     * If the current user can withdraw from the account.
     * @type {boolean}
     * @memberof Account
     */
    'canWithdraw': boolean;
    /**
     * Total effective balance in USD (e9 format).
     * @type {string}
     * @memberof Account
     */
    'crossEffectiveBalanceE9': string;
    /**
     * The sum of initial margin required across all cross positions (e9 format).
     * @type {string}
     * @memberof Account
     */
    'crossMarginRequiredE9': string;
    /**
     * The sum of initial margin required across all open orders (e9 format).
     * @type {string}
     * @memberof Account
     */
    'totalOrderMarginRequiredE9': string;
    /**
     * The amount of margin available to open new positions and orders (e9 format).
     * @type {string}
     * @memberof Account
     */
    'marginAvailableE9': string;
    /**
     * The sum of maintenance margin required across all cross positions (e9 format).
     * @type {string}
     * @memberof Account
     */
    'crossMaintenanceMarginRequiredE9': string;
    /**
     * The amount of margin available before liquidation (e9 format).
     * @type {string}
     * @memberof Account
     */
    'crossMaintenanceMarginAvailableE9': string;
    /**
     * The ratio of the maintenance margin required to the account value (e9 format).
     * @type {string}
     * @memberof Account
     */
    'crossMaintenanceMarginRatioE9': string;
    /**
     * The leverage of the account (e9 format).
     * @type {string}
     * @memberof Account
     */
    'crossLeverageE9': string;
    /**
     * Total unrealized profit (e9 format).
     * @type {string}
     * @memberof Account
     */
    'totalUnrealizedPnlE9': string;
    /**
     * Unrealized profit of cross positions (e9 format).
     * @type {string}
     * @memberof Account
     */
    'crossUnrealizedPnlE9': string;
    /**
     * An implicitly negative number that sums only the losses of all cross positions.
     * @type {string}
     * @memberof Account
     */
    'crossUnrealizedLossE9': string;
    /**
     * The total value of the cross account, combining the cross effective balance and unrealized PnL across all cross positions, and subtracting any pending funding payments on any cross position. 
     * @type {string}
     * @memberof Account
     */
    'crossAccountValueE9': string;
    /**
     * The total value of the account, combining the total effective balance and unrealized PnL across all positions, and subtracting any pending funding payments on any position. 
     * @type {string}
     * @memberof Account
     */
    'totalAccountValueE9': string;
    /**
     * Last update time in milliseconds since Unix epoch.
     * @type {number}
     * @memberof Account
     */
    'updatedAtMillis': number;
    /**
     * 
     * @type {Array<Asset>}
     * @memberof Account
     */
    'assets': Array<Asset>;
    /**
     * 
     * @type {Array<Position>}
     * @memberof Account
     */
    'positions': Array<Position>;
    /**
     * Deprecated: Replaced with authorizedWallets.
     * @type {Array<string>}
     * @memberof Account
     * @deprecated
     */
    'authorizedAccounts': Array<string>;
    /**
     * The address of the account.
     * @type {string}
     * @memberof Account
     */
    'accountAddress': string;
    /**
     * The wallets that are authorized to trade on behalf of the current account.
     * @type {Array<AuthorizedWallet>}
     * @memberof Account
     */
    'authorizedWallets': Array<AuthorizedWallet>;
}
/**
 * Aggregated details about a trade in the account.
 * @export
 * @interface AccountAggregatedTradeUpdate
 */
export interface AccountAggregatedTradeUpdate {
    /**
     * 
     * @type {Trade}
     * @memberof AccountAggregatedTradeUpdate
     */
    'trade': Trade;
}
/**
 * 
 * @export
 * @interface AccountAuthorizationRequest
 */
export interface AccountAuthorizationRequest {
    /**
     * 
     * @type {AccountAuthorizationRequestSignedFields}
     * @memberof AccountAuthorizationRequest
     */
    'signedFields': AccountAuthorizationRequestSignedFields;
    /**
     * The signature of the request, encoded from the signedFields
     * @type {string}
     * @memberof AccountAuthorizationRequest
     */
    'signature': string;
    /**
     * The (optional) alias of the account that is being authorized or deauthorized
     * @type {string}
     * @memberof AccountAuthorizationRequest
     */
    'alias'?: string;
}
/**
 * 
 * @export
 * @interface AccountAuthorizationRequestSignedFields
 */
export interface AccountAuthorizationRequestSignedFields {
    /**
     * The account address of the parent account that is authorizing/deauthorizing this account
     * @type {string}
     * @memberof AccountAuthorizationRequestSignedFields
     */
    'accountAddress': string;
    /**
     * The address of the account that should be authorized/deauthorized
     * @type {string}
     * @memberof AccountAuthorizationRequestSignedFields
     */
    'authorizedAccountAddress': string;
    /**
     * The random generated salt. Should always be a number
     * @type {string}
     * @memberof AccountAuthorizationRequestSignedFields
     */
    'salt': string;
    /**
     * the ID of the internal datastore for the target network
     * @type {string}
     * @memberof AccountAuthorizationRequestSignedFields
     */
    'idsId': string;
    /**
     * The timestamp when the request was signed
     * @type {number}
     * @memberof AccountAuthorizationRequestSignedFields
     */
    'signedAtMillis': number;
}
/**
 * Details about a failure during an account command execution.
 * @export
 * @interface AccountCommandFailureUpdate
 */
export interface AccountCommandFailureUpdate {
    /**
     * The reason for the failure.
     * @type {string}
     * @memberof AccountCommandFailureUpdate
     */
    'reason': string;
    /**
     * 
     * @type {CommandFailureReasonCode}
     * @memberof AccountCommandFailureUpdate
     */
    'reasonCode'?: CommandFailureReasonCode;
    /**
     * The type of command that failed.
     * @type {string}
     * @memberof AccountCommandFailureUpdate
     */
    'failedCommandType': string;
    /**
     * 
     * @type {FailedCommandType}
     * @memberof AccountCommandFailureUpdate
     */
    'failedCommandTypeCode'?: FailedCommandType;
    /**
     * The timestamp when the command failed in milliseconds.
     * @type {number}
     * @memberof AccountCommandFailureUpdate
     */
    'failedAtMillis': number;
}


/**
 * Represents the type of account data stream.
 * @export
 * @enum {string}
 */

export const AccountDataStream = {
    AccountOrderUpdate: 'AccountOrderUpdate',
    AccountTradeUpdate: 'AccountTradeUpdate',
    AccountAggregatedTradeUpdate: 'AccountAggregatedTradeUpdate',
    AccountPositionUpdate: 'AccountPositionUpdate',
    AccountUpdate: 'AccountUpdate',
    AccountTransactionUpdate: 'AccountTransactionUpdate',
    AccountCommandFailureUpdate: 'AccountCommandFailureUpdate'
} as const;

export type AccountDataStream = typeof AccountDataStream[keyof typeof AccountDataStream];


/**
 * The reason for the account-related event.
 * @export
 * @enum {string}
 */

export const AccountEventReason = {
    Deposit: 'Deposit',
    Withdraw: 'Withdraw',
    OrderCreated: 'OrderCreated',
    OrderMatched: 'OrderMatched',
    OrderCancelled: 'OrderCancelled',
    OrdersForMarketCancelled: 'OrdersForMarketCancelled',
    LeverageUpdated: 'LeverageUpdated',
    IsolatedMarginUpdated: 'IsolatedMarginUpdated',
    FundingRatePayment: 'FundingRatePayment',
    AccountGroupUpdated: 'AccountGroupUpdated',
    Unspecified: 'Unspecified'
} as const;

export type AccountEventReason = typeof AccountEventReason[keyof typeof AccountEventReason];


/**
 * The type of account-related event.
 * @export
 * @enum {string}
 */

export const AccountEventType = {
    AccountUpdate: 'AccountUpdate',
    AccountTradeUpdate: 'AccountTradeUpdate',
    AccountAggregatedTradeUpdate: 'AccountAggregatedTradeUpdate',
    AccountOrderUpdate: 'AccountOrderUpdate',
    AccountPositionUpdate: 'AccountPositionUpdate',
    AccountTransactionUpdate: 'AccountTransactionUpdate',
    AccountCommandFailureUpdate: 'AccountCommandFailureUpdate'
} as const;

export type AccountEventType = typeof AccountEventType[keyof typeof AccountEventType];


/**
 * 
 * @export
 * @interface AccountFundingRateHistory
 */
export interface AccountFundingRateHistory {
    /**
     * 
     * @type {Array<AccountFundingRateHistoryData>}
     * @memberof AccountFundingRateHistory
     */
    'data': Array<AccountFundingRateHistoryData>;
}
/**
 * 
 * @export
 * @interface AccountFundingRateHistoryData
 */
export interface AccountFundingRateHistoryData {
    /**
     * Payment amount in e9 format.
     * @type {string}
     * @memberof AccountFundingRateHistoryData
     */
    'paymentAmountE9': string;
    /**
     * 
     * @type {PositionSide}
     * @memberof AccountFundingRateHistoryData
     */
    'positionSide': PositionSide;
    /**
     * Funding rate value (e9 format).
     * @type {string}
     * @memberof AccountFundingRateHistoryData
     */
    'rateE9': string;
    /**
     * Market address.
     * @type {string}
     * @memberof AccountFundingRateHistoryData
     */
    'symbol': string;
    /**
     * Execution timestamp in milliseconds since Unix epoch.
     * @type {number}
     * @memberof AccountFundingRateHistoryData
     */
    'executedAtMillis': number;
    /**
     * Computed timestamp in milliseconds since Unix epoch.
     * @type {number}
     * @memberof AccountFundingRateHistoryData
     */
    'computedAtMillis': number;
}


/**
 * 
 * @export
 * @interface AccountGroupIdPatch
 */
export interface AccountGroupIdPatch {
    /**
     * The address of the account to update.
     * @type {string}
     * @memberof AccountGroupIdPatch
     */
    'accountAddress': string;
    /**
     * The new group to assign the account to. If not set, the account will be removed from it\'s group. 
     * @type {string}
     * @memberof AccountGroupIdPatch
     */
    'groupId'?: string;
}
/**
 * 
 * @export
 * @interface AccountMarketPreference
 */
export interface AccountMarketPreference {
    /**
     * 
     * @type {MarginType}
     * @memberof AccountMarketPreference
     */
    'marginType'?: MarginType;
    /**
     * User set leverage (e.g., 10x).
     * @type {number}
     * @memberof AccountMarketPreference
     */
    'setLeverage'?: number;
}


/**
 * @type AccountOrderUpdate
 * A message containing order update information.
 * @export
 */
export type AccountOrderUpdate = ActiveOrderUpdate | OrderCancellationUpdate;

/**
 * 
 * @export
 * @interface AccountPositionLeverageUpdateRequest
 */
export interface AccountPositionLeverageUpdateRequest {
    /**
     * 
     * @type {AccountPositionLeverageUpdateRequestSignedFields}
     * @memberof AccountPositionLeverageUpdateRequest
     */
    'signedFields': AccountPositionLeverageUpdateRequestSignedFields;
    /**
     * The signature of the request, encoded from the signedFields
     * @type {string}
     * @memberof AccountPositionLeverageUpdateRequest
     */
    'signature': string;
}
/**
 * 
 * @export
 * @interface AccountPositionLeverageUpdateRequestSignedFields
 */
export interface AccountPositionLeverageUpdateRequestSignedFields {
    /**
     * The Account Address from which to update leverage
     * @type {string}
     * @memberof AccountPositionLeverageUpdateRequestSignedFields
     */
    'accountAddress': string;
    /**
     * Symbol of the perpetual of the positions for which to update the leverage
     * @type {string}
     * @memberof AccountPositionLeverageUpdateRequestSignedFields
     */
    'symbol': string;
    /**
     * The leverage to set for the account positions (Must be a number in base e9)
     * @type {string}
     * @memberof AccountPositionLeverageUpdateRequestSignedFields
     */
    'leverageE9': string;
    /**
     * The random generated SALT. Should always be a number
     * @type {string}
     * @memberof AccountPositionLeverageUpdateRequestSignedFields
     */
    'salt': string;
    /**
     * the ID of the internal datastore for the target network
     * @type {string}
     * @memberof AccountPositionLeverageUpdateRequestSignedFields
     */
    'idsId': string;
    /**
     * The timestamp in millis at which the request was signed
     * @type {number}
     * @memberof AccountPositionLeverageUpdateRequestSignedFields
     */
    'signedAtMillis': number;
}
/**
 * Details about an account position update.
 * @export
 * @interface AccountPositionUpdate
 */
export interface AccountPositionUpdate {
    /**
     * The symbol of the market.
     * @type {string}
     * @memberof AccountPositionUpdate
     */
    'symbol': string;
    /**
     * The average entry price for the position.
     * @type {string}
     * @memberof AccountPositionUpdate
     */
    'avgEntryPriceE9': string;
    /**
     * The leverage applied to the position.
     * @type {string}
     * @memberof AccountPositionUpdate
     */
    'clientSetLeverageE9': string;
    /**
     * The liquidation price of the position.
     * @type {string}
     * @memberof AccountPositionUpdate
     */
    'liquidationPriceE9': string;
    /**
     * The current mark price of the position.
     * @type {string}
     * @memberof AccountPositionUpdate
     */
    'markPriceE9': string;
    /**
     * The notional value of the position.
     * @type {string}
     * @memberof AccountPositionUpdate
     */
    'notionalValueE9': string;
    /**
     * The size of the position.
     * @type {string}
     * @memberof AccountPositionUpdate
     */
    'sizeE9': string;
    /**
     * The unrealized profit and loss for the position.
     * @type {string}
     * @memberof AccountPositionUpdate
     */
    'unrealizedPnlE9': string;
    /**
     * 
     * @type {PositionSide}
     * @memberof AccountPositionUpdate
     */
    'side': PositionSide;
    /**
     * The margin required for the position.
     * @type {string}
     * @memberof AccountPositionUpdate
     */
    'marginRequiredE9': string;
    /**
     * The maintenance margin required for the position.
     * @type {string}
     * @memberof AccountPositionUpdate
     */
    'maintenanceMarginE9': string;
    /**
     * Indicates if the position is isolated.
     * @type {boolean}
     * @memberof AccountPositionUpdate
     */
    'isIsolated': boolean;
    /**
     * The isolated margin applied to the position.
     * @type {string}
     * @memberof AccountPositionUpdate
     */
    'isolatedMarginE9': string;
    /**
     * The last update time for the position in milliseconds.
     * @type {number}
     * @memberof AccountPositionUpdate
     */
    'updatedAtMillis': number;
}


/**
 * 
 * @export
 * @interface AccountPreference
 */
export interface AccountPreference {
    [key: string]: any;

    /**
     * User preferred language.
     * @type {string}
     * @memberof AccountPreference
     */
    'language'?: string;
    /**
     * User preferred theme.
     * @type {string}
     * @memberof AccountPreference
     */
    'theme'?: string;
    /**
     * 
     * @type {Array<AccountMarketPreference>}
     * @memberof AccountPreference
     */
    'market'?: Array<AccountMarketPreference>;
}
/**
 * Account stream message for account-related events. The payload depends on the event type. 
 * @export
 * @interface AccountStreamMessage
 */
export interface AccountStreamMessage {
    /**
     * 
     * @type {AccountEventType}
     * @memberof AccountStreamMessage
     */
    'event': AccountEventType;
    /**
     * 
     * @type {AccountEventReason}
     * @memberof AccountStreamMessage
     */
    'reason': AccountEventReason;
    /**
     * 
     * @type {AccountStreamMessagePayload}
     * @memberof AccountStreamMessage
     */
    'payload': AccountStreamMessagePayload;
}


/**
 * @type AccountStreamMessagePayload
 * The payload of the message, which varies based on the event type.
 * @export
 */
export type AccountStreamMessagePayload = AccountAggregatedTradeUpdate | AccountCommandFailureUpdate | AccountOrderUpdate | AccountPositionUpdate | AccountTradeUpdate | AccountTransactionUpdate | AccountUpdate;

/**
 * Subscription message for account data streams.
 * @export
 * @interface AccountSubscriptionMessage
 */
export interface AccountSubscriptionMessage {
    /**
     * The authentication token for the account.
     * @type {string}
     * @memberof AccountSubscriptionMessage
     */
    'authToken'?: string;
    /**
     * 
     * @type {SubscriptionType}
     * @memberof AccountSubscriptionMessage
     */
    'method': SubscriptionType;
    /**
     * List of account data streams to subscribe or unsubscribe from.
     * @type {Array<AccountDataStream>}
     * @memberof AccountSubscriptionMessage
     */
    'dataStreams': Array<AccountDataStream>;
}


/**
 * Details about a trade in the account.
 * @export
 * @interface AccountTradeUpdate
 */
export interface AccountTradeUpdate {
    /**
     * 
     * @type {Trade}
     * @memberof AccountTradeUpdate
     */
    'trade': Trade;
}
/**
 * Details about a transaction in the account.
 * @export
 * @interface AccountTransactionUpdate
 */
export interface AccountTransactionUpdate {
    /**
     * The symbol of the market.
     * @type {string}
     * @memberof AccountTransactionUpdate
     */
    'symbol'?: string;
    /**
     * 
     * @type {TransactionType}
     * @memberof AccountTransactionUpdate
     */
    'transactionType': TransactionType;
    /**
     * The amount of the transaction in scientific notation with 9 decimal places.
     * @type {string}
     * @memberof AccountTransactionUpdate
     */
    'amountE9': string;
    /**
     * The symbol of the asset.
     * @type {string}
     * @memberof AccountTransactionUpdate
     */
    'assetSymbol'?: string;
    /**
     * The trade ID associated with the transaction.
     * @type {string}
     * @memberof AccountTransactionUpdate
     */
    'tradeId'?: string;
    /**
     * The timestamp when the transaction was executed in milliseconds.
     * @type {number}
     * @memberof AccountTransactionUpdate
     */
    'executedAtMillis': number;
}


/**
 * Account information for the data stream.
 * @export
 * @interface AccountUpdate
 */
export interface AccountUpdate {
    /**
     * The optional group ID of the account.
     * @type {string}
     * @memberof AccountUpdate
     */
    'groupId'?: string;
    /**
     * 
     * @type {TradingFees}
     * @memberof AccountUpdate
     */
    'tradingFees'?: TradingFees;
    /**
     * If the user can trade.
     * @type {boolean}
     * @memberof AccountUpdate
     */
    'canTrade': boolean;
    /**
     * If the current user can deposit to the account.
     * @type {boolean}
     * @memberof AccountUpdate
     */
    'canDeposit': boolean;
    /**
     * If the current user can withdraw from the account.
     * @type {boolean}
     * @memberof AccountUpdate
     */
    'canWithdraw': boolean;
    /**
     * Total effective balance in USD (e9 format).
     * @type {string}
     * @memberof AccountUpdate
     */
    'crossEffectiveBalanceE9': string;
    /**
     * The sum of initial margin required across all cross positions (e9 format).
     * @type {string}
     * @memberof AccountUpdate
     */
    'crossMarginRequiredE9': string;
    /**
     * The sum of initial margin required across all open orders (e9 format).
     * @type {string}
     * @memberof AccountUpdate
     */
    'totalOrderMarginRequiredE9': string;
    /**
     * The amount of margin available to open new positions and orders (e9 format).
     * @type {string}
     * @memberof AccountUpdate
     */
    'marginAvailableE9': string;
    /**
     * The sum of maintenance margin required across all cross positions (e9 format).
     * @type {string}
     * @memberof AccountUpdate
     */
    'crossMaintenanceMarginRequiredE9': string;
    /**
     * The amount of margin available before liquidation (e9 format).
     * @type {string}
     * @memberof AccountUpdate
     */
    'crossMaintenanceMarginAvailableE9': string;
    /**
     * The ratio of the maintenance margin required to the account value (e9 format).
     * @type {string}
     * @memberof AccountUpdate
     */
    'crossMaintenanceMarginRatioE9': string;
    /**
     * The leverage of the account (e9 format).
     * @type {string}
     * @memberof AccountUpdate
     */
    'crossLeverageE9': string;
    /**
     * Total unrealized profit (e9 format).
     * @type {string}
     * @memberof AccountUpdate
     */
    'totalUnrealizedPnlE9': string;
    /**
     * Unrealized profit of cross positions (e9 format).
     * @type {string}
     * @memberof AccountUpdate
     */
    'crossUnrealizedPnlE9': string;
    /**
     * An implicitly negative number that sums only the losses of all cross positions.
     * @type {string}
     * @memberof AccountUpdate
     */
    'crossUnrealizedLossE9': string;
    /**
     * The total value of the cross account, combining the cross effective balance and unrealized PnL across all cross positions, and subtracting any pending funding payments on any cross position. 
     * @type {string}
     * @memberof AccountUpdate
     */
    'crossAccountValueE9': string;
    /**
     * The total value of the account, combining the total effective balance and unrealized PnL across all positions, and subtracting any pending funding payments on any position. 
     * @type {string}
     * @memberof AccountUpdate
     */
    'totalAccountValueE9': string;
    /**
     * Last update time in milliseconds since Unix epoch.
     * @type {number}
     * @memberof AccountUpdate
     */
    'updatedAtMillis': number;
    /**
     * 
     * @type {Array<Asset>}
     * @memberof AccountUpdate
     */
    'assets': Array<Asset>;
    /**
     * Deprecated: Replaced with authorizedWallets.
     * @type {Array<string>}
     * @memberof AccountUpdate
     * @deprecated
     */
    'authorizedAccounts': Array<string>;
    /**
     * The wallets that are authorized to trade on behalf of the current account.
     * @type {Array<AuthorizedWallet>}
     * @memberof AccountUpdate
     */
    'authorizedWallets': Array<AuthorizedWallet>;
}
/**
 * Information about an order update.
 * @export
 * @interface ActiveOrderUpdate
 */
export interface ActiveOrderUpdate {
    /**
     * The unique hash of the order.
     * @type {string}
     * @memberof ActiveOrderUpdate
     */
    'orderHash': string;
    /**
     * The client-provided order ID.
     * @type {string}
     * @memberof ActiveOrderUpdate
     */
    'clientOrderId'?: string;
    /**
     * The symbol of the market.
     * @type {string}
     * @memberof ActiveOrderUpdate
     */
    'symbol': string;
    /**
     * The address of the account.
     * @type {string}
     * @memberof ActiveOrderUpdate
     */
    'accountAddress': string;
    /**
     * The price of the order in scientific notation with 9 decimal places.
     * @type {string}
     * @memberof ActiveOrderUpdate
     */
    'priceE9': string;
    /**
     * The quantity of the order in scientific notation with 9 decimal places.
     * @type {string}
     * @memberof ActiveOrderUpdate
     */
    'quantityE9': string;
    /**
     * The filled quantity of the order in scientific notation with 9 decimal places.
     * @type {string}
     * @memberof ActiveOrderUpdate
     */
    'filledQuantityE9': string;
    /**
     * 
     * @type {TradeSide}
     * @memberof ActiveOrderUpdate
     */
    'side': TradeSide;
    /**
     * The leverage of the order in scientific notation with 9 decimal places.
     * @type {string}
     * @memberof ActiveOrderUpdate
     */
    'leverageE9': string;
    /**
     * Indicates if the order is isolated.
     * @type {boolean}
     * @memberof ActiveOrderUpdate
     */
    'isIsolated': boolean;
    /**
     * A unique salt for the order.
     * @type {string}
     * @memberof ActiveOrderUpdate
     */
    'salt': string;
    /**
     * The expiration timestamp of the order in milliseconds.
     * @type {number}
     * @memberof ActiveOrderUpdate
     */
    'expiresAtMillis': number;
    /**
     * The signing timestamp of the order in milliseconds.
     * @type {number}
     * @memberof ActiveOrderUpdate
     */
    'signedAtMillis': number;
    /**
     * The address of the signer of the order request.
     * @type {string}
     * @memberof ActiveOrderUpdate
     */
    'signerAddress': string;
    /**
     * 
     * @type {OrderType}
     * @memberof ActiveOrderUpdate
     */
    'type': OrderType;
    /**
     * Indicates if the order is reduce-only.
     * @type {boolean}
     * @memberof ActiveOrderUpdate
     */
    'reduceOnly': boolean;
    /**
     * Indicates if the order is post-only.
     * @type {boolean}
     * @memberof ActiveOrderUpdate
     */
    'postOnly': boolean;
    /**
     * 
     * @type {OrderTimeInForce}
     * @memberof ActiveOrderUpdate
     */
    'timeInForce': OrderTimeInForce;
    /**
     * The trigger price for stop-limit or stop-market orders.
     * @type {string}
     * @memberof ActiveOrderUpdate
     */
    'triggerPriceE9'?: string;
    /**
     * 
     * @type {OrderStatus}
     * @memberof ActiveOrderUpdate
     */
    'status': OrderStatus;
    /**
     * 
     * @type {SelfTradePreventionType}
     * @memberof ActiveOrderUpdate
     */
    'selfTradePreventionType': SelfTradePreventionType;
    /**
     * The timestamp when the order was placed, in milliseconds.
     * @type {number}
     * @memberof ActiveOrderUpdate
     */
    'createdAtMillis': number;
    /**
     * The timestamp of the last update of the order in milliseconds.
     * @type {number}
     * @memberof ActiveOrderUpdate
     */
    'updatedAtMillis': number;
}


/**
 * 
 * @export
 * @interface AdjustIsolatedMarginRequest
 */
export interface AdjustIsolatedMarginRequest {
    /**
     * 
     * @type {AdjustIsolatedMarginRequestSignedFields}
     * @memberof AdjustIsolatedMarginRequest
     */
    'signedFields': AdjustIsolatedMarginRequestSignedFields;
    /**
     * The signature of the request, encoded from the signedFields
     * @type {string}
     * @memberof AdjustIsolatedMarginRequest
     */
    'signature': string;
}
/**
 * 
 * @export
 * @interface AdjustIsolatedMarginRequestSignedFields
 */
export interface AdjustIsolatedMarginRequestSignedFields {
    /**
     * the ID of the internal datastore for the target network
     * @type {string}
     * @memberof AdjustIsolatedMarginRequestSignedFields
     */
    'idsId': string;
    /**
     * The account address of the account for which to adjust margin
     * @type {string}
     * @memberof AdjustIsolatedMarginRequestSignedFields
     */
    'accountAddress': string;
    /**
     * The symbol of the isolated position for which to adjust margin
     * @type {string}
     * @memberof AdjustIsolatedMarginRequestSignedFields
     */
    'symbol': string;
    /**
     * 
     * @type {AdjustMarginOperation}
     * @memberof AdjustIsolatedMarginRequestSignedFields
     */
    'operation': AdjustMarginOperation;
    /**
     * The quantity of margin to adjust for the isolated position
     * @type {string}
     * @memberof AdjustIsolatedMarginRequestSignedFields
     */
    'quantityE9': string;
    /**
     * The random generated SALT. Should always be a number
     * @type {string}
     * @memberof AdjustIsolatedMarginRequestSignedFields
     */
    'salt': string;
    /**
     * The timestamp in millis at which the request was signed
     * @type {number}
     * @memberof AdjustIsolatedMarginRequestSignedFields
     */
    'signedAtMillis': number;
}


/**
 * The operation to perform on the margin
 * @export
 * @enum {string}
 */

export const AdjustMarginOperation = {
    Add: 'ADD',
    Subtract: 'SUBTRACT'
} as const;

export type AdjustMarginOperation = typeof AdjustMarginOperation[keyof typeof AdjustMarginOperation];


/**
 * 
 * @export
 * @interface AffiliateIntervalOverview
 */
export interface AffiliateIntervalOverview {
    /**
     * The user\'s wallet address
     * @type {string}
     * @memberof AffiliateIntervalOverview
     */
    'userAddress': string;
    /**
     * Name of the affiliate
     * @type {string}
     * @memberof AffiliateIntervalOverview
     */
    'name'?: string;
    /**
     * The interval number for the affiliate\'s earnings data
     * @type {number}
     * @memberof AffiliateIntervalOverview
     */
    'intervalNumber': number;
    /**
     * Start date of the interval in seconds
     * @type {number}
     * @memberof AffiliateIntervalOverview
     */
    'intervalStartDate': number;
    /**
     * End date of the interval in seconds
     * @type {number}
     * @memberof AffiliateIntervalOverview
     */
    'intervalEndDate': number;
    /**
     * Status of the interval
     * @type {string}
     * @memberof AffiliateIntervalOverview
     */
    'status': AffiliateIntervalOverviewStatusEnum;
    /**
     * Date when the user was referred
     * @type {string}
     * @memberof AffiliateIntervalOverview
     */
    'referredSince': string;
    /**
     * Referee earnings from perps trading (e9 format)
     * @type {string}
     * @memberof AffiliateIntervalOverview
     */
    'perpsRefereeEarningsE9': string;
    /**
     * Referee earnings from spot LP (e9 format)
     * @type {string}
     * @memberof AffiliateIntervalOverview
     */
    'spotLPRefereeEarningsE9': string;
    /**
     * Referee earnings from lending (e9 format)
     * @type {string}
     * @memberof AffiliateIntervalOverview
     */
    'lendingRefereeEarningsE9': string;
    /**
     * Referee earnings from ember (e9 format)
     * @type {string}
     * @memberof AffiliateIntervalOverview
     */
    'emberRefereeEarningsE9': string;
    /**
     * Referral earnings from perps trading (e9 format)
     * @type {string}
     * @memberof AffiliateIntervalOverview
     */
    'perpsReferralEarningsE9': string;
    /**
     * Referral earnings from spot LP (e9 format)
     * @type {string}
     * @memberof AffiliateIntervalOverview
     */
    'spotLPReferralEarningsE9': string;
    /**
     * Referral earnings from lending (e9 format)
     * @type {string}
     * @memberof AffiliateIntervalOverview
     */
    'lendingReferralEarningsE9': string;
    /**
     * Total earnings from ember (e9 format)
     * @type {string}
     * @memberof AffiliateIntervalOverview
     */
    'emberTotalEarningsE9': string;
    /**
     * Total earnings from perps trading (e9 format)
     * @type {string}
     * @memberof AffiliateIntervalOverview
     */
    'perpsTotalEarningsE9': string;
    /**
     * Total earnings from spot LP (e9 format)
     * @type {string}
     * @memberof AffiliateIntervalOverview
     */
    'spotLPTotalEarningsE9': string;
    /**
     * Total earnings from lending (e9 format)
     * @type {string}
     * @memberof AffiliateIntervalOverview
     */
    'lendingTotalEarningsE9': string;
    /**
     * Total earnings from referrals (e9 format)
     * @type {string}
     * @memberof AffiliateIntervalOverview
     */
    'totalReferralEarningsE9': string;
    /**
     * Total earnings from referee activities (e9 format)
     * @type {string}
     * @memberof AffiliateIntervalOverview
     */
    'totalRefereeEarningsE9': string;
    /**
     * Total earnings combining referrals and referee activities (e9 format)
     * @type {string}
     * @memberof AffiliateIntervalOverview
     */
    'totalEarningsE9': string;
}

export const AffiliateIntervalOverviewStatusEnum = {
    Active: 'ACTIVE',
    NotStarted: 'NOT_STARTED',
    Finalized: 'FINALIZED',
    Cooldown: 'COOLDOWN'
} as const;

export type AffiliateIntervalOverviewStatusEnum = typeof AffiliateIntervalOverviewStatusEnum[keyof typeof AffiliateIntervalOverviewStatusEnum];

/**
 * 
 * @export
 * @interface AffiliateLeaderDashboard
 */
export interface AffiliateLeaderDashboard {
    /**
     * The user\'s wallet address
     * @type {string}
     * @memberof AffiliateLeaderDashboard
     */
    'userAddress': string;
    /**
     * Name of the affiliate
     * @type {string}
     * @memberof AffiliateLeaderDashboard
     */
    'name'?: string;
    /**
     * The parent affiliate\'s wallet address
     * @type {string}
     * @memberof AffiliateLeaderDashboard
     */
    'parentAddress': string;
    /**
     * Name of the parent affiliate
     * @type {string}
     * @memberof AffiliateLeaderDashboard
     */
    'parentName'?: string;
    /**
     * Ranking in perps trading category
     * @type {number}
     * @memberof AffiliateLeaderDashboard
     */
    'perpsRank': number;
    /**
     * Ranking in spot trading category
     * @type {number}
     * @memberof AffiliateLeaderDashboard
     */
    'spotRank': number;
    /**
     * Ranking in lending category
     * @type {number}
     * @memberof AffiliateLeaderDashboard
     */
    'lendingRank': number;
    /**
     * Total earnings from perps trading (e9 format)
     * @type {string}
     * @memberof AffiliateLeaderDashboard
     */
    'perpsTotalEarningsE9': string;
    /**
     * Total earnings from spot trading (e9 format)
     * @type {string}
     * @memberof AffiliateLeaderDashboard
     */
    'spotTotalEarningsE9': string;
    /**
     * Total earnings from lending (e9 format)
     * @type {string}
     * @memberof AffiliateLeaderDashboard
     */
    'lendingTotalEarningsE9': string;
}
/**
 * 
 * @export
 * @interface AffiliateMetadata
 */
export interface AffiliateMetadata {
    /**
     * The user\'s wallet address
     * @type {string}
     * @memberof AffiliateMetadata
     */
    'userAddress': string;
    /**
     * The referral code of the parent affiliate
     * @type {string}
     * @memberof AffiliateMetadata
     */
    'parentReferralCode'?: string | null;
    /**
     * The user\'s referral code if approved as an affiliate
     * @type {string}
     * @memberof AffiliateMetadata
     */
    'referralCode'?: string | null;
    /**
     * The name of the affiliate
     * @type {string}
     * @memberof AffiliateMetadata
     */
    'name'?: string;
    /**
     * The name of the parent affiliate
     * @type {string}
     * @memberof AffiliateMetadata
     */
    'parentName'?: string | null;
    /**
     * 
     * @type {FeeConfigs}
     * @memberof AffiliateMetadata
     */
    'fees'?: FeeConfigs;
    /**
     * Status of the affiliate application
     * @type {string}
     * @memberof AffiliateMetadata
     */
    'status'?: AffiliateMetadataStatusEnum | null;
    /**
     * Indicates whether the user has traded or not
     * @type {boolean}
     * @memberof AffiliateMetadata
     */
    'hasTraded': boolean;
    /**
     * Tier of the affiliate
     * @type {string}
     * @memberof AffiliateMetadata
     */
    'tier'?: AffiliateMetadataTierEnum;
    /**
     * Indicates whether the affiliate is an ember affiliate
     * @type {boolean}
     * @memberof AffiliateMetadata
     */
    'isEmber'?: boolean;
}

export const AffiliateMetadataStatusEnum = {
    Pending: 'PENDING',
    Approved: 'APPROVED',
    Rejected: 'REJECTED'
} as const;

export type AffiliateMetadataStatusEnum = typeof AffiliateMetadataStatusEnum[keyof typeof AffiliateMetadataStatusEnum];
export const AffiliateMetadataTierEnum = {
    S: 'S',
    A: 'A',
    N: 'N',
    U: 'U'
} as const;

export type AffiliateMetadataTierEnum = typeof AffiliateMetadataTierEnum[keyof typeof AffiliateMetadataTierEnum];

/**
 * 
 * @export
 * @interface AffiliateOnboardResponse
 */
export interface AffiliateOnboardResponse {
    /**
     * Status of the application
     * @type {string}
     * @memberof AffiliateOnboardResponse
     */
    'status': AffiliateOnboardResponseStatusEnum;
    /**
     * Response message including rejection reason if application was rejected
     * @type {string}
     * @memberof AffiliateOnboardResponse
     */
    'message': string;
}

export const AffiliateOnboardResponseStatusEnum = {
    Approved: 'APPROVED',
    Rejected: 'REJECTED',
    Pending: 'PENDING'
} as const;

export type AffiliateOnboardResponseStatusEnum = typeof AffiliateOnboardResponseStatusEnum[keyof typeof AffiliateOnboardResponseStatusEnum];

/**
 * 
 * @export
 * @interface AffiliateOverview
 */
export interface AffiliateOverview {
    /**
     * The user\'s wallet address
     * @type {string}
     * @memberof AffiliateOverview
     */
    'userAddress': string;
    /**
     * Name of the affiliate
     * @type {string}
     * @memberof AffiliateOverview
     */
    'name'?: string;
    /**
     * Referee earnings from perps trading (e9 format)
     * @type {string}
     * @memberof AffiliateOverview
     */
    'perpsRefereeEarningsE9': string;
    /**
     * Referee earnings from spot LP (e9 format)
     * @type {string}
     * @memberof AffiliateOverview
     */
    'spotLPRefereeEarningsE9': string;
    /**
     * Referee earnings from lending (e9 format)
     * @type {string}
     * @memberof AffiliateOverview
     */
    'lendingRefereeEarningsE9': string;
    /**
     * Referee earnings from ember (e9 format)
     * @type {string}
     * @memberof AffiliateOverview
     */
    'emberRefereeEarningsE9': string;
    /**
     * Referral earnings from perps trading (e9 format)
     * @type {string}
     * @memberof AffiliateOverview
     */
    'perpsReferralEarningsE9': string;
    /**
     * Referral earnings from spot LP (e9 format)
     * @type {string}
     * @memberof AffiliateOverview
     */
    'spotLPReferralEarningsE9': string;
    /**
     * Referral earnings from lending (e9 format)
     * @type {string}
     * @memberof AffiliateOverview
     */
    'lendingReferralEarningsE9': string;
    /**
     * Total earnings from perps trading (e9 format)
     * @type {string}
     * @memberof AffiliateOverview
     */
    'perpsTotalEarningsE9': string;
    /**
     * Total earnings from spot LP (e9 format)
     * @type {string}
     * @memberof AffiliateOverview
     */
    'spotLPTotalEarningsE9': string;
    /**
     * Total earnings from lending (e9 format)
     * @type {string}
     * @memberof AffiliateOverview
     */
    'lendingTotalEarningsE9': string;
    /**
     * Total earnings from ember (e9 format)
     * @type {string}
     * @memberof AffiliateOverview
     */
    'emberTotalEarningsE9': string;
    /**
     * Total earnings from referrals (e9 format)
     * @type {string}
     * @memberof AffiliateOverview
     */
    'totalReferralEarningsE9': string;
    /**
     * Total earnings from referee activities (e9 format)
     * @type {string}
     * @memberof AffiliateOverview
     */
    'totalRefereeEarningsE9': string;
    /**
     * Total earnings combining referrals and referee activities (e9 format)
     * @type {string}
     * @memberof AffiliateOverview
     */
    'totalEarningsE9': string;
}
/**
 * 
 * @export
 * @interface AffiliateSummary
 */
export interface AffiliateSummary {
    /**
     * The user\'s wallet address
     * @type {string}
     * @memberof AffiliateSummary
     */
    'userAddress': string;
    /**
     * Total number of referees
     * @type {number}
     * @memberof AffiliateSummary
     */
    'totalReferredUsers': number;
    /**
     * Total earnings in e9 format
     * @type {string}
     * @memberof AffiliateSummary
     */
    'totalEarningsE9': string;
    /**
     * Ranking in perps trading category
     * @type {number}
     * @memberof AffiliateSummary
     */
    'perpsRanking': number;
    /**
     * Ranking in spot trading category
     * @type {number}
     * @memberof AffiliateSummary
     */
    'spotRanking': number;
    /**
     * Ranking in lending category
     * @type {number}
     * @memberof AffiliateSummary
     */
    'lendRanking': number;
}
/**
 * Details about an asset in the account.
 * @export
 * @interface Asset
 */
export interface Asset {
    /**
     * The symbol of the asset.
     * @type {string}
     * @memberof Asset
     */
    'symbol': string;
    /**
     * The quantity of the asset.
     * @type {string}
     * @memberof Asset
     */
    'quantityE9': string;
    /**
     * The effective balance of the asset.
     * @type {string}
     * @memberof Asset
     */
    'effectiveBalanceE9': string;
    /**
     * The maximum quantity that can be withdrawn.
     * @type {string}
     * @memberof Asset
     */
    'maxWithdrawQuantityE9': string;
    /**
     * The timestamp of the last update in milliseconds.
     * @type {number}
     * @memberof Asset
     */
    'updatedAtMillis': number;
}
/**
 * 
 * @export
 * @interface AssetConfig
 */
export interface AssetConfig {
    /**
     * The bank address of the asset.
     * @type {string}
     * @memberof AssetConfig
     */
    'assetType': string;
    /**
     * Asset symbol.
     * @type {string}
     * @memberof AssetConfig
     */
    'symbol': string;
    /**
     * Default precision for rendering this asset.
     * @type {number}
     * @memberof AssetConfig
     */
    'decimals': number;
    /**
     * Weight applied to asset to use as margin in Multi-Assets mode.
     * @type {string}
     * @memberof AssetConfig
     */
    'weight': string;
    /**
     * Indicates if the asset can be used as margin in Multi-Assets mode.
     * @type {boolean}
     * @memberof AssetConfig
     */
    'marginAvailable': boolean;
}
/**
 * 
 * @export
 * @interface AuthorizedWallet
 */
export interface AuthorizedWallet {
    /**
     * The address of the authorized wallet.
     * @type {string}
     * @memberof AuthorizedWallet
     */
    'address': string;
    /**
     * The alias of the authorized wallet.
     * @type {string}
     * @memberof AuthorizedWallet
     */
    'alias'?: string;
    /**
     * The timestamp in milliseconds when the wallet was authorized.
     * @type {number}
     * @memberof AuthorizedWallet
     */
    'authorizedAtMillis': number;
}
/**
 * 
 * @export
 * @interface CampaignMetadata
 */
export interface CampaignMetadata {
    /**
     * 
     * @type {string}
     * @memberof CampaignMetadata
     */
    'Status': CampaignMetadataStatusEnum;
    /**
     * Name of the campaign.
     * @type {string}
     * @memberof CampaignMetadata
     */
    'CampaignName': string;
    /**
     * Name of the parent campaign.
     * @type {string}
     * @memberof CampaignMetadata
     */
    'ParentCampaignName': string;
    /**
     * Time in seconds for campaign start date.
     * @type {number}
     * @memberof CampaignMetadata
     */
    'StartDate': number;
    /**
     * Time in seconds for campaign end date.
     * @type {number}
     * @memberof CampaignMetadata
     */
    'EndDate': number;
}

export const CampaignMetadataStatusEnum = {
    Active: 'ACTIVE',
    Inactive: 'INACTIVE'
} as const;

export type CampaignMetadataStatusEnum = typeof CampaignMetadataStatusEnum[keyof typeof CampaignMetadataStatusEnum];

/**
 * Cancelling Orders for a specific symbol. If order hashes are not specified, all orders are canceled for this symbol
 * @export
 * @interface CancelOrdersRequest
 */
export interface CancelOrdersRequest {
    /**
     * The symbol of the perpetual for which to cancel orders.
     * @type {string}
     * @memberof CancelOrdersRequest
     */
    'symbol': string;
    /**
     * List of order hashes of the orders to be cancelled. All orders must belong to accountAddress. Max 10 order hashes
     * @type {Array<string>}
     * @memberof CancelOrdersRequest
     */
    'orderHashes'?: Array<string>;
}
/**
 * Response to a request to cancel orders.
 * @export
 * @interface CancelOrdersResponse
 */
export interface CancelOrdersResponse {
    /**
     * The order hashes of the cancelled orders.
     * @type {Array<string>}
     * @memberof CancelOrdersResponse
     */
    'orderHashes': Array<string>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const CandlePriceType = {
    Last: 'Last',
    Market: 'Market',
    Oracle: 'Oracle',
    Unspecified: 'UNSPECIFIED'
} as const;

export type CandlePriceType = typeof CandlePriceType[keyof typeof CandlePriceType];


/**
 * Represents a candlestick for a specific market and interval.
 * @export
 * @interface CandlestickUpdate
 */
export interface CandlestickUpdate {
    /**
     * The symbol of the market for this candlestick.
     * @type {string}
     * @memberof CandlestickUpdate
     */
    'symbol': string;
    /**
     * The start time of the candlestick in milliseconds since epoch.
     * @type {number}
     * @memberof CandlestickUpdate
     */
    'startTime': number;
    /**
     * The end time of the candlestick in milliseconds since epoch.
     * @type {number}
     * @memberof CandlestickUpdate
     */
    'endTime': number;
    /**
     * The interval of the candlestick (e.g., 1m, 5m, 1h).
     * @type {string}
     * @memberof CandlestickUpdate
     */
    'interval': string;
    /**
     * The opening price of the candlestick.
     * @type {string}
     * @memberof CandlestickUpdate
     */
    'openPriceE9': string;
    /**
     * The closing price of the candlestick.
     * @type {string}
     * @memberof CandlestickUpdate
     */
    'closePriceE9': string;
    /**
     * The highest price during the candlestick interval.
     * @type {string}
     * @memberof CandlestickUpdate
     */
    'highPriceE9': string;
    /**
     * The lowest price during the candlestick interval.
     * @type {string}
     * @memberof CandlestickUpdate
     */
    'lowPriceE9': string;
    /**
     * The total trading volume during the candlestick interval.
     * @type {string}
     * @memberof CandlestickUpdate
     */
    'volumeE9': string;
    /**
     * The total quote volume traded during the candlestick interval.
     * @type {string}
     * @memberof CandlestickUpdate
     */
    'quoteVolumeE9': string;
    /**
     * The number of trades that occurred during the candlestick interval.
     * @type {number}
     * @memberof CandlestickUpdate
     */
    'numTrades': number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const CommandFailureReasonCode = {
    Unspecified: 'UNSPECIFIED',
    UnknownAddress: 'UNKNOWN_ADDRESS',
    UnknownSymbol: 'UNKNOWN_SYMBOL',
    NoPosition: 'NO_POSITION',
    InsufficientBalance: 'INSUFFICIENT_BALANCE',
    DuplicateCommandHash: 'DUPLICATE_COMMAND_HASH',
    InvalidLeverage: 'INVALID_LEVERAGE',
    UnknownMarket: 'UNKNOWN_MARKET',
    WithdrawZero: 'WITHDRAW_ZERO',
    Unexpected: 'UNEXPECTED'
} as const;

export type CommandFailureReasonCode = typeof CommandFailureReasonCode[keyof typeof CommandFailureReasonCode];


/**
 * Contract configuration for the exchange.
 * @export
 * @interface ContractsConfig
 */
export interface ContractsConfig {
    /**
     * External Data Store Address
     * @type {string}
     * @memberof ContractsConfig
     */
    'edsId': string;
    /**
     * External Data Store Address
     * @type {string}
     * @memberof ContractsConfig
     */
    'idsId': string;
    /**
     * Network environment
     * @type {string}
     * @memberof ContractsConfig
     */
    'network': ContractsConfigNetworkEnum;
    /**
     * Base contract address
     * @type {string}
     * @memberof ContractsConfig
     */
    'baseContractAddress': string;
    /**
     * Current contract address
     * @type {string}
     * @memberof ContractsConfig
     */
    'currentContractAddress': string;
    /**
     * 
     * @type {Operators}
     * @memberof ContractsConfig
     */
    'operators': Operators;
}

export const ContractsConfigNetworkEnum = {
    Mainnet: 'mainnet',
    Testnet: 'testnet',
    Devnet: 'devnet'
} as const;

export type ContractsConfigNetworkEnum = typeof ContractsConfigNetworkEnum[keyof typeof ContractsConfigNetworkEnum];

/**
 * 
 * @export
 * @interface CountryResponse
 */
export interface CountryResponse {
    /**
     * The country code in ISO 3166-1 alpha-2 format.
     * @type {string}
     * @memberof CountryResponse
     */
    'country': string;
    /**
     * Indicates if the country is blocked.
     * @type {boolean}
     * @memberof CountryResponse
     */
    'isBlockedCountry': boolean;
}
/**
 * 
 * @export
 * @interface CreateOrderRequest
 */
export interface CreateOrderRequest {
    /**
     * 
     * @type {CreateOrderRequestSignedFields}
     * @memberof CreateOrderRequest
     */
    'signedFields': CreateOrderRequestSignedFields;
    /**
     * The signature of the request, encoded from the signedFields
     * @type {string}
     * @memberof CreateOrderRequest
     */
    'signature': string;
    /**
     * The client-defined unique identifier of this order used for lookup. This should always be unique; however, the server will not gurantee this or impose any checks.
     * @type {string}
     * @memberof CreateOrderRequest
     */
    'clientOrderId'?: string;
    /**
     * 
     * @type {OrderType}
     * @memberof CreateOrderRequest
     */
    'type': OrderType;
    /**
     * Is this order to only reduce a position? Default false
     * @type {boolean}
     * @memberof CreateOrderRequest
     */
    'reduceOnly': boolean;
    /**
     * If set to TRUE, the order can only be a maker order
     * @type {boolean}
     * @memberof CreateOrderRequest
     */
    'postOnly'?: boolean;
    /**
     * Omit or set to null for market orders; otherwise, choose a valid time-in-force value. GTT: Good Til Time  IOC: Immediate Or Cancel  FOK: Fill Or Kill 
     * @type {OrderTimeInForce}
     * @memberof CreateOrderRequest
     */
    'timeInForce'?: OrderTimeInForce;
    /**
     * Trigger price in base e9 for stop orders. This should always be a number
     * @type {string}
     * @memberof CreateOrderRequest
     */
    'triggerPriceE9'?: string;
    /**
     * 
     * @type {SelfTradePreventionType}
     * @memberof CreateOrderRequest
     */
    'selfTradePreventionType'?: SelfTradePreventionType;
}


/**
 * 
 * @export
 * @interface CreateOrderRequestSignedFields
 */
export interface CreateOrderRequestSignedFields {
    /**
     * The symbol of the perpetual for which to create the order
     * @type {string}
     * @memberof CreateOrderRequestSignedFields
     */
    'symbol': string;
    /**
     * The account address of the order. May be an account user is authorized for.
     * @type {string}
     * @memberof CreateOrderRequestSignedFields
     */
    'accountAddress': string;
    /**
     * The price in base e9 of the asset to be traded. Should always be a number
     * @type {string}
     * @memberof CreateOrderRequestSignedFields
     */
    'priceE9': string;
    /**
     * The quantity in base e9 of the asset to be traded. Should always be a number
     * @type {string}
     * @memberof CreateOrderRequestSignedFields
     */
    'quantityE9': string;
    /**
     * 
     * @type {OrderSide}
     * @memberof CreateOrderRequestSignedFields
     */
    'side': OrderSide;
    /**
     * The leverage in base e9 of the order to be traded. Should always be a number
     * @type {string}
     * @memberof CreateOrderRequestSignedFields
     */
    'leverageE9': string;
    /**
     * Is this order isolated or cross margin. Note market must be set to the same mode.
     * @type {boolean}
     * @memberof CreateOrderRequestSignedFields
     */
    'isIsolated': boolean;
    /**
     * The random generated SALT. Should always be a number
     * @type {string}
     * @memberof CreateOrderRequestSignedFields
     */
    'salt': string;
    /**
     * the ID of the internal datastore for the target network
     * @type {string}
     * @memberof CreateOrderRequestSignedFields
     */
    'idsId': string;
    /**
     * The timestamp in millis at which order will expire.
     * @type {number}
     * @memberof CreateOrderRequestSignedFields
     */
    'expiresAtMillis': number;
    /**
     * The timestamp in millis at which the request was signed
     * @type {number}
     * @memberof CreateOrderRequestSignedFields
     */
    'signedAtMillis': number;
}


/**
 * 
 * @export
 * @interface CreateOrderResponse
 */
export interface CreateOrderResponse {
    /**
     * The unique identifier of this order, to be used as a lookup key
     * @type {string}
     * @memberof CreateOrderResponse
     */
    'orderHash': string;
}
/**
 * 
 * @export
 * @interface EpochConfigs
 */
export interface EpochConfigs {
    /**
     * The name of the campaign.
     * @type {string}
     * @memberof EpochConfigs
     */
    'campaignName': string;
    /**
     * Duration of the epoch in seconds.
     * @type {number}
     * @memberof EpochConfigs
     */
    'epochDuration': number;
    /**
     * Allocation of Sui token rewards in the epoch (e9 format).
     * @type {string}
     * @memberof EpochConfigs
     */
    'suiRewardsAllocationE9': string;
    /**
     * Allocation of Blue token rewards in the epoch (e9 format).
     * @type {string}
     * @memberof EpochConfigs
     */
    'blueRewardsAllocationE9': string;
    /**
     * Allocation of wal token rewards in the epoch (e9 format)
     * @type {string}
     * @memberof EpochConfigs
     */
    'walRewardsAllocationE9': string;
    /**
     * Interval number for the epoch.
     * @type {number}
     * @memberof EpochConfigs
     */
    'intervalNumber': number;
    /**
     * Epoch number for the epoch.
     * @type {number}
     * @memberof EpochConfigs
     */
    'epochNumber': number;
    /**
     * Object to add custom configurations for campaigns.
     * @type {{ [key: string]: any | undefined; }}
     * @memberof EpochConfigs
     */
    'config': { [key: string]: any | undefined; };
}
/**
 * 
 * @export
 * @interface EpochConfigsResponse
 */
export interface EpochConfigsResponse {
    /**
     * The maximum interval number available.
     * @type {number}
     * @memberof EpochConfigsResponse
     */
    'maxIntervalNumber': number;
    /**
     * The current interval number being queried.
     * @type {number}
     * @memberof EpochConfigsResponse
     */
    'intervalNumber': number;
    /**
     * List of epoch configs for different campaigns.
     * @type {Array<EpochConfigs>}
     * @memberof EpochConfigsResponse
     */
    'data': Array<EpochConfigs>;
}
/**
 * 
 * @export
 * @interface EpochMetadata
 */
export interface EpochMetadata {
    /**
     * 
     * @type {string}
     * @memberof EpochMetadata
     */
    'Status': EpochMetadataStatusEnum;
    /**
     * Name of the campaign.
     * @type {string}
     * @memberof EpochMetadata
     */
    'CampaignName': string;
    /**
     * Epoch Id of the epoch.
     * @type {number}
     * @memberof EpochMetadata
     */
    'EpochId': number;
    /**
     * Epoch number for the queried epoch.
     * @type {number}
     * @memberof EpochMetadata
     */
    'EpochNumber': number;
    /**
     * Time in seconds for campaign start date.
     * @type {number}
     * @memberof EpochMetadata
     */
    'StartDate': number;
    /**
     * Time in seconds for campaign end date.
     * @type {number}
     * @memberof EpochMetadata
     */
    'EndDate': number;
}

export const EpochMetadataStatusEnum = {
    Active: 'ACTIVE',
    NotStarted: 'NOT_STARTED',
    Finalized: 'FINALIZED',
    Cooldown: 'COOLDOWN'
} as const;

export type EpochMetadataStatusEnum = typeof EpochMetadataStatusEnum[keyof typeof EpochMetadataStatusEnum];

/**
 * 
 * @export
 * @interface ExchangeInfoResponse
 */
export interface ExchangeInfoResponse {
    /**
     * List of assets available on the exchange.
     * @type {Array<AssetConfig>}
     * @memberof ExchangeInfoResponse
     */
    'assets': Array<AssetConfig>;
    /**
     * 
     * @type {ContractsConfig}
     * @memberof ExchangeInfoResponse
     */
    'contractsConfig'?: ContractsConfig;
    /**
     * List of markets available on the exchange.
     * @type {Array<Market>}
     * @memberof ExchangeInfoResponse
     */
    'markets': Array<Market>;
    /**
     * Current gas fee set for subsidized trades (e9 format)
     * @type {string}
     * @memberof ExchangeInfoResponse
     */
    'tradingGasFeeE9': string;
    /**
     * Server time in milliseconds.
     * @type {number}
     * @memberof ExchangeInfoResponse
     */
    'serverTimeAtMillis': number;
    /**
     * Timezone of the exchange.
     * @type {string}
     * @memberof ExchangeInfoResponse
     */
    'timezone': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const FailedCommandType = {
    PositionIsolatedMarginUpdate: 'POSITION_ISOLATED_MARGIN_UPDATE',
    PositionLeverageUpdate: 'POSITION_LEVERAGE_UPDATE',
    Withdraw: 'WITHDRAW'
} as const;

export type FailedCommandType = typeof FailedCommandType[keyof typeof FailedCommandType];


/**
 * Map of various fee-related configurations
 * @export
 * @interface FeeConfigs
 */
export interface FeeConfigs {
    /**
     * Earnings from referral perps fees
     * @type {string}
     * @memberof FeeConfigs
     */
    'referralPerpsFee'?: string;
    /**
     * Earnings from subaffiliate perps
     * @type {string}
     * @memberof FeeConfigs
     */
    'subaffiliatePerpsEarnings'?: string;
    /**
     * Earnings from spot LP fees
     * @type {string}
     * @memberof FeeConfigs
     */
    'spotLPFee'?: string;
    /**
     * Earnings from referral spot LP fees
     * @type {string}
     * @memberof FeeConfigs
     */
    'referralSpotLPFee'?: string;
    /**
     * Earnings from referral lending rewards
     * @type {string}
     * @memberof FeeConfigs
     */
    'referralLendingRewards'?: string;
    /**
     * Cashback from perps fees
     * @type {string}
     * @memberof FeeConfigs
     */
    'perpsFeeCashback'?: string;
    /**
     * Revenue share percentage for perps
     * @type {string}
     * @memberof FeeConfigs
     */
    'perpsRevShare'?: string;
    /**
     * Ember refferal share for an affiliate
     * @type {string}
     * @memberof FeeConfigs
     */
    'emberRefferalShare'?: string;
    /**
     * Ember revenue share for an affiliate
     * @type {string}
     * @memberof FeeConfigs
     */
    'emberRevShare'?: string;
}
/**
 * 
 * @export
 * @interface FundingRateEntry
 */
export interface FundingRateEntry {
    /**
     * The market symbol.
     * @type {string}
     * @memberof FundingRateEntry
     */
    'symbol': string;
    /**
     * Timestamp of the funding time in milliseconds.
     * @type {number}
     * @memberof FundingRateEntry
     */
    'fundingTimeAtMillis': number;
    /**
     * Funding rate for the market address.
     * @type {string}
     * @memberof FundingRateEntry
     */
    'fundingRateE9': string;
}
/**
 * 
 * @export
 * @interface GetAffiliateIntervalOverview200Response
 */
export interface GetAffiliateIntervalOverview200Response {
    /**
     * 
     * @type {Array<AffiliateIntervalOverview>}
     * @memberof GetAffiliateIntervalOverview200Response
     */
    'data'?: Array<AffiliateIntervalOverview>;
    /**
     * Total number of records
     * @type {number}
     * @memberof GetAffiliateIntervalOverview200Response
     */
    'total'?: number;
    /**
     * The page size for pagination
     * @type {number}
     * @memberof GetAffiliateIntervalOverview200Response
     */
    'limit'?: number;
    /**
     * The page number for pagination
     * @type {number}
     * @memberof GetAffiliateIntervalOverview200Response
     */
    'page'?: number;
}
/**
 * 
 * @export
 * @interface GetAffiliateLeaderDashboard200Response
 */
export interface GetAffiliateLeaderDashboard200Response {
    /**
     * 
     * @type {Array<AffiliateLeaderDashboard>}
     * @memberof GetAffiliateLeaderDashboard200Response
     */
    'data'?: Array<AffiliateLeaderDashboard>;
    /**
     * Total number of records
     * @type {number}
     * @memberof GetAffiliateLeaderDashboard200Response
     */
    'total'?: number;
    /**
     * The page size for pagination
     * @type {number}
     * @memberof GetAffiliateLeaderDashboard200Response
     */
    'limit'?: number;
    /**
     * The page number for pagination
     * @type {number}
     * @memberof GetAffiliateLeaderDashboard200Response
     */
    'page'?: number;
}
/**
 * 
 * @export
 * @interface GetAffiliateOverview200Response
 */
export interface GetAffiliateOverview200Response {
    /**
     * 
     * @type {Array<AffiliateOverview>}
     * @memberof GetAffiliateOverview200Response
     */
    'data'?: Array<AffiliateOverview>;
    /**
     * Total number of records
     * @type {number}
     * @memberof GetAffiliateOverview200Response
     */
    'total'?: number;
    /**
     * The page size for pagination
     * @type {number}
     * @memberof GetAffiliateOverview200Response
     */
    'limit'?: number;
    /**
     * The page number for pagination
     * @type {number}
     * @memberof GetAffiliateOverview200Response
     */
    'page'?: number;
}
/**
 * 
 * @export
 * @interface IntervalMetadata
 */
export interface IntervalMetadata {
    /**
     * 
     * @type {string}
     * @memberof IntervalMetadata
     */
    'Status': IntervalMetadataStatusEnum;
    /**
     * Time in seconds for interval start date.
     * @type {number}
     * @memberof IntervalMetadata
     */
    'StartDate': number;
    /**
     * Time in seconds for interval end date.
     * @type {number}
     * @memberof IntervalMetadata
     */
    'EndDate': number;
    /**
     * Interval Id of the interval.
     * @type {number}
     * @memberof IntervalMetadata
     */
    'IntervalId': number;
    /**
     * Type of the interval.
     * @type {string}
     * @memberof IntervalMetadata
     */
    'IntervalType': string;
}

export const IntervalMetadataStatusEnum = {
    Active: 'ACTIVE',
    NotStarted: 'NOT_STARTED',
    Finalized: 'FINALIZED',
    Cooldown: 'COOLDOWN'
} as const;

export type IntervalMetadataStatusEnum = typeof IntervalMetadataStatusEnum[keyof typeof IntervalMetadataStatusEnum];

/**
 * 
 * @export
 * @interface IntervalRewards
 */
export interface IntervalRewards {
    /**
     * User address for the rewards earned data.
     * @type {string}
     * @memberof IntervalRewards
     */
    'UserAddress': string;
    /**
     * 
     * @type {string}
     * @memberof IntervalRewards
     */
    'Status': IntervalRewardsStatusEnum;
    /**
     * Total Blue token rewards earned in the interval (e9 format).
     * @type {string}
     * @memberof IntervalRewards
     */
    'BlueRewardsE9': string;
    /**
     * Total Sui token rewards earned in the interval (e9 format).
     * @type {string}
     * @memberof IntervalRewards
     */
    'SuiRewardsE9': string;
    /**
     * Total wal rewards earned in the interval (e9 format).
     * @type {string}
     * @memberof IntervalRewards
     */
    'WalRewardsE9': string;
    /**
     * Interval Id of the interval for the rewards earned data.
     * @type {number}
     * @memberof IntervalRewards
     */
    'IntervalNumber': number;
}

export const IntervalRewardsStatusEnum = {
    Active: 'ACTIVE',
    NotStarted: 'NOT_STARTED',
    Finalized: 'FINALIZED',
    Cooldown: 'COOLDOWN'
} as const;

export type IntervalRewardsStatusEnum = typeof IntervalRewardsStatusEnum[keyof typeof IntervalRewardsStatusEnum];

/**
 * Base64 encoded ISS details with index.
 * @export
 * @interface IssBase64Details
 */
export interface IssBase64Details {
    /**
     * Base64 encoded ISS details value.
     * @type {string}
     * @memberof IssBase64Details
     */
    'value': string;
    /**
     * Index modulo 4 for the ISS details.
     * @type {number}
     * @memberof IssBase64Details
     */
    'indexMod4': number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const KlineInterval = {
    _1m: '1m',
    _3m: '3m',
    _5m: '5m',
    _15m: '15m',
    _30m: '30m',
    _1h: '1h',
    _2h: '2h',
    _4h: '4h',
    _6h: '6h',
    _8h: '8h',
    _12h: '12h',
    _1d: '1d',
    _1w: '1w',
    _1Mo: '1Mo',
    Unspecified: 'UNSPECIFIED'
} as const;

export type KlineInterval = typeof KlineInterval[keyof typeof KlineInterval];


/**
 * User is expected to sign this payload and sends is signature in login api as header and payload itself in request body 
 * @export
 * @interface LoginRequest
 */
export interface LoginRequest {
    /**
     * The address of the account.
     * @type {string}
     * @memberof LoginRequest
     */
    'accountAddress': string;
    /**
     * The timestamp in millis when the login was signed.
     * @type {number}
     * @memberof LoginRequest
     */
    'signedAtMillis': number;
    /**
     * The intended audience of the login request.
     * @type {string}
     * @memberof LoginRequest
     */
    'audience': string;
}
/**
 * 
 * @export
 * @interface LoginResponse
 */
export interface LoginResponse {
    /**
     * 
     * @type {string}
     * @memberof LoginResponse
     */
    'accessToken': string;
    /**
     * 
     * @type {number}
     * @memberof LoginResponse
     */
    'accessTokenValidForSeconds': number;
    /**
     * 
     * @type {string}
     * @memberof LoginResponse
     */
    'refreshToken': string;
    /**
     * 
     * @type {number}
     * @memberof LoginResponse
     */
    'refreshTokenValidForSeconds': number;
}
/**
 * Margin type.
 * @export
 * @enum {string}
 */

export const MarginType = {
    Cross: 'CROSS',
    Isolated: 'ISOLATED',
    Unspecified: 'UNSPECIFIED'
} as const;

export type MarginType = typeof MarginType[keyof typeof MarginType];


/**
 * 
 * @export
 * @interface MarkPriceUpdate
 */
export interface MarkPriceUpdate {
    /**
     * The symbol of the market.
     * @type {string}
     * @memberof MarkPriceUpdate
     */
    'symbol': string;
    /**
     * The price in scientific notation with 9 decimal places of precision.
     * @type {string}
     * @memberof MarkPriceUpdate
     */
    'priceE9': string;
    /**
     * 
     * @type {string}
     * @memberof MarkPriceUpdate
     */
    'source': MarkPriceUpdateSourceEnum;
    /**
     * The timestamp of the price update.
     * @type {number}
     * @memberof MarkPriceUpdate
     */
    'updatedAtMillis': number;
}

export const MarkPriceUpdateSourceEnum = {
    Mark: 'Mark'
} as const;

export type MarkPriceUpdateSourceEnum = typeof MarkPriceUpdateSourceEnum[keyof typeof MarkPriceUpdateSourceEnum];

/**
 * 
 * @export
 * @interface Market
 */
export interface Market {
    /**
     * Symbol of the market.
     * @type {string}
     * @memberof Market
     */
    'symbol': string;
    /**
     * Market address.
     * @type {string}
     * @memberof Market
     */
    'marketAddress': string;
    /**
     * 
     * @type {MarketStatus}
     * @memberof Market
     */
    'status': MarketStatus;
    /**
     * Base asset symbol.
     * @type {string}
     * @memberof Market
     */
    'baseAssetSymbol': string;
    /**
     * Base asset name.
     * @type {string}
     * @memberof Market
     */
    'baseAssetName': string;
    /**
     * Precision of the base asset.
     * @type {number}
     * @memberof Market
     */
    'baseAssetDecimals': number;
    /**
     * Step size for the quantity (e9 format).
     * @type {string}
     * @memberof Market
     */
    'stepSizeE9': string;
    /**
     * Price increment size (e9 format).
     * @type {string}
     * @memberof Market
     */
    'tickSizeE9': string;
    /**
     * Minimum order size (e9 format).
     * @type {string}
     * @memberof Market
     */
    'minOrderQuantityE9': string;
    /**
     * Maximum limit order size (e9 format).
     * @type {string}
     * @memberof Market
     */
    'maxLimitOrderQuantityE9': string;
    /**
     * Maximum market order size (e9 format).
     * @type {string}
     * @memberof Market
     */
    'maxMarketOrderQuantityE9': string;
    /**
     * Minimum order price (e9 format).
     * @type {string}
     * @memberof Market
     */
    'minOrderPriceE9': string;
    /**
     * Maximum order price (e9 format).
     * @type {string}
     * @memberof Market
     */
    'maxOrderPriceE9': string;
    /**
     * Maintenance margin ratio (MMR, e9 format).
     * @type {string}
     * @memberof Market
     */
    'maintenanceMarginRatioE9': string;
    /**
     * Initial margin ratio (IMR), e9 format).
     * @type {string}
     * @memberof Market
     */
    'initialMarginRatioE9': string;
    /**
     * Insurance pool ratio (e9 format).
     * @type {string}
     * @memberof Market
     */
    'insurancePoolRatioE9': string;
    /**
     * Default leverage (e9 format).
     * @type {string}
     * @memberof Market
     */
    'defaultLeverageE9': string;
    /**
     * Maximum notional value at current leverage. Index 0 is max notional value for leverage set to 1x, index 1 is for leverage 2x, etc...
     * @type {Array<string>}
     * @memberof Market
     */
    'maxNotionalAtOpenE9': Array<string>;
    /**
     * Minimum trade quantity allowed (e9 format).
     * @type {string}
     * @memberof Market
     */
    'minTradeQuantityE9': string;
    /**
     * Max trade quantity allowed (e9 format).
     * @type {string}
     * @memberof Market
     */
    'maxTradeQuantityE9': string;
    /**
     * Minimum trade price allowed (e9 format).
     * @type {string}
     * @memberof Market
     */
    'minTradePriceE9': string;
    /**
     * Maximum trade price allowed (e9 format).
     * @type {string}
     * @memberof Market
     */
    'maxTradePriceE9': string;
    /**
     * Maximum allowed funding rate (e9 format).
     * @type {string}
     * @memberof Market
     */
    'maxFundingRateE9': string;
    /**
     * Default maker fee (e9 format).
     * @type {string}
     * @memberof Market
     */
    'defaultMakerFeeE9': string;
    /**
     * Default taker fee (e9 format).
     * @type {string}
     * @memberof Market
     */
    'defaultTakerFeeE9': string;
    /**
     * Insurance pool address.
     * @type {string}
     * @memberof Market
     */
    'insurancePoolAddress': string;
    /**
     * Fee pool address.
     * @type {string}
     * @memberof Market
     */
    'feePoolAddress': string;
    /**
     * The time when trading will start/have started on the market.
     * @type {string}
     * @memberof Market
     */
    'tradingStartTimeAtMillis': string;
    /**
     * Maximum take bound for long positions (e9 format).
     * @type {string}
     * @memberof Market
     */
    'mtbLongE9': string;
    /**
     * Maximum take bound for short positions (e9 format).
     * @type {string}
     * @memberof Market
     */
    'mtbShortE9': string;
    /**
     * Delisting price (e9 format).
     * @type {string}
     * @memberof Market
     */
    'delistingPriceE9': string;
    /**
     * Indicates whether the market only allows isolated margin.
     * @type {boolean}
     * @memberof Market
     */
    'isolatedOnly': boolean;
}


/**
 * 
 * @export
 * @enum {string}
 */

export const MarketDataStreamName = {
    RecentTrade: 'Recent_Trade',
    Ticker: 'Ticker',
    TickerAll: 'Ticker_All',
    DiffDepth10Ms: 'Diff_Depth_10_ms',
    DiffDepth200Ms: 'Diff_Depth_200_ms',
    DiffDepth500Ms: 'Diff_Depth_500_ms',
    PartialDepth5: 'Partial_Depth_5',
    PartialDepth10: 'Partial_Depth_10',
    PartialDepth20: 'Partial_Depth_20',
    OraclePrice: 'Oracle_Price',
    MarkPrice: 'Mark_Price',
    MarketPrice: 'Market_Price',
    Candlestick1mLast: 'Candlestick_1m_Last',
    Candlestick3mLast: 'Candlestick_3m_Last',
    Candlestick5mLast: 'Candlestick_5m_Last',
    Candlestick15mLast: 'Candlestick_15m_Last',
    Candlestick30mLast: 'Candlestick_30m_Last',
    Candlestick1hLast: 'Candlestick_1h_Last',
    Candlestick2hLast: 'Candlestick_2h_Last',
    Candlestick4hLast: 'Candlestick_4h_Last',
    Candlestick6hLast: 'Candlestick_6h_Last',
    Candlestick8hLast: 'Candlestick_8h_Last',
    Candlestick12hLast: 'Candlestick_12h_Last',
    Candlestick1dLast: 'Candlestick_1d_Last',
    Candlestick1wLast: 'Candlestick_1w_Last',
    Candlestick1MoLast: 'Candlestick_1Mo_Last',
    Candlestick1mOracle: 'Candlestick_1m_Oracle',
    Candlestick3mOracle: 'Candlestick_3m_Oracle',
    Candlestick5mOracle: 'Candlestick_5m_Oracle',
    Candlestick15mOracle: 'Candlestick_15m_Oracle',
    Candlestick30mOracle: 'Candlestick_30m_Oracle',
    Candlestick1hOracle: 'Candlestick_1h_Oracle',
    Candlestick2hOracle: 'Candlestick_2h_Oracle',
    Candlestick4hOracle: 'Candlestick_4h_Oracle',
    Candlestick6hOracle: 'Candlestick_6h_Oracle',
    Candlestick8hOracle: 'Candlestick_8h_Oracle',
    Candlestick12hOracle: 'Candlestick_12h_Oracle',
    Candlestick1dOracle: 'Candlestick_1d_Oracle',
    Candlestick1wOracle: 'Candlestick_1w_Oracle',
    Candlestick1MoOracle: 'Candlestick_1Mo_Oracle',
    Candlestick1mMark: 'Candlestick_1m_Mark',
    Candlestick3mMark: 'Candlestick_3m_Mark',
    Candlestick5mMark: 'Candlestick_5m_Mark',
    Candlestick15mMark: 'Candlestick_15m_Mark',
    Candlestick30mMark: 'Candlestick_30m_Mark',
    Candlestick1hMark: 'Candlestick_1h_Mark',
    Candlestick2hMark: 'Candlestick_2h_Mark',
    Candlestick4hMark: 'Candlestick_4h_Mark',
    Candlestick6hMark: 'Candlestick_6h_Mark',
    Candlestick8hMark: 'Candlestick_8h_Mark',
    Candlestick12hMark: 'Candlestick_12h_Mark',
    Candlestick1dMark: 'Candlestick_1d_Mark',
    Candlestick1wMark: 'Candlestick_1w_Mark',
    Candlestick1MoMark: 'Candlestick_1Mo_Mark',
    Candlestick1mMarket: 'Candlestick_1m_Market',
    Candlestick3mMarket: 'Candlestick_3m_Market',
    Candlestick5mMarket: 'Candlestick_5m_Market',
    Candlestick15mMarket: 'Candlestick_15m_Market',
    Candlestick30mMarket: 'Candlestick_30m_Market',
    Candlestick1hMarket: 'Candlestick_1h_Market',
    Candlestick2hMarket: 'Candlestick_2h_Market',
    Candlestick4hMarket: 'Candlestick_4h_Market',
    Candlestick6hMarket: 'Candlestick_6h_Market',
    Candlestick8hMarket: 'Candlestick_8h_Market',
    Candlestick12hMarket: 'Candlestick_12h_Market',
    Candlestick1dMarket: 'Candlestick_1d_Market',
    Candlestick1wMarket: 'Candlestick_1w_Market',
    Candlestick1MoMarket: 'Candlestick_1Mo_Market'
} as const;

export type MarketDataStreamName = typeof MarketDataStreamName[keyof typeof MarketDataStreamName];


/**
 * The type of event communicated in the WebSocket message.
 * @export
 * @enum {string}
 */

export const MarketEventType = {
    RecentTradesUpdates: 'RecentTradesUpdates',
    TickerUpdate: 'TickerUpdate',
    TickerAllUpdate: 'TickerAllUpdate',
    OraclePriceUpdate: 'OraclePriceUpdate',
    MarkPriceUpdate: 'MarkPriceUpdate',
    MarketPriceUpdate: 'MarketPriceUpdate',
    CandlestickUpdate: 'CandlestickUpdate',
    OrderbookDiffDepthUpdate: 'OrderbookDiffDepthUpdate',
    OrderbookPartialDepthUpdate: 'OrderbookPartialDepthUpdate'
} as const;

export type MarketEventType = typeof MarketEventType[keyof typeof MarketEventType];


/**
 * 
 * @export
 * @interface MarketPriceUpdate
 */
export interface MarketPriceUpdate {
    /**
     * The symbol of the market.
     * @type {string}
     * @memberof MarketPriceUpdate
     */
    'symbol': string;
    /**
     * The price in scientific notation with 9 decimal places of precision.
     * @type {string}
     * @memberof MarketPriceUpdate
     */
    'priceE9': string;
    /**
     * 
     * @type {string}
     * @memberof MarketPriceUpdate
     */
    'source': MarketPriceUpdateSourceEnum;
    /**
     * The timestamp of the price update.
     * @type {number}
     * @memberof MarketPriceUpdate
     */
    'updatedAtMillis': number;
}

export const MarketPriceUpdateSourceEnum = {
    Market: 'Market'
} as const;

export type MarketPriceUpdateSourceEnum = typeof MarketPriceUpdateSourceEnum[keyof typeof MarketPriceUpdateSourceEnum];

/**
 * 
 * @export
 * @enum {string}
 */

export const MarketStatus = {
    Active: 'ACTIVE',
    Beta: 'BETA',
    Maintenance: 'MAINTENANCE',
    Delisted: 'DELISTED',
    Unspecified: 'UNSPECIFIED'
} as const;

export type MarketStatus = typeof MarketStatus[keyof typeof MarketStatus];


/**
 * A market stream message containing an event type and a payload. The payload structure depends on the event type. 
 * @export
 * @interface MarketStreamMessage
 */
export interface MarketStreamMessage {
    /**
     * 
     * @type {MarketEventType}
     * @memberof MarketStreamMessage
     */
    'event': MarketEventType;
    /**
     * 
     * @type {MarketStreamMessagePayload}
     * @memberof MarketStreamMessage
     */
    'payload': MarketStreamMessagePayload;
}


/**
 * @type MarketStreamMessagePayload
 * The payload of the message, which varies based on the event type.
 * @export
 */
export type MarketStreamMessagePayload = CandlestickUpdate | MarkPriceUpdate | MarketPriceUpdate | OraclePriceUpdate | OrderbookDiffDepthUpdate | OrderbookPartialDepthUpdate | RecentTradesUpdates | TickerAllUpdate | TickerUpdate;

/**
 * Subscription message for market data streams.
 * @export
 * @interface MarketSubscriptionMessage
 */
export interface MarketSubscriptionMessage {
    /**
     * 
     * @type {SubscriptionType}
     * @memberof MarketSubscriptionMessage
     */
    'method': SubscriptionType;
    /**
     * List of market data streams to subscribe or unsubscribe from.
     * @type {Array<MarketSubscriptionStreams>}
     * @memberof MarketSubscriptionMessage
     */
    'dataStreams': Array<MarketSubscriptionStreams>;
}


/**
 * Represents the type of market data stream and its parameters.
 * @export
 * @interface MarketSubscriptionStreams
 */
export interface MarketSubscriptionStreams {
    /**
     * The symbol of the market stream to subscribe to (Leave empty for TickerAll stream)
     * @type {string}
     * @memberof MarketSubscriptionStreams
     */
    'symbol': string;
    /**
     * 
     * @type {Array<MarketDataStreamName>}
     * @memberof MarketSubscriptionStreams
     */
    'streams': Array<MarketDataStreamName>;
}
/**
 * 
 * @export
 * @interface ModelError
 */
export interface ModelError {
    /**
     * A code representing the type of error.
     * @type {string}
     * @memberof ModelError
     */
    'errorCode'?: string;
    /**
     * A human-readable message describing the error.
     * @type {string}
     * @memberof ModelError
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface OnboardAffiliateRequest
 */
export interface OnboardAffiliateRequest {
    /**
     * Referral code of the parent affiliate
     * @type {string}
     * @memberof OnboardAffiliateRequest
     */
    'parentReferralCode'?: string | null;
    /**
     * Name of the applicant
     * @type {string}
     * @memberof OnboardAffiliateRequest
     */
    'name': string;
    /**
     * Email address of the applicant
     * @type {string}
     * @memberof OnboardAffiliateRequest
     */
    'email': string;
    /**
     * 
     * @type {OnboardAffiliateRequestSocialUserNames}
     * @memberof OnboardAffiliateRequest
     */
    'socialUserNames'?: OnboardAffiliateRequestSocialUserNames;
}
/**
 * Map of social media usernames
 * @export
 * @interface OnboardAffiliateRequestSocialUserNames
 */
export interface OnboardAffiliateRequestSocialUserNames {
    /**
     * Twitter username
     * @type {string}
     * @memberof OnboardAffiliateRequestSocialUserNames
     */
    'twitter'?: string;
    /**
     * Instagram username
     * @type {string}
     * @memberof OnboardAffiliateRequestSocialUserNames
     */
    'instagram'?: string;
    /**
     * YouTube channel name
     * @type {string}
     * @memberof OnboardAffiliateRequestSocialUserNames
     */
    'youtube'?: string;
    /**
     * TikTok username
     * @type {string}
     * @memberof OnboardAffiliateRequestSocialUserNames
     */
    'tiktok'?: string;
}
/**
 * 
 * @export
 * @interface OnboardRefereeRequest
 */
export interface OnboardRefereeRequest {
    /**
     * Referral code of the parent affiliate
     * @type {string}
     * @memberof OnboardRefereeRequest
     */
    'code': string;
}
/**
 * 
 * @export
 * @interface OpenOrderResponse
 */
export interface OpenOrderResponse {
    /**
     * The Order Hash, which is the default way to uniquely identify an order in the system
     * @type {string}
     * @memberof OpenOrderResponse
     */
    'orderHash': string;
    /**
     * The Client Order ID, which is used a unique identifier for an order, provided by the client, in case of proprietary order management systems
     * @type {string}
     * @memberof OpenOrderResponse
     */
    'clientOrderId'?: string;
    /**
     * The market symbol
     * @type {string}
     * @memberof OpenOrderResponse
     */
    'symbol': string;
    /**
     * The account address of the order. May be an account user is authorized for.
     * @type {string}
     * @memberof OpenOrderResponse
     */
    'accountAddress': string;
    /**
     * The signer address of the order. May be an account user is authorized for.
     * @type {string}
     * @memberof OpenOrderResponse
     */
    'signerAddress': string;
    /**
     * The price in base e9 of the asset to be traded. Should always be a number
     * @type {string}
     * @memberof OpenOrderResponse
     */
    'priceE9': string;
    /**
     * The quantity in base e9 of the asset to be traded. Should always be a number
     * @type {string}
     * @memberof OpenOrderResponse
     */
    'quantityE9': string;
    /**
     * 
     * @type {OrderSide}
     * @memberof OpenOrderResponse
     */
    'side': OrderSide;
    /**
     * The leverage in base e9  of the order to be traded. Should always be a number
     * @type {string}
     * @memberof OpenOrderResponse
     */
    'leverageE9': string;
    /**
     * Is this order isolated or cross margin. Note market must be set to the same mode.
     * @type {boolean}
     * @memberof OpenOrderResponse
     */
    'isIsolated': boolean;
    /**
     * The random generated SALT. Should always be a number
     * @type {string}
     * @memberof OpenOrderResponse
     */
    'salt': string;
    /**
     * Unix timestamp in millis at which order will expire. Defaults to 1 month for LIMIT orders if not provided
     * @type {number}
     * @memberof OpenOrderResponse
     */
    'expiresAtMillis': number;
    /**
     * The timestamp in millis at which the request was signed
     * @type {number}
     * @memberof OpenOrderResponse
     */
    'signedAtMillis': number;
    /**
     * 
     * @type {OrderType}
     * @memberof OpenOrderResponse
     */
    'type': OrderType;
    /**
     * Is this order to only reduce a position? Default false
     * @type {boolean}
     * @memberof OpenOrderResponse
     */
    'reduceOnly': boolean;
    /**
     * If set to TRUE, the order can only be a maker order
     * @type {boolean}
     * @memberof OpenOrderResponse
     */
    'postOnly': boolean;
    /**
     * 
     * @type {OrderTimeInForce}
     * @memberof OpenOrderResponse
     */
    'timeInForce': OrderTimeInForce;
    /**
     * Trigger price in base e9 for stop orders. This should always be a number
     * @type {string}
     * @memberof OpenOrderResponse
     */
    'triggerPriceE9'?: string;
    /**
     * The quantity in base e9 of the asset currently filled. This should always be a number
     * @type {string}
     * @memberof OpenOrderResponse
     */
    'filledQuantityE9': string;
    /**
     * 
     * @type {OrderStatus}
     * @memberof OpenOrderResponse
     */
    'status': OrderStatus;
    /**
     * 
     * @type {SelfTradePreventionType}
     * @memberof OpenOrderResponse
     */
    'selfTradePreventionType': SelfTradePreventionType;
    /**
     * The timestamp in millis when the order was opened
     * @type {number}
     * @memberof OpenOrderResponse
     */
    'orderTimeAtMillis': number;
    /**
     * The timestamp in millis that this order was last updated (including status updates)
     * @type {number}
     * @memberof OpenOrderResponse
     */
    'updatedAtMillis': number;
}


/**
 * 
 * @export
 * @interface Operators
 */
export interface Operators {
    /**
     * Admin operator address
     * @type {string}
     * @memberof Operators
     */
    'admin': string;
    /**
     * General operator address; AKA Guardian
     * @type {string}
     * @memberof Operators
     * @deprecated
     */
    'operator': string;
    /**
     * Sequencer operator address
     * @type {string}
     * @memberof Operators
     */
    'sequencer': string;
    /**
     * Funding operator address
     * @type {string}
     * @memberof Operators
     * @deprecated
     */
    'funding': string;
    /**
     * Fee operator address
     * @type {string}
     * @memberof Operators
     * @deprecated
     */
    'fee': string;
}
/**
 * 
 * @export
 * @interface OraclePriceUpdate
 */
export interface OraclePriceUpdate {
    /**
     * The symbol of the market.
     * @type {string}
     * @memberof OraclePriceUpdate
     */
    'symbol': string;
    /**
     * The price in scientific notation with 9 decimal places of precision.
     * @type {string}
     * @memberof OraclePriceUpdate
     */
    'priceE9': string;
    /**
     * 
     * @type {string}
     * @memberof OraclePriceUpdate
     */
    'source': OraclePriceUpdateSourceEnum;
    /**
     * The timestamp of the price update.
     * @type {number}
     * @memberof OraclePriceUpdate
     */
    'updatedAtMillis': number;
}

export const OraclePriceUpdateSourceEnum = {
    Oracle: 'Oracle'
} as const;

export type OraclePriceUpdateSourceEnum = typeof OraclePriceUpdateSourceEnum[keyof typeof OraclePriceUpdateSourceEnum];

/**
 * The reason for an order cancellation.
 * @export
 * @enum {string}
 */

export const OrderCancelReason = {
    Unspecified: 'UNSPECIFIED',
    InsufficientMargin: 'INSUFFICIENT_MARGIN',
    DuplicateOrder: 'DUPLICATE_ORDER',
    PostOnlyWouldTrade: 'POST_ONLY_WOULD_TRADE',
    InvalidSymbol: 'INVALID_SYMBOL',
    SignedAtTooOld: 'SIGNED_AT_TOO_OLD',
    OrderExpired: 'ORDER_EXPIRED',
    InvalidLeverage: 'INVALID_LEVERAGE',
    InvalidInput: 'INVALID_INPUT',
    PriceOutOfBound: 'PRICE_OUT_OF_BOUND',
    QuantityOutOfBound: 'QUANTITY_OUT_OF_BOUND',
    PriceOutOfTickSize: 'PRICE_OUT_OF_TICK_SIZE',
    QuantityOutOfStepSize: 'QUANTITY_OUT_OF_STEP_SIZE',
    ReduceOnlyWouldOpen: 'REDUCE_ONLY_WOULD_OPEN',
    TooManyOpenOrdersOnMarket: 'TOO_MANY_OPEN_ORDERS_ON_MARKET',
    UserCancelled: 'USER_CANCELLED',
    UserCancelledAllOnMarket: 'USER_CANCELLED_ALL_ON_MARKET',
    SelfTradePrevention: 'SELF_TRADE_PREVENTION',
    LeverageUpdate: 'LEVERAGE_UPDATE',
    AccountNotFound: 'ACCOUNT_NOT_FOUND',
    MarketNotTrading: 'MARKET_NOT_TRADING',
    InsufficientLiquidity: 'INSUFFICIENT_LIQUIDITY',
    PositionNotFound: 'POSITION_NOT_FOUND',
    LiquidationOutOfOrder: 'LIQUIDATION_OUT_OF_ORDER',
    AccountNotLiquidatable: 'ACCOUNT_NOT_LIQUIDATABLE',
    OrderNotReducingPosition: 'ORDER_NOT_REDUCING_POSITION',
    UserCancelledAllStandbyOnMarket: 'USER_CANCELLED_ALL_STANDBY_ON_MARKET',
    PositionExceedsMaxOpenInterest: 'POSITION_EXCEEDS_MAX_OPEN_INTEREST',
    AccountDeauthorized: 'ACCOUNT_DEAUTHORIZED'
} as const;

export type OrderCancelReason = typeof OrderCancelReason[keyof typeof OrderCancelReason];


/**
 * The reason for failure to cancel an order.
 * @export
 * @enum {string}
 */

export const OrderCancellationFailureReason = {
    OrderNotFound: 'ORDER_NOT_FOUND',
    MarketNotFound: 'MARKET_NOT_FOUND',
    AccountNotFound: 'ACCOUNT_NOT_FOUND',
    NoOpenOrdersOnMarket: 'NO_OPEN_ORDERS_ON_MARKET',
    NoFailure: 'NO_FAILURE',
    Unspecified: 'UNSPECIFIED'
} as const;

export type OrderCancellationFailureReason = typeof OrderCancellationFailureReason[keyof typeof OrderCancellationFailureReason];


/**
 * Details of an order cancellation.
 * @export
 * @interface OrderCancellationUpdate
 */
export interface OrderCancellationUpdate {
    /**
     * The unique hash of the order.
     * @type {string}
     * @memberof OrderCancellationUpdate
     */
    'orderHash': string;
    /**
     * The client-provided order ID.
     * @type {string}
     * @memberof OrderCancellationUpdate
     */
    'clientOrderId'?: string;
    /**
     * The symbol of the market.
     * @type {string}
     * @memberof OrderCancellationUpdate
     */
    'symbol': string;
    /**
     * The address of the account.
     * @type {string}
     * @memberof OrderCancellationUpdate
     */
    'accountAddress': string;
    /**
     * The timestamp of the order creation in milliseconds.
     * @type {number}
     * @memberof OrderCancellationUpdate
     */
    'createdAtMillis': number;
    /**
     * 
     * @type {OrderCancelReason}
     * @memberof OrderCancellationUpdate
     */
    'cancellationReason': OrderCancelReason;
    /**
     * 
     * @type {OrderCancellationFailureReason}
     * @memberof OrderCancellationUpdate
     */
    'failureToCancelReason'?: OrderCancellationFailureReason;
    /**
     * The remaining quantity of the order.
     * @type {string}
     * @memberof OrderCancellationUpdate
     */
    'remainingQuantityE9': string;
}


/**
 * Side of the order
 * @export
 * @enum {string}
 */

export const OrderSide = {
    Long: 'LONG',
    Short: 'SHORT',
    Unspecified: 'UNSPECIFIED'
} as const;

export type OrderSide = typeof OrderSide[keyof typeof OrderSide];


/**
 * The current status of the order.
 * @export
 * @enum {string}
 */

export const OrderStatus = {
    Standby: 'STANDBY',
    Open: 'OPEN',
    PartiallyFilledOpen: 'PARTIALLY_FILLED_OPEN',
    PartiallyFilledCanceled: 'PARTIALLY_FILLED_CANCELED',
    Filled: 'FILLED',
    Cancelled: 'CANCELLED',
    Expired: 'EXPIRED',
    PartiallyFilledExpired: 'PARTIALLY_FILLED_EXPIRED',
    Unspecified: 'UNSPECIFIED'
} as const;

export type OrderStatus = typeof OrderStatus[keyof typeof OrderStatus];


/**
 * The time-in-force policy for the order. By default, all orders are GTT. UNSPECIFIED is set to default.  GTT: Good Til Time  IOC: Immediate Or Cancel  FOK: Fill Or Kill     
 * @export
 * @enum {string}
 */

export const OrderTimeInForce = {
    Gtt: 'GTT',
    Ioc: 'IOC',
    Fok: 'FOK',
    Unspecified: 'UNSPECIFIED'
} as const;

export type OrderTimeInForce = typeof OrderTimeInForce[keyof typeof OrderTimeInForce];


/**
 * The type of order. (BANKRUPTCY_LIQUIDATION is deprecated)
 * @export
 * @enum {string}
 */

export const OrderType = {
    Limit: 'LIMIT',
    Market: 'MARKET',
    StopLimit: 'STOP_LIMIT',
    StopMarket: 'STOP_MARKET',
    Liquidation: 'LIQUIDATION',
    StopLossMarket: 'STOP_LOSS_MARKET',
    TakeProfitMarket: 'TAKE_PROFIT_MARKET',
    StopLossLimit: 'STOP_LOSS_LIMIT',
    TakeProfitLimit: 'TAKE_PROFIT_LIMIT',
    BankruptcyLiquidation: 'BANKRUPTCY_LIQUIDATION',
    Unspecified: 'UNSPECIFIED'
} as const;

export type OrderType = typeof OrderType[keyof typeof OrderType];


/**
 * 
 * @export
 * @interface OrderbookDepthResponse
 */
export interface OrderbookDepthResponse {
    /**
     * Market symbol.
     * @type {string}
     * @memberof OrderbookDepthResponse
     */
    'symbol': string;
    /**
     * Count indicating the number of changes in orderbook state.
     * @type {number}
     * @memberof OrderbookDepthResponse
     */
    'lastUpdateId': number;
    /**
     * Timestamp at which the last change in orderbook state took place, in milliseconds.
     * @type {number}
     * @memberof OrderbookDepthResponse
     */
    'updatedAtMillis': number;
    /**
     * The time at which the orderbook server sent the response, in milliseconds.
     * @type {number}
     * @memberof OrderbookDepthResponse
     */
    'responseSentAtMillis': number;
    /**
     * The best bid price on orderbook at the moment (e9 format).
     * @type {string}
     * @memberof OrderbookDepthResponse
     */
    'bestBidPriceE9': string;
    /**
     * The best bid quantity on orderbook at the moment (e9 format).
     * @type {string}
     * @memberof OrderbookDepthResponse
     */
    'bestBidQuantityE9': string;
    /**
     * The best ask price on orderbook at the moment (e9 format).
     * @type {string}
     * @memberof OrderbookDepthResponse
     */
    'bestAskPriceE9': string;
    /**
     * The best ask quantity on orderbook at the moment (e9 format).
     * @type {string}
     * @memberof OrderbookDepthResponse
     */
    'bestAskQuantityE9': string;
    /**
     * Bids to be filled. Index 0 is price, index 1 is quantity at price bin. Prices are in e9 format.
     * @type {Array<Array<string>>}
     * @memberof OrderbookDepthResponse
     */
    'bidsE9': Array<Array<string>>;
    /**
     * Asks to be filled. Index 0 is price, index 1 is quantity at price bin. Prices are in e9 format.
     * @type {Array<Array<string>>}
     * @memberof OrderbookDepthResponse
     */
    'asksE9': Array<Array<string>>;
}
/**
 * 
 * @export
 * @interface OrderbookDiffDepthUpdate
 */
export interface OrderbookDiffDepthUpdate {
    /**
     * The timestamp of the orderbook update.
     * @type {number}
     * @memberof OrderbookDiffDepthUpdate
     */
    'updatedAtMillis': number;
    /**
     * The symbol of the market for the orderbook update.
     * @type {string}
     * @memberof OrderbookDiffDepthUpdate
     */
    'symbol': string;
    /**
     * 
     * @type {Array<Array<string>>}
     * @memberof OrderbookDiffDepthUpdate
     */
    'bidsE9': Array<Array<string>>;
    /**
     * 
     * @type {Array<Array<string>>}
     * @memberof OrderbookDiffDepthUpdate
     */
    'asksE9': Array<Array<string>>;
    /**
     * The ID of the first update in this batch.
     * @type {number}
     * @memberof OrderbookDiffDepthUpdate
     */
    'firstUpdateId': number;
    /**
     * The ID of the last update in this batch.
     * @type {number}
     * @memberof OrderbookDiffDepthUpdate
     */
    'lastUpdateId': number;
}
/**
 * 
 * @export
 * @interface OrderbookPartialDepthUpdate
 */
export interface OrderbookPartialDepthUpdate {
    /**
     * The timestamp of the partial depth update.
     * @type {number}
     * @memberof OrderbookPartialDepthUpdate
     */
    'updatedAtMillis': number;
    /**
     * The symbol of the market for the partial depth update.
     * @type {string}
     * @memberof OrderbookPartialDepthUpdate
     */
    'symbol': string;
    /**
     * 
     * @type {Array<Array<string>>}
     * @memberof OrderbookPartialDepthUpdate
     */
    'bidsE9': Array<Array<string>>;
    /**
     * 
     * @type {Array<Array<string>>}
     * @memberof OrderbookPartialDepthUpdate
     */
    'asksE9': Array<Array<string>>;
    /**
     * The unique identifier for the orderbook update.
     * @type {number}
     * @memberof OrderbookPartialDepthUpdate
     */
    'orderbookUpdateId': number;
    /**
     * The depth level of the orderbook snapshot.
     * @type {string}
     * @memberof OrderbookPartialDepthUpdate
     */
    'depthLevel': OrderbookPartialDepthUpdateDepthLevelEnum;
}

export const OrderbookPartialDepthUpdateDepthLevelEnum = {
    _5: '5',
    _10: '10',
    _20: '20'
} as const;

export type OrderbookPartialDepthUpdateDepthLevelEnum = typeof OrderbookPartialDepthUpdateDepthLevelEnum[keyof typeof OrderbookPartialDepthUpdateDepthLevelEnum];

/**
 * 
 * @export
 * @interface Position
 */
export interface Position {
    /**
     * Market address.
     * @type {string}
     * @memberof Position
     */
    'symbol': string;
    /**
     * Average entry price determined by a simple average of all entry prices resulting in this position size (e9 format).
     * @type {string}
     * @memberof Position
     */
    'avgEntryPriceE9': string;
    /**
     * Isolated position leverage (e9 format).
     * @type {string}
     * @memberof Position
     */
    'clientSetLeverageE9': string;
    /**
     * Liquidation price (e9 format).
     * @type {string}
     * @memberof Position
     */
    'liquidationPriceE9': string;
    /**
     * Mark price (e9 format).
     * @type {string}
     * @memberof Position
     */
    'markPriceE9': string;
    /**
     * Notional value (e9 format).
     * @type {string}
     * @memberof Position
     */
    'notionalValueE9': string;
    /**
     * Position size (e9 format).
     * @type {string}
     * @memberof Position
     */
    'sizeE9': string;
    /**
     * Unrealized profit (e9 format).
     * @type {string}
     * @memberof Position
     */
    'unrealizedPnlE9': string;
    /**
     * 
     * @type {PositionSide}
     * @memberof Position
     */
    'side': PositionSide;
    /**
     * Initial margin required with current mark price (e9 format).
     * @type {string}
     * @memberof Position
     */
    'marginRequiredE9': string;
    /**
     * Maintenance margin required with current mark price (e9 format).
     * @type {string}
     * @memberof Position
     */
    'maintenanceMarginE9': string;
    /**
     * If the position is isolated.
     * @type {boolean}
     * @memberof Position
     */
    'isIsolated': boolean;
    /**
     * Margin value present if margin type is isolated (e9 format).
     * @type {string}
     * @memberof Position
     */
    'isolatedMarginE9': string;
    /**
     * Last update time.
     * @type {number}
     * @memberof Position
     */
    'updatedAtMillis': number;
    /**
     * Total funding rate payment (e9 format).
     * @type {string}
     * @memberof Position
     */
    'fundingRatePaymentAllTimeE9': string;
    /**
     * Funding rate payment since last position change (e9 format).
     * @type {string}
     * @memberof Position
     */
    'fundingRatePaymentSinceChangeE9': string;
    /**
     * Funding rate payment since position opened (e9 format).
     * @type {string}
     * @memberof Position
     */
    'fundingRatePaymentSinceOpenedE9': string;
}


/**
 * The side of the position, either long or short
 * @export
 * @enum {string}
 */

export const PositionSide = {
    Long: 'LONG',
    Short: 'SHORT',
    Unspecified: 'UNSPECIFIED'
} as const;

export type PositionSide = typeof PositionSide[keyof typeof PositionSide];


/**
 * The generated zero-knowledge proof points.
 * @export
 * @interface ProofPoints
 */
export interface ProofPoints {
    /**
     * Point A of the proof.
     * @type {Array<string>}
     * @memberof ProofPoints
     */
    'a': Array<string>;
    /**
     * Point B of the proof.
     * @type {Array<Array<string>>}
     * @memberof ProofPoints
     */
    'b': Array<Array<string>>;
    /**
     * Point C of the proof.
     * @type {Array<string>}
     * @memberof ProofPoints
     */
    'c': Array<string>;
}
/**
 * 
 * @export
 * @interface RecentTradesUpdates
 */
export interface RecentTradesUpdates {
    /**
     * 
     * @type {Array<Trade>}
     * @memberof RecentTradesUpdates
     */
    'trades': Array<Trade>;
}
/**
 * 
 * @export
 * @interface RefereeOnboardResponse
 */
export interface RefereeOnboardResponse {
    /**
     * Response message indicating if the referral code exists
     * @type {string}
     * @memberof RefereeOnboardResponse
     */
    'message': string;
}
/**
 * 
 * @export
 * @interface RefreshTokenRequest
 */
export interface RefreshTokenRequest {
    /**
     * 
     * @type {string}
     * @memberof RefreshTokenRequest
     */
    'refreshToken': string;
}
/**
 * 
 * @export
 * @interface RefreshTokenResponse
 */
export interface RefreshTokenResponse {
    /**
     * 
     * @type {string}
     * @memberof RefreshTokenResponse
     */
    'accessToken': string;
    /**
     * 
     * @type {number}
     * @memberof RefreshTokenResponse
     */
    'accessTokenValidForSeconds': number;
    /**
     * 
     * @type {string}
     * @memberof RefreshTokenResponse
     */
    'refreshToken': string;
    /**
     * 
     * @type {number}
     * @memberof RefreshTokenResponse
     */
    'refreshTokenValidForSeconds': number;
}
/**
 * 
 * @export
 * @interface RewardsSummary
 */
export interface RewardsSummary {
    /**
     * User address for the rewards earned data.
     * @type {string}
     * @memberof RewardsSummary
     */
    'UserAddress': string;
    /**
     * Total Blue token rewards earned by the user (e9 format).
     * @type {string}
     * @memberof RewardsSummary
     */
    'BlueRewardsE9': string;
    /**
     * Total Sui token rewards earned by the user (e9 format).
     * @type {string}
     * @memberof RewardsSummary
     */
    'SuiRewardsE9': string;
    /**
     * Total wal rewards earned by the user (e9 format).
     * @type {string}
     * @memberof RewardsSummary
     */
    'WalRewardsE9': string;
}
/**
 * The strategy used to resolve self trades.   TAKER: On a self trade, the taker order will be cancelled  MAKER: On a self trade, the maker order will be cancelled  BOTH: On a self trade, both the taker and the maker order will be cancelled  UNSPECIFIED: set to default value 
 * @export
 * @enum {string}
 */

export const SelfTradePreventionType = {
    Taker: 'TAKER',
    Maker: 'MAKER',
    Both: 'BOTH',
    Unspecified: 'UNSPECIFIED'
} as const;

export type SelfTradePreventionType = typeof SelfTradePreventionType[keyof typeof SelfTradePreventionType];


/**
 * 
 * @export
 * @interface SponsorTxRequest
 */
export interface SponsorTxRequest {
    /**
     * Base64 encoded transaction bytes to be sponsored.  To create txBytes: 1. Create a TransactionBlock with move calls (e.g., deposit_to_asset_bank) 2. Serialize the TransactionBlock to bytes using BCS (Binary Canonical Serialization) 3. Encode the bytes to base64 string Reference implementation: https://github.com/fireflyprotocol/library-sui/blob/1412fff4d4fe7cf6b7ec04d700e777628c57c70a/src/classes/SuiBlocks.ts#L220 
     * @type {string}
     * @memberof SponsorTxRequest
     */
    'txBytes': string;
}
/**
 * 
 * @export
 * @interface SponsorTxResponse
 */
export interface SponsorTxResponse {
    /**
     * Base64 encoded sponsored transaction bytes
     * @type {string}
     * @memberof SponsorTxResponse
     */
    'txBytes': string;
    /**
     * Transaction digest
     * @type {string}
     * @memberof SponsorTxResponse
     */
    'txDigest': string;
    /**
     * Transaction signature
     * @type {string}
     * @memberof SponsorTxResponse
     */
    'signature': string;
    /**
     * Transaction expiration time in milliseconds since Unix epoch
     * @type {number}
     * @memberof SponsorTxResponse
     */
    'expireAtTime': number;
}
/**
 * 
 * @export
 * @interface StatsAllTimeResponse
 */
export interface StatsAllTimeResponse {
    /**
     * Timestamp in milliseconds when the statistics period starts.
     * @type {number}
     * @memberof StatsAllTimeResponse
     */
    'startTimeAtMillis': number;
    /**
     * Total value locked in the legacy exchange in e9 format.
     * @type {string}
     * @memberof StatsAllTimeResponse
     */
    'legacyTvlE9': string;
    /**
     * Total value locked in the exchange in e9 format.
     * @type {string}
     * @memberof StatsAllTimeResponse
     */
    'tvlE9': string;
    /**
     * Total quote asset volume in the legacy exchange in e9 format.
     * @type {string}
     * @memberof StatsAllTimeResponse
     */
    'totalLegacyQuoteAssetVolumeE9': string;
    /**
     * Total quote asset volume in the exchange in e9 format.
     * @type {string}
     * @memberof StatsAllTimeResponse
     */
    'totalQuoteAssetVolumeE9': string;
    /**
     * Timestamp in milliseconds when the statistics period ends.
     * @type {number}
     * @memberof StatsAllTimeResponse
     */
    'endTimeAtMillis': number;
}
/**
 * 
 * @export
 * @interface StatsEntry
 */
export interface StatsEntry {
    /**
     * Timestamp in milliseconds when the statistics period starts.
     * @type {number}
     * @memberof StatsEntry
     */
    'startTimeAtMillis': number;
    /**
     * Total value locked in the legacy exchange in e9 format.
     * @type {string}
     * @memberof StatsEntry
     */
    'legacyTvlE9': string;
    /**
     * Total value locked in the exchange in e9 format.
     * @type {string}
     * @memberof StatsEntry
     */
    'tvlE9': string;
    /**
     * Total quote asset volume in the legacy exchange in e9 format.
     * @type {string}
     * @memberof StatsEntry
     */
    'totalLegacyQuoteAssetVolumeE9': string;
    /**
     * Total quote asset volume in the exchange in e9 format.
     * @type {string}
     * @memberof StatsEntry
     */
    'totalQuoteAssetVolumeE9': string;
    /**
     * Timestamp in milliseconds when the statistics period ends.
     * @type {number}
     * @memberof StatsEntry
     */
    'endTimeAtMillis': number;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const StatsInterval = {
    _1d: '1d',
    _1w: '1w',
    _1Mo: '1Mo',
    Unspecified: 'UNSPECIFIED'
} as const;

export type StatsInterval = typeof StatsInterval[keyof typeof StatsInterval];


/**
 * 
 * @export
 * @interface StatsResponse
 */
export interface StatsResponse {
    /**
     * 
     * @type {Array<StatsEntry>}
     * @memberof StatsResponse
     */
    'data': Array<StatsEntry>;
}
/**
 * Response message indicating the success or failure of a subscription operation.
 * @export
 * @interface SubscriptionResponseMessage
 */
export interface SubscriptionResponseMessage {
    /**
     * Indicates if the subscription operation was successful.
     * @type {boolean}
     * @memberof SubscriptionResponseMessage
     */
    'success': boolean;
    /**
     * Additional information about the subscription operation.
     * @type {string}
     * @memberof SubscriptionResponseMessage
     */
    'message': string;
}
/**
 * Indicates the type of subscription action.
 * @export
 * @enum {string}
 */

export const SubscriptionType = {
    Subscribe: 'Subscribe',
    Unsubscribe: 'Unsubscribe'
} as const;

export type SubscriptionType = typeof SubscriptionType[keyof typeof SubscriptionType];


/**
 * 
 * @export
 * @interface TickerAllUpdate
 */
export interface TickerAllUpdate {
    /**
     * Array of detailed market ticker information for all markets.
     * @type {Array<TickerUpdate>}
     * @memberof TickerAllUpdate
     */
    'tickerAll': Array<TickerUpdate>;
}
/**
 * 
 * @export
 * @interface TickerResponse
 */
export interface TickerResponse {
    /**
     * Market symbol.
     * @type {string}
     * @memberof TickerResponse
     */
    'symbol': string;
    /**
     * Last trade quantity (e9 format).
     * @type {string}
     * @memberof TickerResponse
     */
    'lastQuantityE9': string;
    /**
     * Last trade time in milliseconds.
     * @type {number}
     * @memberof TickerResponse
     */
    'lastTimeAtMillis': number;
    /**
     * Last trade price (e9 format).
     * @type {string}
     * @memberof TickerResponse
     */
    'lastPriceE9': string;
    /**
     * Funding rate value (e9 format).
     * @type {string}
     * @memberof TickerResponse
     */
    'lastFundingRateE9': string;
    /**
     * Time in milliseconds of next funding rate update.
     * @type {number}
     * @memberof TickerResponse
     */
    'nextFundingTimeAtMillis': number;
    /**
     * 8 hr average funding rate (e9 format).
     * @type {string}
     * @memberof TickerResponse
     */
    'avgFundingRate8hrE9': string;
    /**
     * Oracle price of the asset (e9 format).
     * @type {string}
     * @memberof TickerResponse
     */
    'oraclePriceE9': string;
    /**
     * Direction of oracle price computed by comparing current oracle price to last oracle price. 0 = no change, -1 = negative trend (current < last), 1 positive trend (current > last).
     * @type {number}
     * @memberof TickerResponse
     */
    'oraclePriceDirection': number;
    /**
     * Mark price on the exchange (e9 format).
     * @type {string}
     * @memberof TickerResponse
     */
    'markPriceE9': string;
    /**
     * Direction of mark price computed by comparing current mark price to last mark price. 0 = no change, -1 = negative trend (current < last), 1 positive trend (current > last).
     * @type {number}
     * @memberof TickerResponse
     */
    'markPriceDirection': number;
    /**
     * Simple average of bestBid and bestAsk. lastPrice if either is not present (e9 format).
     * @type {string}
     * @memberof TickerResponse
     */
    'marketPriceE9': string;
    /**
     * Direction of market price computed by comparing current market price to last market price. 0 = no change, -1 = negative trend (current < last), 1 positive trend (current > last).
     * @type {number}
     * @memberof TickerResponse
     */
    'marketPriceDirection': number;
    /**
     * Best bid price (e9 format).
     * @type {string}
     * @memberof TickerResponse
     */
    'bestBidPriceE9': string;
    /**
     * Best bid quantity (e9 format).
     * @type {string}
     * @memberof TickerResponse
     */
    'bestBidQuantityE9': string;
    /**
     * Best ask price (e9 format).
     * @type {string}
     * @memberof TickerResponse
     */
    'bestAskPriceE9': string;
    /**
     * Best ask quantity (e9 format).
     * @type {string}
     * @memberof TickerResponse
     */
    'bestAskQuantityE9': string;
    /**
     * Open interest value (e9 format).
     * @type {string}
     * @memberof TickerResponse
     */
    'openInterestE9': string;
    /**
     * Highest Price in the last 24hrs (e9 format).
     * @type {string}
     * @memberof TickerResponse
     */
    'highPrice24hrE9': string;
    /**
     * Lowest Price in the last 24hrs (e9 format).
     * @type {string}
     * @memberof TickerResponse
     */
    'lowPrice24hrE9': string;
    /**
     * Total market volume in last 24hrs of asset (e9 format).
     * @type {string}
     * @memberof TickerResponse
     */
    'volume24hrE9': string;
    /**
     * Total market volume in last 24hrs in USDC (e9 format).
     * @type {string}
     * @memberof TickerResponse
     */
    'quoteVolume24hrE9': string;
    /**
     * Close price 24hrs ago (e9 format).
     * @type {string}
     * @memberof TickerResponse
     */
    'closePrice24hrE9': string;
    /**
     * Open price in the last 24hrs (e9 format).
     * @type {string}
     * @memberof TickerResponse
     */
    'openPrice24hrE9': string;
    /**
     * 24 hour close time in milliseconds.
     * @type {number}
     * @memberof TickerResponse
     */
    'closeTime24hrAtMillis': number;
    /**
     * 24 hour open time in milliseconds.
     * @type {number}
     * @memberof TickerResponse
     */
    'openTime24hrAtMillis': number;
    /**
     * First trade id in 24hr.
     * @type {number}
     * @memberof TickerResponse
     */
    'firstId24hr': number;
    /**
     * Last trade id in 24hr.
     * @type {number}
     * @memberof TickerResponse
     */
    'lastId24hr': number;
    /**
     * Total number of trades in 24hr.
     * @type {string}
     * @memberof TickerResponse
     */
    'count24hr': string;
    /**
     * 24hr Market price change (e9 format).
     * @type {string}
     * @memberof TickerResponse
     */
    'priceChange24hrE9': string;
    /**
     * 24hr Market price change in percentage (e9 format).
     * @type {string}
     * @memberof TickerResponse
     */
    'priceChangePercent24hrE9': string;
    /**
     * Last update time in milliseconds.
     * @type {number}
     * @memberof TickerResponse
     */
    'updatedAtMillis': number;
}
/**
 * Represents detailed market ticker information.
 * @export
 * @interface TickerUpdate
 */
export interface TickerUpdate {
    /**
     * Market symbol.
     * @type {string}
     * @memberof TickerUpdate
     */
    'symbol': string;
    /**
     * Last trade quantity (e9 format).
     * @type {string}
     * @memberof TickerUpdate
     */
    'lastQuantityE9': string;
    /**
     * Last trade time in milliseconds.
     * @type {number}
     * @memberof TickerUpdate
     */
    'lastTimeAtMillis': number;
    /**
     * Last trade price (e9 format).
     * @type {string}
     * @memberof TickerUpdate
     */
    'lastPriceE9': string;
    /**
     * Funding rate value (e9 format).
     * @type {string}
     * @memberof TickerUpdate
     */
    'lastFundingRateE9': string;
    /**
     * Time in milliseconds of next funding rate update.
     * @type {number}
     * @memberof TickerUpdate
     */
    'nextFundingTimeAtMillis': number;
    /**
     * 8 hr average funding rate (e9 format).
     * @type {string}
     * @memberof TickerUpdate
     */
    'avgFundingRate8hrE9': string;
    /**
     * Oracle price of the asset (e9 format).
     * @type {string}
     * @memberof TickerUpdate
     */
    'oraclePriceE9': string;
    /**
     * Direction of oracle price computed by comparing current oracle price to last oracle price. 0 = no change, -1 = negative trend (current < last), 1 = positive trend (current > last).
     * @type {number}
     * @memberof TickerUpdate
     */
    'oraclePriceDirection': number;
    /**
     * Mark price on the exchange (e9 format).
     * @type {string}
     * @memberof TickerUpdate
     */
    'markPriceE9': string;
    /**
     * Direction of mark price computed by comparing current mark price to last mark price. 0 = no change, -1 = negative trend (current < last), 1 = positive trend (current > last).
     * @type {number}
     * @memberof TickerUpdate
     */
    'markPriceDirection': number;
    /**
     * Simple average of bestBid and bestAsk, or lastPrice if either is not present (e9 format).
     * @type {string}
     * @memberof TickerUpdate
     */
    'marketPriceE9': string;
    /**
     * Direction of market price computed by comparing current market price to last market price. 0 = no change, -1 = negative trend (current < last), 1 = positive trend (current > last).
     * @type {number}
     * @memberof TickerUpdate
     */
    'marketPriceDirection': number;
    /**
     * Best bid price (e9 format).
     * @type {string}
     * @memberof TickerUpdate
     */
    'bestBidPriceE9': string;
    /**
     * Best bid quantity (e9 format).
     * @type {string}
     * @memberof TickerUpdate
     */
    'bestBidQuantityE9': string;
    /**
     * Best ask price (e9 format).
     * @type {string}
     * @memberof TickerUpdate
     */
    'bestAskPriceE9': string;
    /**
     * Best ask quantity (e9 format).
     * @type {string}
     * @memberof TickerUpdate
     */
    'bestAskQuantityE9': string;
    /**
     * Open interest value (e9 format).
     * @type {string}
     * @memberof TickerUpdate
     */
    'openInterestE9': string;
    /**
     * Highest Price in the last 24 hours (e9 format).
     * @type {string}
     * @memberof TickerUpdate
     */
    'highPrice24hrE9': string;
    /**
     * Lowest Price in the last 24 hours (e9 format).
     * @type {string}
     * @memberof TickerUpdate
     */
    'lowPrice24hrE9': string;
    /**
     * Total market volume in last 24 hours of asset (e9 format).
     * @type {string}
     * @memberof TickerUpdate
     */
    'volume24hrE9': string;
    /**
     * Total market volume in last 24 hours in USDC (e9 format).
     * @type {string}
     * @memberof TickerUpdate
     */
    'quoteVolume24hrE9': string;
    /**
     * Close price 24 hours ago (e9 format).
     * @type {string}
     * @memberof TickerUpdate
     */
    'closePrice24hrE9': string;
    /**
     * Open price in the last 24 hours (e9 format).
     * @type {string}
     * @memberof TickerUpdate
     */
    'openPrice24hrE9': string;
    /**
     * 24 hour close timestamp in milliseconds.
     * @type {number}
     * @memberof TickerUpdate
     */
    'closeTime24hrAtMillis': number;
    /**
     * 24 hour open timetamp in milliseconds.
     * @type {number}
     * @memberof TickerUpdate
     */
    'openTime24hrAtMillis': number;
    /**
     * First trade ID in the last 24 hours.
     * @type {number}
     * @memberof TickerUpdate
     */
    'firstId24hr': number;
    /**
     * Last trade ID in the last 24 hours.
     * @type {number}
     * @memberof TickerUpdate
     */
    'lastId24hr': number;
    /**
     * Total number of trades in the last 24 hours.
     * @type {string}
     * @memberof TickerUpdate
     */
    'count24hr': string;
    /**
     * 24 hour Market price change (e9 format).
     * @type {string}
     * @memberof TickerUpdate
     */
    'priceChange24hrE9': string;
    /**
     * 24 hour Market price change as a percentage (e9 format).
     * @type {string}
     * @memberof TickerUpdate
     */
    'priceChangePercent24hrE9': string;
    /**
     * Last update timestamp in milliseconds.
     * @type {number}
     * @memberof TickerUpdate
     */
    'updatedAtMillis': number;
}
/**
 * 
 * @export
 * @interface Trade
 */
export interface Trade {
    /**
     * Trade ID
     * @type {string}
     * @memberof Trade
     */
    'id': string;
    /**
     * Client order ID.
     * @type {string}
     * @memberof Trade
     */
    'clientOrderId'?: string;
    /**
     * Market address.
     * @type {string}
     * @memberof Trade
     */
    'symbol'?: string;
    /**
     * Order hash.
     * @type {string}
     * @memberof Trade
     */
    'orderHash'?: string;
    /**
     * 
     * @type {OrderType}
     * @memberof Trade
     */
    'orderType'?: OrderType;
    /**
     * 
     * @type {TradeType}
     * @memberof Trade
     */
    'tradeType'?: TradeType;
    /**
     * 
     * @type {TradeSide}
     * @memberof Trade
     */
    'side': TradeSide;
    /**
     * Indicates if the user was a maker to the trade.
     * @type {boolean}
     * @memberof Trade
     */
    'isMaker'?: boolean;
    /**
     * Trade price (e9 format).
     * @type {string}
     * @memberof Trade
     */
    'priceE9': string;
    /**
     * Trade quantity (e9 format).
     * @type {string}
     * @memberof Trade
     */
    'quantityE9': string;
    /**
     * Quote quantity (e9 format).
     * @type {string}
     * @memberof Trade
     */
    'quoteQuantityE9': string;
    /**
     * Realized profit and loss (e9 format).
     * @type {string}
     * @memberof Trade
     */
    'realizedPnlE9'?: string;
    /**
     * 
     * @type {PositionSide}
     * @memberof Trade
     */
    'positionSide'?: PositionSide;
    /**
     * Trading fee (e9 format).
     * @type {string}
     * @memberof Trade
     */
    'tradingFeeE9'?: string;
    /**
     * Asset used for trading fee.
     * @type {string}
     * @memberof Trade
     */
    'tradingFeeAsset'?: string;
    /**
     * Gas fee.
     * @type {string}
     * @memberof Trade
     */
    'gasFeeE9'?: string;
    /**
     * Asset used for gas fee.
     * @type {string}
     * @memberof Trade
     */
    'gasFeeAsset'?: string;
    /**
     * Trade timestamp in milliseconds since Unix epoch.
     * @type {number}
     * @memberof Trade
     */
    'executedAtMillis': number;
}


/**
 * Trade side based on the user order in this trade.
 * @export
 * @enum {string}
 */

export const TradeSide = {
    Long: 'LONG',
    Short: 'SHORT',
    Unspecified: 'UNSPECIFIED'
} as const;

export type TradeSide = typeof TradeSide[keyof typeof TradeSide];


/**
 * Type of trade.
 * @export
 * @enum {string}
 */

export const TradeType = {
    Order: 'ORDER',
    Liquidation: 'LIQUIDATION',
    Deleverage: 'DELEVERAGE',
    Unspecified: 'UNSPECIFIED'
} as const;

export type TradeType = typeof TradeType[keyof typeof TradeType];


/**
 * 
 * @export
 * @interface TradingFees
 */
export interface TradingFees {
    /**
     * The Account Maker Fee (e9 format).
     * @type {string}
     * @memberof TradingFees
     */
    'makerFeeE9': string;
    /**
     * The Account Taker Fee (e9 format).
     * @type {string}
     * @memberof TradingFees
     */
    'takerFeeE9': string;
    /**
     * Are the fees applied on the account?
     * @type {boolean}
     * @memberof TradingFees
     */
    'isApplied': boolean;
}
/**
 * 
 * @export
 * @interface Transaction
 */
export interface Transaction {
    /**
     * Transaction ID.
     * @type {string}
     * @memberof Transaction
     */
    'id': string;
    /**
     * Market address.
     * @type {string}
     * @memberof Transaction
     */
    'symbol'?: string;
    /**
     * 
     * @type {TransactionType}
     * @memberof Transaction
     */
    'type': TransactionType;
    /**
     * Amount in e9 format (positive or negative).
     * @type {string}
     * @memberof Transaction
     */
    'amountE9': string;
    /**
     * Transaction status (SUCCESS, REJECTED).
     * @type {string}
     * @memberof Transaction
     */
    'status'?: string;
    /**
     * Asset bank address.
     * @type {string}
     * @memberof Transaction
     */
    'assetSymbol': string;
    /**
     * Trade ID
     * @type {string}
     * @memberof Transaction
     */
    'tradeId'?: string;
    /**
     * Transaction timestamp in milliseconds since Unix epoch.
     * @type {number}
     * @memberof Transaction
     */
    'executedAtMillis': number;
}


/**
 * Transaction type (what caused the change in the asset balance).
 * @export
 * @enum {string}
 */

export const TransactionType = {
    Transfer: 'TRANSFER',
    Deposit: 'DEPOSIT',
    Withdraw: 'WITHDRAW',
    RealizedPnl: 'REALIZED_PNL',
    FundingFee: 'FUNDING_FEE',
    TradingFee: 'TRADING_FEE',
    TradingGasFee: 'TRADING_GAS_FEE',
    Bonus: 'BONUS',
    Unspecified: 'UNSPECIFIED'
} as const;

export type TransactionType = typeof TransactionType[keyof typeof TransactionType];


/**
 * 
 * @export
 * @interface UpdateAccountPreferenceRequest
 */
export interface UpdateAccountPreferenceRequest {
    [key: string]: any;

    /**
     * User preferred language.
     * @type {string}
     * @memberof UpdateAccountPreferenceRequest
     */
    'language'?: string;
    /**
     * User preferred theme.
     * @type {string}
     * @memberof UpdateAccountPreferenceRequest
     */
    'theme'?: string;
    /**
     * 
     * @type {Array<AccountMarketPreference>}
     * @memberof UpdateAccountPreferenceRequest
     */
    'market'?: Array<AccountMarketPreference>;
}
/**
 * 
 * @export
 * @interface UpdateAffiliateEmberRefferalShareRequest
 */
export interface UpdateAffiliateEmberRefferalShareRequest {
    /**
     * Ember refferal share for an affiliate.
     * @type {number}
     * @memberof UpdateAffiliateEmberRefferalShareRequest
     */
    'emberRefferalShare': number;
}
/**
 * 
 * @export
 * @interface UpdateAffiliateFeeConfigRequest
 */
export interface UpdateAffiliateFeeConfigRequest {
    /**
     * Cashback amount to give to the referees
     * @type {number}
     * @memberof UpdateAffiliateFeeConfigRequest
     */
    'cashback': number;
}
/**
 * 
 * @export
 * @interface UserCampaignRewards
 */
export interface UserCampaignRewards {
    /**
     * User address for the rewards earned data.
     * @type {string}
     * @memberof UserCampaignRewards
     */
    'userAddress': string;
    /**
     * Name of the campaign.
     * @type {string}
     * @memberof UserCampaignRewards
     */
    'campaignName': string;
    /**
     * Epoch number for the rewards earned data.
     * @type {number}
     * @memberof UserCampaignRewards
     */
    'epochNumber': number;
    /**
     * Interval number for the rewards earned data.
     * @type {number}
     * @memberof UserCampaignRewards
     */
    'intervalNumber': number;
    /**
     * Market Symbol.
     * @type {string}
     * @memberof UserCampaignRewards
     */
    'symbol': string;
    /**
     * 
     * @type {string}
     * @memberof UserCampaignRewards
     */
    'status': UserCampaignRewardsStatusEnum;
    /**
     * Total blue-perp token rewards earned in the epoch (e9 format).
     * @type {string}
     * @memberof UserCampaignRewards
     */
    'blueRewardsE9': string;
    /**
     * Total sui-perp token rewards earned in the epoch (e9 format).
     * @type {string}
     * @memberof UserCampaignRewards
     */
    'suiRewardsE9': string;
    /**
     * Total wal-perp rewards earned in the epoch (e9 format).
     * @type {string}
     * @memberof UserCampaignRewards
     */
    'walRewardsE9': string;
    /**
     * Total cash rewards earned in the epoch (e9 format).
     * @type {string}
     * @memberof UserCampaignRewards
     */
    'cashRewardsE9': string;
    /**
     * Total user fee paid in the epoch (e9 format).
     * @type {string}
     * @memberof UserCampaignRewards
     */
    'userFeePaidE9': string;
    /**
     * Time in seconds for interval start date.
     * @type {number}
     * @memberof UserCampaignRewards
     */
    'intervalStartDate': number;
    /**
     * Time in seconds for interval end date.
     * @type {number}
     * @memberof UserCampaignRewards
     */
    'intervalEndDate': number;
    /**
     * Indicates if the rewards have been disbursed.
     * @type {boolean}
     * @memberof UserCampaignRewards
     */
    'isDisbursed': boolean;
    /**
     * Transaction digest of the disbursement.
     * @type {string}
     * @memberof UserCampaignRewards
     */
    'txnDigest': string;
}

export const UserCampaignRewardsStatusEnum = {
    Active: 'ACTIVE',
    NotStarted: 'NOT_STARTED',
    Finalized: 'FINALIZED',
    Cooldown: 'COOLDOWN'
} as const;

export type UserCampaignRewardsStatusEnum = typeof UserCampaignRewardsStatusEnum[keyof typeof UserCampaignRewardsStatusEnum];

/**
 * 
 * @export
 * @interface WithdrawRequest
 */
export interface WithdrawRequest {
    /**
     * 
     * @type {WithdrawRequestSignedFields}
     * @memberof WithdrawRequest
     */
    'signedFields': WithdrawRequestSignedFields;
    /**
     * The signature of the request, encoded from the signedFields
     * @type {string}
     * @memberof WithdrawRequest
     */
    'signature': string;
}
/**
 * 
 * @export
 * @interface WithdrawRequestSignedFields
 */
export interface WithdrawRequestSignedFields {
    /**
     * Asset symbol of the withdrawn asset
     * @type {string}
     * @memberof WithdrawRequestSignedFields
     */
    'assetSymbol': string;
    /**
     * The Account Address from which to withdraw assets
     * @type {string}
     * @memberof WithdrawRequestSignedFields
     */
    'accountAddress': string;
    /**
     * The amount in e9 of the asset that the User will withdraw from their account
     * @type {string}
     * @memberof WithdrawRequestSignedFields
     */
    'amountE9': string;
    /**
     * A uniqueness modifier for the request. This is added to guarantee uniqueness of the request. Usually a mix of timestamp and a random number
     * @type {string}
     * @memberof WithdrawRequestSignedFields
     */
    'salt': string;
    /**
     * the ID of the external datastore for the target network
     * @type {string}
     * @memberof WithdrawRequestSignedFields
     */
    'edsId': string;
    /**
     * The timestamp in milliseconds when the HTTP Request payload has been signed
     * @type {number}
     * @memberof WithdrawRequestSignedFields
     */
    'signedAtMillis': number;
}
/**
 * 
 * @export
 * @interface ZKLoginUserDetailsResponse
 */
export interface ZKLoginUserDetailsResponse {
    /**
     * The zkLogin user salt.
     * @type {string}
     * @memberof ZKLoginUserDetailsResponse
     */
    'salt': string;
    /**
     * The zkLogin user\'s address.
     * @type {string}
     * @memberof ZKLoginUserDetailsResponse
     */
    'address': string;
    /**
     * The zkLogin user\'s public key.
     * @type {string}
     * @memberof ZKLoginUserDetailsResponse
     */
    'publicKey': string;
}
/**
 * 
 * @export
 * @interface ZKLoginZKPRequest
 */
export interface ZKLoginZKPRequest {
    /**
     * The network to use (e.g., \"mainnet\", \"testnet\").
     * @type {string}
     * @memberof ZKLoginZKPRequest
     */
    'network'?: string;
    /**
     * The ephemeral public key for the ZK proof.
     * @type {string}
     * @memberof ZKLoginZKPRequest
     */
    'ephemeralPublicKey': string;
    /**
     * The maximum epoch for the ZK proof.
     * @type {number}
     * @memberof ZKLoginZKPRequest
     */
    'maxEpoch': number;
    /**
     * Randomness value for the ZK proof.
     * @type {string}
     * @memberof ZKLoginZKPRequest
     */
    'randomness': string;
}
/**
 * 
 * @export
 * @interface ZKLoginZKPResponse
 */
export interface ZKLoginZKPResponse {
    /**
     * 
     * @type {ProofPoints}
     * @memberof ZKLoginZKPResponse
     */
    'proofPoints'?: ProofPoints;
    /**
     * 
     * @type {IssBase64Details}
     * @memberof ZKLoginZKPResponse
     */
    'issBase64Details'?: IssBase64Details;
    /**
     * Base64 encoded header information.
     * @type {string}
     * @memberof ZKLoginZKPResponse
     */
    'headerBase64'?: string;
    /**
     * The address seed used in the proof.
     * @type {string}
     * @memberof ZKLoginZKPResponse
     */
    'addressSeed': string;
}

/**
 * AccountDataApi - axios parameter creator
 * @export
 */
export const AccountDataApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves the user\'s account details.
         * @summary /account
         * @param {string} [accountAddress] Account address to fetch account details by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountDetails: async (accountAddress?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/account`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (accountAddress !== undefined) {
                localVarQueryParameter['accountAddress'] = accountAddress;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the funding rate history for a specific account.
         * @summary /account/fundingRateHistory
         * @param {string} [accountAddress] Account address to filter funding rate history by.
         * @param {number} [limit] Default 500; max 1000.
         * @param {number} [page] The page number to retrieve in a paginated response.
         * @param {number} [startTimeAtMillis] Start time in milliseconds. Defaults to 7 days ago if not specified.
         * @param {number} [endTimeAtMillis] End time in milliseconds. Defaults to now if not specified. Must be greater than start time and must be less than 90 days apart.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountFundingRateHistory: async (accountAddress?: string, limit?: number, page?: number, startTimeAtMillis?: number, endTimeAtMillis?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/account/fundingRateHistory`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (accountAddress !== undefined) {
                localVarQueryParameter['accountAddress'] = accountAddress;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (startTimeAtMillis !== undefined) {
                localVarQueryParameter['startTimeAtMillis'] = startTimeAtMillis;
            }

            if (endTimeAtMillis !== undefined) {
                localVarQueryParameter['endTimeAtMillis'] = endTimeAtMillis;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the user\'s account preferences.
         * @summary /account/preferences
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountPreferences: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/account/preferences`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the user\'s trade history.
         * @summary /account/trades
         * @param {string} [symbol] Market address to filter trades by. If not specified, returns trades for all markets.
         * @param {number} [startTimeAtMillis] Start time in milliseconds. Defaults to 7 days ago if not specified.
         * @param {number} [endTimeAtMillis] End time in milliseconds. Defaults to now if not specified. Must be greater than start time and must be less than 90 days apart.
         * @param {number} [limit] Default 500; max 1000.
         * @param {TradeType} [tradeType] Type of trade. By default returns all. UNSPECIFIED returns all.
         * @param {number} [page] The page number to retrieve in a paginated response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountTrades: async (symbol?: string, startTimeAtMillis?: number, endTimeAtMillis?: number, limit?: number, tradeType?: TradeType, page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/account/trades`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (startTimeAtMillis !== undefined) {
                localVarQueryParameter['startTimeAtMillis'] = startTimeAtMillis;
            }

            if (endTimeAtMillis !== undefined) {
                localVarQueryParameter['endTimeAtMillis'] = endTimeAtMillis;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (tradeType !== undefined) {
                localVarQueryParameter['tradeType'] = tradeType;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves the user\'s transaction history (any change in balance).
         * @summary /account/transactions
         * @param {Array<TransactionType>} [types] Optional query parameter to filter transactions by type.
         * @param {string} [assetSymbol] Optional query parameter to filter transactions by asset bank address.
         * @param {number} [startTimeAtMillis] Start time in milliseconds. Defaults to 7 days ago if not specified.
         * @param {number} [endTimeAtMillis] End time in milliseconds. Defaults to now if not specified. Must be greater than start time and must be less than 90 days apart.
         * @param {number} [limit] Default 500; max 1000.
         * @param {number} [page] The page number to retrieve in a paginated response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountTransactionHistory: async (types?: Array<TransactionType>, assetSymbol?: string, startTimeAtMillis?: number, endTimeAtMillis?: number, limit?: number, page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/account/transactions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (types) {
                localVarQueryParameter['types'] = types;
            }

            if (assetSymbol !== undefined) {
                localVarQueryParameter['assetSymbol'] = assetSymbol;
            }

            if (startTimeAtMillis !== undefined) {
                localVarQueryParameter['startTimeAtMillis'] = startTimeAtMillis;
            }

            if (endTimeAtMillis !== undefined) {
                localVarQueryParameter['endTimeAtMillis'] = endTimeAtMillis;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sets or updates the group ID for a specific account. Accounts belonging to the same group cannot trade against each other. If the groupId is not set, the account will be removed from its group. Only the first 6 characters of the groupID are guaranteed to be respected, longer group IDs may be rejected. 
         * @summary Set the group ID for an account.
         * @param {AccountGroupIdPatch} accountGroupIdPatch Account group ID update.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchAccountGroupID: async (accountGroupIdPatch: AccountGroupIdPatch, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountGroupIdPatch' is not null or undefined
            assertParamExists('patchAccountGroupID', 'accountGroupIdPatch', accountGroupIdPatch)
            const localVarPath = `/api/v1/account/groupId`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accountGroupIdPatch, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update user\'s account preferences. This will overwrite the preferences, so always send the full object.
         * @summary /account/preferences
         * @param {UpdateAccountPreferenceRequest} updateAccountPreferenceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putAccountPreferences: async (updateAccountPreferenceRequest: UpdateAccountPreferenceRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateAccountPreferenceRequest' is not null or undefined
            assertParamExists('putAccountPreferences', 'updateAccountPreferenceRequest', updateAccountPreferenceRequest)
            const localVarPath = `/api/v1/account/preferences`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateAccountPreferenceRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Sponsors a transaction if it\'s eligible for sponsorship based on allowlisted methods and kinds.
         * @summary /account/sponsorTx
         * @param {SponsorTxRequest} sponsorTxRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sponsorTx: async (sponsorTxRequest: SponsorTxRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sponsorTxRequest' is not null or undefined
            assertParamExists('sponsorTx', 'sponsorTxRequest', sponsorTxRequest)
            const localVarPath = `/api/v1/account/sponsorTx`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sponsorTxRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountDataApi - functional programming interface
 * @export
 */
export const AccountDataApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AccountDataApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves the user\'s account details.
         * @summary /account
         * @param {string} [accountAddress] Account address to fetch account details by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountDetails(accountAddress?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Account>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountDetails(accountAddress, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountDataApi.getAccountDetails']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves the funding rate history for a specific account.
         * @summary /account/fundingRateHistory
         * @param {string} [accountAddress] Account address to filter funding rate history by.
         * @param {number} [limit] Default 500; max 1000.
         * @param {number} [page] The page number to retrieve in a paginated response.
         * @param {number} [startTimeAtMillis] Start time in milliseconds. Defaults to 7 days ago if not specified.
         * @param {number} [endTimeAtMillis] End time in milliseconds. Defaults to now if not specified. Must be greater than start time and must be less than 90 days apart.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountFundingRateHistory(accountAddress?: string, limit?: number, page?: number, startTimeAtMillis?: number, endTimeAtMillis?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountFundingRateHistory>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountFundingRateHistory(accountAddress, limit, page, startTimeAtMillis, endTimeAtMillis, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountDataApi.getAccountFundingRateHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves the user\'s account preferences.
         * @summary /account/preferences
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountPreferences(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccountPreference>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountPreferences(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountDataApi.getAccountPreferences']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves the user\'s trade history.
         * @summary /account/trades
         * @param {string} [symbol] Market address to filter trades by. If not specified, returns trades for all markets.
         * @param {number} [startTimeAtMillis] Start time in milliseconds. Defaults to 7 days ago if not specified.
         * @param {number} [endTimeAtMillis] End time in milliseconds. Defaults to now if not specified. Must be greater than start time and must be less than 90 days apart.
         * @param {number} [limit] Default 500; max 1000.
         * @param {TradeType} [tradeType] Type of trade. By default returns all. UNSPECIFIED returns all.
         * @param {number} [page] The page number to retrieve in a paginated response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountTrades(symbol?: string, startTimeAtMillis?: number, endTimeAtMillis?: number, limit?: number, tradeType?: TradeType, page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Trade>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountTrades(symbol, startTimeAtMillis, endTimeAtMillis, limit, tradeType, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountDataApi.getAccountTrades']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves the user\'s transaction history (any change in balance).
         * @summary /account/transactions
         * @param {Array<TransactionType>} [types] Optional query parameter to filter transactions by type.
         * @param {string} [assetSymbol] Optional query parameter to filter transactions by asset bank address.
         * @param {number} [startTimeAtMillis] Start time in milliseconds. Defaults to 7 days ago if not specified.
         * @param {number} [endTimeAtMillis] End time in milliseconds. Defaults to now if not specified. Must be greater than start time and must be less than 90 days apart.
         * @param {number} [limit] Default 500; max 1000.
         * @param {number} [page] The page number to retrieve in a paginated response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccountTransactionHistory(types?: Array<TransactionType>, assetSymbol?: string, startTimeAtMillis?: number, endTimeAtMillis?: number, limit?: number, page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Transaction>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccountTransactionHistory(types, assetSymbol, startTimeAtMillis, endTimeAtMillis, limit, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountDataApi.getAccountTransactionHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Sets or updates the group ID for a specific account. Accounts belonging to the same group cannot trade against each other. If the groupId is not set, the account will be removed from its group. Only the first 6 characters of the groupID are guaranteed to be respected, longer group IDs may be rejected. 
         * @summary Set the group ID for an account.
         * @param {AccountGroupIdPatch} accountGroupIdPatch Account group ID update.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async patchAccountGroupID(accountGroupIdPatch: AccountGroupIdPatch, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.patchAccountGroupID(accountGroupIdPatch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountDataApi.patchAccountGroupID']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update user\'s account preferences. This will overwrite the preferences, so always send the full object.
         * @summary /account/preferences
         * @param {UpdateAccountPreferenceRequest} updateAccountPreferenceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putAccountPreferences(updateAccountPreferenceRequest: UpdateAccountPreferenceRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putAccountPreferences(updateAccountPreferenceRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountDataApi.putAccountPreferences']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Sponsors a transaction if it\'s eligible for sponsorship based on allowlisted methods and kinds.
         * @summary /account/sponsorTx
         * @param {SponsorTxRequest} sponsorTxRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sponsorTx(sponsorTxRequest: SponsorTxRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SponsorTxResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sponsorTx(sponsorTxRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AccountDataApi.sponsorTx']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AccountDataApi - factory interface
 * @export
 */
export const AccountDataApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AccountDataApiFp(configuration)
    return {
        /**
         * Retrieves the user\'s account details.
         * @summary /account
         * @param {string} [accountAddress] Account address to fetch account details by.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountDetails(accountAddress?: string, options?: RawAxiosRequestConfig): AxiosPromise<Account> {
            return localVarFp.getAccountDetails(accountAddress, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the funding rate history for a specific account.
         * @summary /account/fundingRateHistory
         * @param {string} [accountAddress] Account address to filter funding rate history by.
         * @param {number} [limit] Default 500; max 1000.
         * @param {number} [page] The page number to retrieve in a paginated response.
         * @param {number} [startTimeAtMillis] Start time in milliseconds. Defaults to 7 days ago if not specified.
         * @param {number} [endTimeAtMillis] End time in milliseconds. Defaults to now if not specified. Must be greater than start time and must be less than 90 days apart.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountFundingRateHistory(accountAddress?: string, limit?: number, page?: number, startTimeAtMillis?: number, endTimeAtMillis?: number, options?: RawAxiosRequestConfig): AxiosPromise<AccountFundingRateHistory> {
            return localVarFp.getAccountFundingRateHistory(accountAddress, limit, page, startTimeAtMillis, endTimeAtMillis, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the user\'s account preferences.
         * @summary /account/preferences
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountPreferences(options?: RawAxiosRequestConfig): AxiosPromise<AccountPreference> {
            return localVarFp.getAccountPreferences(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the user\'s trade history.
         * @summary /account/trades
         * @param {string} [symbol] Market address to filter trades by. If not specified, returns trades for all markets.
         * @param {number} [startTimeAtMillis] Start time in milliseconds. Defaults to 7 days ago if not specified.
         * @param {number} [endTimeAtMillis] End time in milliseconds. Defaults to now if not specified. Must be greater than start time and must be less than 90 days apart.
         * @param {number} [limit] Default 500; max 1000.
         * @param {TradeType} [tradeType] Type of trade. By default returns all. UNSPECIFIED returns all.
         * @param {number} [page] The page number to retrieve in a paginated response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountTrades(symbol?: string, startTimeAtMillis?: number, endTimeAtMillis?: number, limit?: number, tradeType?: TradeType, page?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<Trade>> {
            return localVarFp.getAccountTrades(symbol, startTimeAtMillis, endTimeAtMillis, limit, tradeType, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves the user\'s transaction history (any change in balance).
         * @summary /account/transactions
         * @param {Array<TransactionType>} [types] Optional query parameter to filter transactions by type.
         * @param {string} [assetSymbol] Optional query parameter to filter transactions by asset bank address.
         * @param {number} [startTimeAtMillis] Start time in milliseconds. Defaults to 7 days ago if not specified.
         * @param {number} [endTimeAtMillis] End time in milliseconds. Defaults to now if not specified. Must be greater than start time and must be less than 90 days apart.
         * @param {number} [limit] Default 500; max 1000.
         * @param {number} [page] The page number to retrieve in a paginated response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountTransactionHistory(types?: Array<TransactionType>, assetSymbol?: string, startTimeAtMillis?: number, endTimeAtMillis?: number, limit?: number, page?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<Transaction>> {
            return localVarFp.getAccountTransactionHistory(types, assetSymbol, startTimeAtMillis, endTimeAtMillis, limit, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Sets or updates the group ID for a specific account. Accounts belonging to the same group cannot trade against each other. If the groupId is not set, the account will be removed from its group. Only the first 6 characters of the groupID are guaranteed to be respected, longer group IDs may be rejected. 
         * @summary Set the group ID for an account.
         * @param {AccountGroupIdPatch} accountGroupIdPatch Account group ID update.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        patchAccountGroupID(accountGroupIdPatch: AccountGroupIdPatch, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.patchAccountGroupID(accountGroupIdPatch, options).then((request) => request(axios, basePath));
        },
        /**
         * Update user\'s account preferences. This will overwrite the preferences, so always send the full object.
         * @summary /account/preferences
         * @param {UpdateAccountPreferenceRequest} updateAccountPreferenceRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putAccountPreferences(updateAccountPreferenceRequest: UpdateAccountPreferenceRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.putAccountPreferences(updateAccountPreferenceRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Sponsors a transaction if it\'s eligible for sponsorship based on allowlisted methods and kinds.
         * @summary /account/sponsorTx
         * @param {SponsorTxRequest} sponsorTxRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sponsorTx(sponsorTxRequest: SponsorTxRequest, options?: RawAxiosRequestConfig): AxiosPromise<SponsorTxResponse> {
            return localVarFp.sponsorTx(sponsorTxRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AccountDataApi - object-oriented interface
 * @export
 * @class AccountDataApi
 * @extends {BaseAPI}
 */
export class AccountDataApi extends BaseAPI {
    /**
     * Retrieves the user\'s account details.
     * @summary /account
     * @param {string} [accountAddress] Account address to fetch account details by.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountDataApi
     */
    public getAccountDetails(accountAddress?: string, options?: RawAxiosRequestConfig) {
        return AccountDataApiFp(this.configuration).getAccountDetails(accountAddress, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the funding rate history for a specific account.
     * @summary /account/fundingRateHistory
     * @param {string} [accountAddress] Account address to filter funding rate history by.
     * @param {number} [limit] Default 500; max 1000.
     * @param {number} [page] The page number to retrieve in a paginated response.
     * @param {number} [startTimeAtMillis] Start time in milliseconds. Defaults to 7 days ago if not specified.
     * @param {number} [endTimeAtMillis] End time in milliseconds. Defaults to now if not specified. Must be greater than start time and must be less than 90 days apart.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountDataApi
     */
    public getAccountFundingRateHistory(accountAddress?: string, limit?: number, page?: number, startTimeAtMillis?: number, endTimeAtMillis?: number, options?: RawAxiosRequestConfig) {
        return AccountDataApiFp(this.configuration).getAccountFundingRateHistory(accountAddress, limit, page, startTimeAtMillis, endTimeAtMillis, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the user\'s account preferences.
     * @summary /account/preferences
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountDataApi
     */
    public getAccountPreferences(options?: RawAxiosRequestConfig) {
        return AccountDataApiFp(this.configuration).getAccountPreferences(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the user\'s trade history.
     * @summary /account/trades
     * @param {string} [symbol] Market address to filter trades by. If not specified, returns trades for all markets.
     * @param {number} [startTimeAtMillis] Start time in milliseconds. Defaults to 7 days ago if not specified.
     * @param {number} [endTimeAtMillis] End time in milliseconds. Defaults to now if not specified. Must be greater than start time and must be less than 90 days apart.
     * @param {number} [limit] Default 500; max 1000.
     * @param {TradeType} [tradeType] Type of trade. By default returns all. UNSPECIFIED returns all.
     * @param {number} [page] The page number to retrieve in a paginated response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountDataApi
     */
    public getAccountTrades(symbol?: string, startTimeAtMillis?: number, endTimeAtMillis?: number, limit?: number, tradeType?: TradeType, page?: number, options?: RawAxiosRequestConfig) {
        return AccountDataApiFp(this.configuration).getAccountTrades(symbol, startTimeAtMillis, endTimeAtMillis, limit, tradeType, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves the user\'s transaction history (any change in balance).
     * @summary /account/transactions
     * @param {Array<TransactionType>} [types] Optional query parameter to filter transactions by type.
     * @param {string} [assetSymbol] Optional query parameter to filter transactions by asset bank address.
     * @param {number} [startTimeAtMillis] Start time in milliseconds. Defaults to 7 days ago if not specified.
     * @param {number} [endTimeAtMillis] End time in milliseconds. Defaults to now if not specified. Must be greater than start time and must be less than 90 days apart.
     * @param {number} [limit] Default 500; max 1000.
     * @param {number} [page] The page number to retrieve in a paginated response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountDataApi
     */
    public getAccountTransactionHistory(types?: Array<TransactionType>, assetSymbol?: string, startTimeAtMillis?: number, endTimeAtMillis?: number, limit?: number, page?: number, options?: RawAxiosRequestConfig) {
        return AccountDataApiFp(this.configuration).getAccountTransactionHistory(types, assetSymbol, startTimeAtMillis, endTimeAtMillis, limit, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sets or updates the group ID for a specific account. Accounts belonging to the same group cannot trade against each other. If the groupId is not set, the account will be removed from its group. Only the first 6 characters of the groupID are guaranteed to be respected, longer group IDs may be rejected. 
     * @summary Set the group ID for an account.
     * @param {AccountGroupIdPatch} accountGroupIdPatch Account group ID update.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountDataApi
     */
    public patchAccountGroupID(accountGroupIdPatch: AccountGroupIdPatch, options?: RawAxiosRequestConfig) {
        return AccountDataApiFp(this.configuration).patchAccountGroupID(accountGroupIdPatch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update user\'s account preferences. This will overwrite the preferences, so always send the full object.
     * @summary /account/preferences
     * @param {UpdateAccountPreferenceRequest} updateAccountPreferenceRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountDataApi
     */
    public putAccountPreferences(updateAccountPreferenceRequest: UpdateAccountPreferenceRequest, options?: RawAxiosRequestConfig) {
        return AccountDataApiFp(this.configuration).putAccountPreferences(updateAccountPreferenceRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Sponsors a transaction if it\'s eligible for sponsorship based on allowlisted methods and kinds.
     * @summary /account/sponsorTx
     * @param {SponsorTxRequest} sponsorTxRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountDataApi
     */
    public sponsorTx(sponsorTxRequest: SponsorTxRequest, options?: RawAxiosRequestConfig) {
        return AccountDataApiFp(this.configuration).sponsorTx(sponsorTxRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authJwksGet: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/jwks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * login with token
         * @param {string} payloadSignature 
         * @param {LoginRequest} loginRequest 
         * @param {number} [refreshTokenValidForSeconds] The number of seconds the refresh token is valid for. If not provided, the default is 30 days.
         * @param {boolean} [readOnly] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authTokenPost: async (payloadSignature: string, loginRequest: LoginRequest, refreshTokenValidForSeconds?: number, readOnly?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'payloadSignature' is not null or undefined
            assertParamExists('authTokenPost', 'payloadSignature', payloadSignature)
            // verify required parameter 'loginRequest' is not null or undefined
            assertParamExists('authTokenPost', 'loginRequest', loginRequest)
            const localVarPath = `/auth/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (refreshTokenValidForSeconds !== undefined) {
                localVarQueryParameter['refreshTokenValidForSeconds'] = refreshTokenValidForSeconds;
            }

            if (readOnly !== undefined) {
                localVarQueryParameter['readOnly'] = readOnly;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (payloadSignature != null) {
                localVarHeaderParameter['payloadSignature'] = String(payloadSignature);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves a new auth token for an account. Expiry is set to 5 min.
         * @param {RefreshTokenRequest} refreshTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authTokenRefreshPut: async (refreshTokenRequest: RefreshTokenRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'refreshTokenRequest' is not null or undefined
            assertParamExists('authTokenRefreshPut', 'refreshTokenRequest', refreshTokenRequest)
            const localVarPath = `/auth/token/refresh`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(refreshTokenRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * login compatible with BCS payload with intent bytes
         * @param {string} payloadSignature 
         * @param {LoginRequest} loginRequest 
         * @param {number} [refreshTokenValidForSeconds] The number of seconds the refresh token is valid for. If not provided, the default is 30 days.
         * @param {boolean} [readOnly] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authV2TokenPost: async (payloadSignature: string, loginRequest: LoginRequest, refreshTokenValidForSeconds?: number, readOnly?: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'payloadSignature' is not null or undefined
            assertParamExists('authV2TokenPost', 'payloadSignature', payloadSignature)
            // verify required parameter 'loginRequest' is not null or undefined
            assertParamExists('authV2TokenPost', 'loginRequest', loginRequest)
            const localVarPath = `/auth/v2/token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (refreshTokenValidForSeconds !== undefined) {
                localVarQueryParameter['refreshTokenValidForSeconds'] = refreshTokenValidForSeconds;
            }

            if (readOnly !== undefined) {
                localVarQueryParameter['readOnly'] = readOnly;
            }


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (payloadSignature != null) {
                localVarHeaderParameter['payloadSignature'] = String(payloadSignature);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * ZK Login User Details
         * @summary /auth/zklogin
         * @param {string} zkloginJwt The JWT of the user signed in with zkLogin.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getZkLoginUserDetails: async (zkloginJwt: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'zkloginJwt' is not null or undefined
            assertParamExists('getZkLoginUserDetails', 'zkloginJwt', zkloginJwt)
            const localVarPath = `/auth/zklogin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (zkloginJwt != null) {
                localVarHeaderParameter['zklogin-jwt'] = String(zkloginJwt);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary /auth/zklogin/zkp
         * @param {string} zkloginJwt The JWT of the user signed in with zkLogin.
         * @param {ZKLoginZKPRequest} zKLoginZKPRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postZkLoginZkp: async (zkloginJwt: string, zKLoginZKPRequest: ZKLoginZKPRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'zkloginJwt' is not null or undefined
            assertParamExists('postZkLoginZkp', 'zkloginJwt', zkloginJwt)
            // verify required parameter 'zKLoginZKPRequest' is not null or undefined
            assertParamExists('postZkLoginZkp', 'zKLoginZKPRequest', zKLoginZKPRequest)
            const localVarPath = `/auth/zklogin/zkp`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            if (zkloginJwt != null) {
                localVarHeaderParameter['zklogin-jwt'] = String(zkloginJwt);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(zKLoginZKPRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authJwksGet(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: any | undefined; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authJwksGet(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authJwksGet']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * login with token
         * @param {string} payloadSignature 
         * @param {LoginRequest} loginRequest 
         * @param {number} [refreshTokenValidForSeconds] The number of seconds the refresh token is valid for. If not provided, the default is 30 days.
         * @param {boolean} [readOnly] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authTokenPost(payloadSignature: string, loginRequest: LoginRequest, refreshTokenValidForSeconds?: number, readOnly?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authTokenPost(payloadSignature, loginRequest, refreshTokenValidForSeconds, readOnly, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authTokenPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves a new auth token for an account. Expiry is set to 5 min.
         * @param {RefreshTokenRequest} refreshTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authTokenRefreshPut(refreshTokenRequest: RefreshTokenRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RefreshTokenResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authTokenRefreshPut(refreshTokenRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authTokenRefreshPut']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * login compatible with BCS payload with intent bytes
         * @param {string} payloadSignature 
         * @param {LoginRequest} loginRequest 
         * @param {number} [refreshTokenValidForSeconds] The number of seconds the refresh token is valid for. If not provided, the default is 30 days.
         * @param {boolean} [readOnly] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authV2TokenPost(payloadSignature: string, loginRequest: LoginRequest, refreshTokenValidForSeconds?: number, readOnly?: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authV2TokenPost(payloadSignature, loginRequest, refreshTokenValidForSeconds, readOnly, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.authV2TokenPost']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * ZK Login User Details
         * @summary /auth/zklogin
         * @param {string} zkloginJwt The JWT of the user signed in with zkLogin.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getZkLoginUserDetails(zkloginJwt: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ZKLoginUserDetailsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getZkLoginUserDetails(zkloginJwt, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.getZkLoginUserDetails']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @summary /auth/zklogin/zkp
         * @param {string} zkloginJwt The JWT of the user signed in with zkLogin.
         * @param {ZKLoginZKPRequest} zKLoginZKPRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postZkLoginZkp(zkloginJwt: string, zKLoginZKPRequest: ZKLoginZKPRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ZKLoginZKPResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postZkLoginZkp(zkloginJwt, zKLoginZKPRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AuthApi.postZkLoginZkp']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authJwksGet(options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: any | undefined; }> {
            return localVarFp.authJwksGet(options).then((request) => request(axios, basePath));
        },
        /**
         * login with token
         * @param {string} payloadSignature 
         * @param {LoginRequest} loginRequest 
         * @param {number} [refreshTokenValidForSeconds] The number of seconds the refresh token is valid for. If not provided, the default is 30 days.
         * @param {boolean} [readOnly] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authTokenPost(payloadSignature: string, loginRequest: LoginRequest, refreshTokenValidForSeconds?: number, readOnly?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<LoginResponse> {
            return localVarFp.authTokenPost(payloadSignature, loginRequest, refreshTokenValidForSeconds, readOnly, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves a new auth token for an account. Expiry is set to 5 min.
         * @param {RefreshTokenRequest} refreshTokenRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authTokenRefreshPut(refreshTokenRequest: RefreshTokenRequest, options?: RawAxiosRequestConfig): AxiosPromise<RefreshTokenResponse> {
            return localVarFp.authTokenRefreshPut(refreshTokenRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * login compatible with BCS payload with intent bytes
         * @param {string} payloadSignature 
         * @param {LoginRequest} loginRequest 
         * @param {number} [refreshTokenValidForSeconds] The number of seconds the refresh token is valid for. If not provided, the default is 30 days.
         * @param {boolean} [readOnly] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authV2TokenPost(payloadSignature: string, loginRequest: LoginRequest, refreshTokenValidForSeconds?: number, readOnly?: boolean, options?: RawAxiosRequestConfig): AxiosPromise<LoginResponse> {
            return localVarFp.authV2TokenPost(payloadSignature, loginRequest, refreshTokenValidForSeconds, readOnly, options).then((request) => request(axios, basePath));
        },
        /**
         * ZK Login User Details
         * @summary /auth/zklogin
         * @param {string} zkloginJwt The JWT of the user signed in with zkLogin.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getZkLoginUserDetails(zkloginJwt: string, options?: RawAxiosRequestConfig): AxiosPromise<ZKLoginUserDetailsResponse> {
            return localVarFp.getZkLoginUserDetails(zkloginJwt, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary /auth/zklogin/zkp
         * @param {string} zkloginJwt The JWT of the user signed in with zkLogin.
         * @param {ZKLoginZKPRequest} zKLoginZKPRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postZkLoginZkp(zkloginJwt: string, zKLoginZKPRequest: ZKLoginZKPRequest, options?: RawAxiosRequestConfig): AxiosPromise<ZKLoginZKPResponse> {
            return localVarFp.postZkLoginZkp(zkloginJwt, zKLoginZKPRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authJwksGet(options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authJwksGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * login with token
     * @param {string} payloadSignature 
     * @param {LoginRequest} loginRequest 
     * @param {number} [refreshTokenValidForSeconds] The number of seconds the refresh token is valid for. If not provided, the default is 30 days.
     * @param {boolean} [readOnly] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authTokenPost(payloadSignature: string, loginRequest: LoginRequest, refreshTokenValidForSeconds?: number, readOnly?: boolean, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authTokenPost(payloadSignature, loginRequest, refreshTokenValidForSeconds, readOnly, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves a new auth token for an account. Expiry is set to 5 min.
     * @param {RefreshTokenRequest} refreshTokenRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authTokenRefreshPut(refreshTokenRequest: RefreshTokenRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authTokenRefreshPut(refreshTokenRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * login compatible with BCS payload with intent bytes
     * @param {string} payloadSignature 
     * @param {LoginRequest} loginRequest 
     * @param {number} [refreshTokenValidForSeconds] The number of seconds the refresh token is valid for. If not provided, the default is 30 days.
     * @param {boolean} [readOnly] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authV2TokenPost(payloadSignature: string, loginRequest: LoginRequest, refreshTokenValidForSeconds?: number, readOnly?: boolean, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).authV2TokenPost(payloadSignature, loginRequest, refreshTokenValidForSeconds, readOnly, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * ZK Login User Details
     * @summary /auth/zklogin
     * @param {string} zkloginJwt The JWT of the user signed in with zkLogin.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public getZkLoginUserDetails(zkloginJwt: string, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).getZkLoginUserDetails(zkloginJwt, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary /auth/zklogin/zkp
     * @param {string} zkloginJwt The JWT of the user signed in with zkLogin.
     * @param {ZKLoginZKPRequest} zKLoginZKPRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public postZkLoginZkp(zkloginJwt: string, zKLoginZKPRequest: ZKLoginZKPRequest, options?: RawAxiosRequestConfig) {
        return AuthApiFp(this.configuration).postZkLoginZkp(zkloginJwt, zKLoginZKPRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ExchangeApi - axios parameter creator
 * @export
 */
export const ExchangeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieves all market ticker information.
         * @summary /exchange/tickers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllMarketTicker: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/exchange/tickers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves candle stick data for a market.
         * @summary /exchange/candlesticks
         * @param {string} symbol The market symbol to get the klines for.
         * @param {KlineInterval} interval The interval to get the klines for.
         * @param {CandlePriceType} type Candle price type (last price, market price or oracle).
         * @param {number} [startTimeAtMillis] Timestamp in milliseconds in ms to get klines from.
         * @param {number} [endTimeAtMillis] Timestamp in milliseconds in ms to get klines until.
         * @param {number} [limit] Default 50; max 1000.
         * @param {number} [page] The page number to retrieve in a paginated response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCandlestickData: async (symbol: string, interval: KlineInterval, type: CandlePriceType, startTimeAtMillis?: number, endTimeAtMillis?: number, limit?: number, page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getCandlestickData', 'symbol', symbol)
            // verify required parameter 'interval' is not null or undefined
            assertParamExists('getCandlestickData', 'interval', interval)
            // verify required parameter 'type' is not null or undefined
            assertParamExists('getCandlestickData', 'type', type)
            const localVarPath = `/v1/exchange/candlesticks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (startTimeAtMillis !== undefined) {
                localVarQueryParameter['startTimeAtMillis'] = startTimeAtMillis;
            }

            if (endTimeAtMillis !== undefined) {
                localVarQueryParameter['endTimeAtMillis'] = endTimeAtMillis;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Check if the country is geo restricted.
         * @summary /exchange/country
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCountry: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/exchange/country`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the current exchange information including available margin assets, markets, and rules.
         * @summary /exchange/info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExchangeInfo: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/exchange/info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves exchange statistics.
         * @summary /exchange/stats
         * @param {StatsInterval} [interval] 
         * @param {number} [startTimeAtMillis] Timestamp in milliseconds.
         * @param {number} [endTimeAtMillis] Timestamp in milliseconds.
         * @param {number} [limit] Number of records to return. Default is 30; max is 200.
         * @param {number} [page] The page number to retrieve in a paginated response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExchangeStats: async (interval?: StatsInterval, startTimeAtMillis?: number, endTimeAtMillis?: number, limit?: number, page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/exchange/stats`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }

            if (startTimeAtMillis !== undefined) {
                localVarQueryParameter['startTimeAtMillis'] = startTimeAtMillis;
            }

            if (endTimeAtMillis !== undefined) {
                localVarQueryParameter['endTimeAtMillis'] = endTimeAtMillis;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves all time exchange statistics.
         * @summary /v1/exchange/stats/allTime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExchangeStatsAllTime: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/exchange/stats/allTime`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve the funding rate history for a specific market address.
         * @summary /exchange/fundingRateHistory
         * @param {string} symbol The market symbol to get funding rate history for
         * @param {number} [limit] Number of records to return. Default is 100; max is 1000.
         * @param {number} [startTimeAtMillis] The timestamp specifies the earliest point in time for which data should be returned. The value is not included.
         * @param {number} [endTimeAtMillis] The timestamp specifies the latest point in time for which data should be returned. The value is included.
         * @param {number} [page] The page number to retrieve in a paginated response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFundingRateHistory: async (symbol: string, limit?: number, startTimeAtMillis?: number, endTimeAtMillis?: number, page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getFundingRateHistory', 'symbol', symbol)
            const localVarPath = `/v1/exchange/fundingRateHistory`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startTimeAtMillis !== undefined) {
                localVarQueryParameter['startTimeAtMillis'] = startTimeAtMillis;
            }

            if (endTimeAtMillis !== undefined) {
                localVarQueryParameter['endTimeAtMillis'] = endTimeAtMillis;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves aggregated ticker data for a market.
         * @summary /exchange/ticker
         * @param {string} symbol Market symbol.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarketTicker: async (symbol: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getMarketTicker', 'symbol', symbol)
            const localVarPath = `/v1/exchange/ticker`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the current state of the orderbook.
         * @summary /exchange/depth
         * @param {string} symbol Market symbol to get the orderbook depth for.
         * @param {number} [limit] Maximum number of bids and asks to return. Default 500; max 1000.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderbookDepth: async (symbol: string, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getOrderbookDepth', 'symbol', symbol)
            const localVarPath = `/v1/exchange/depth`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieves recent trades executed on a market.
         * @summary /exchange/trades
         * @param {string} symbol The market symbol to get the trades for.
         * @param {TradeType} [tradeType] Type of trade.
         * @param {number} [limit] Default 500; max 1000.
         * @param {number} [startTimeAtMillis] The timestamp specifies the earliest point in time for which data should be returned. The value is not included.
         * @param {number} [endTimeAtMillis] The timestamp specifies the latest point in time for which data should be returned. The value is included.
         * @param {number} [page] The page number to retrieve in a paginated response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecentTrades: async (symbol: string, tradeType?: TradeType, limit?: number, startTimeAtMillis?: number, endTimeAtMillis?: number, page?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'symbol' is not null or undefined
            assertParamExists('getRecentTrades', 'symbol', symbol)
            const localVarPath = `/v1/exchange/trades`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }

            if (tradeType !== undefined) {
                localVarQueryParameter['tradeType'] = tradeType;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (startTimeAtMillis !== undefined) {
                localVarQueryParameter['startTimeAtMillis'] = startTimeAtMillis;
            }

            if (endTimeAtMillis !== undefined) {
                localVarQueryParameter['endTimeAtMillis'] = endTimeAtMillis;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ExchangeApi - functional programming interface
 * @export
 */
export const ExchangeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ExchangeApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieves all market ticker information.
         * @summary /exchange/tickers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllMarketTicker(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TickerResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllMarketTicker(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExchangeApi.getAllMarketTicker']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves candle stick data for a market.
         * @summary /exchange/candlesticks
         * @param {string} symbol The market symbol to get the klines for.
         * @param {KlineInterval} interval The interval to get the klines for.
         * @param {CandlePriceType} type Candle price type (last price, market price or oracle).
         * @param {number} [startTimeAtMillis] Timestamp in milliseconds in ms to get klines from.
         * @param {number} [endTimeAtMillis] Timestamp in milliseconds in ms to get klines until.
         * @param {number} [limit] Default 50; max 1000.
         * @param {number} [page] The page number to retrieve in a paginated response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCandlestickData(symbol: string, interval: KlineInterval, type: CandlePriceType, startTimeAtMillis?: number, endTimeAtMillis?: number, limit?: number, page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Array<string>>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCandlestickData(symbol, interval, type, startTimeAtMillis, endTimeAtMillis, limit, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExchangeApi.getCandlestickData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Check if the country is geo restricted.
         * @summary /exchange/country
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCountry(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CountryResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCountry(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExchangeApi.getCountry']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the current exchange information including available margin assets, markets, and rules.
         * @summary /exchange/info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExchangeInfo(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExchangeInfoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExchangeInfo(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExchangeApi.getExchangeInfo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves exchange statistics.
         * @summary /exchange/stats
         * @param {StatsInterval} [interval] 
         * @param {number} [startTimeAtMillis] Timestamp in milliseconds.
         * @param {number} [endTimeAtMillis] Timestamp in milliseconds.
         * @param {number} [limit] Number of records to return. Default is 30; max is 200.
         * @param {number} [page] The page number to retrieve in a paginated response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExchangeStats(interval?: StatsInterval, startTimeAtMillis?: number, endTimeAtMillis?: number, limit?: number, page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExchangeStats(interval, startTimeAtMillis, endTimeAtMillis, limit, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExchangeApi.getExchangeStats']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves all time exchange statistics.
         * @summary /v1/exchange/stats/allTime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExchangeStatsAllTime(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<StatsAllTimeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExchangeStatsAllTime(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExchangeApi.getExchangeStatsAllTime']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve the funding rate history for a specific market address.
         * @summary /exchange/fundingRateHistory
         * @param {string} symbol The market symbol to get funding rate history for
         * @param {number} [limit] Number of records to return. Default is 100; max is 1000.
         * @param {number} [startTimeAtMillis] The timestamp specifies the earliest point in time for which data should be returned. The value is not included.
         * @param {number} [endTimeAtMillis] The timestamp specifies the latest point in time for which data should be returned. The value is included.
         * @param {number} [page] The page number to retrieve in a paginated response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFundingRateHistory(symbol: string, limit?: number, startTimeAtMillis?: number, endTimeAtMillis?: number, page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FundingRateEntry>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFundingRateHistory(symbol, limit, startTimeAtMillis, endTimeAtMillis, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExchangeApi.getFundingRateHistory']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves aggregated ticker data for a market.
         * @summary /exchange/ticker
         * @param {string} symbol Market symbol.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMarketTicker(symbol: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TickerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMarketTicker(symbol, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExchangeApi.getMarketTicker']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the current state of the orderbook.
         * @summary /exchange/depth
         * @param {string} symbol Market symbol to get the orderbook depth for.
         * @param {number} [limit] Maximum number of bids and asks to return. Default 500; max 1000.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrderbookDepth(symbol: string, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderbookDepthResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrderbookDepth(symbol, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExchangeApi.getOrderbookDepth']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieves recent trades executed on a market.
         * @summary /exchange/trades
         * @param {string} symbol The market symbol to get the trades for.
         * @param {TradeType} [tradeType] Type of trade.
         * @param {number} [limit] Default 500; max 1000.
         * @param {number} [startTimeAtMillis] The timestamp specifies the earliest point in time for which data should be returned. The value is not included.
         * @param {number} [endTimeAtMillis] The timestamp specifies the latest point in time for which data should be returned. The value is included.
         * @param {number} [page] The page number to retrieve in a paginated response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRecentTrades(symbol: string, tradeType?: TradeType, limit?: number, startTimeAtMillis?: number, endTimeAtMillis?: number, page?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Trade>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRecentTrades(symbol, tradeType, limit, startTimeAtMillis, endTimeAtMillis, page, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ExchangeApi.getRecentTrades']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ExchangeApi - factory interface
 * @export
 */
export const ExchangeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ExchangeApiFp(configuration)
    return {
        /**
         * Retrieves all market ticker information.
         * @summary /exchange/tickers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllMarketTicker(options?: RawAxiosRequestConfig): AxiosPromise<Array<TickerResponse>> {
            return localVarFp.getAllMarketTicker(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves candle stick data for a market.
         * @summary /exchange/candlesticks
         * @param {string} symbol The market symbol to get the klines for.
         * @param {KlineInterval} interval The interval to get the klines for.
         * @param {CandlePriceType} type Candle price type (last price, market price or oracle).
         * @param {number} [startTimeAtMillis] Timestamp in milliseconds in ms to get klines from.
         * @param {number} [endTimeAtMillis] Timestamp in milliseconds in ms to get klines until.
         * @param {number} [limit] Default 50; max 1000.
         * @param {number} [page] The page number to retrieve in a paginated response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCandlestickData(symbol: string, interval: KlineInterval, type: CandlePriceType, startTimeAtMillis?: number, endTimeAtMillis?: number, limit?: number, page?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<Array<string>>> {
            return localVarFp.getCandlestickData(symbol, interval, type, startTimeAtMillis, endTimeAtMillis, limit, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Check if the country is geo restricted.
         * @summary /exchange/country
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCountry(options?: RawAxiosRequestConfig): AxiosPromise<CountryResponse> {
            return localVarFp.getCountry(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the current exchange information including available margin assets, markets, and rules.
         * @summary /exchange/info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExchangeInfo(options?: RawAxiosRequestConfig): AxiosPromise<ExchangeInfoResponse> {
            return localVarFp.getExchangeInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves exchange statistics.
         * @summary /exchange/stats
         * @param {StatsInterval} [interval] 
         * @param {number} [startTimeAtMillis] Timestamp in milliseconds.
         * @param {number} [endTimeAtMillis] Timestamp in milliseconds.
         * @param {number} [limit] Number of records to return. Default is 30; max is 200.
         * @param {number} [page] The page number to retrieve in a paginated response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExchangeStats(interval?: StatsInterval, startTimeAtMillis?: number, endTimeAtMillis?: number, limit?: number, page?: number, options?: RawAxiosRequestConfig): AxiosPromise<StatsResponse> {
            return localVarFp.getExchangeStats(interval, startTimeAtMillis, endTimeAtMillis, limit, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves all time exchange statistics.
         * @summary /v1/exchange/stats/allTime
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExchangeStatsAllTime(options?: RawAxiosRequestConfig): AxiosPromise<StatsAllTimeResponse> {
            return localVarFp.getExchangeStatsAllTime(options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve the funding rate history for a specific market address.
         * @summary /exchange/fundingRateHistory
         * @param {string} symbol The market symbol to get funding rate history for
         * @param {number} [limit] Number of records to return. Default is 100; max is 1000.
         * @param {number} [startTimeAtMillis] The timestamp specifies the earliest point in time for which data should be returned. The value is not included.
         * @param {number} [endTimeAtMillis] The timestamp specifies the latest point in time for which data should be returned. The value is included.
         * @param {number} [page] The page number to retrieve in a paginated response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFundingRateHistory(symbol: string, limit?: number, startTimeAtMillis?: number, endTimeAtMillis?: number, page?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<FundingRateEntry>> {
            return localVarFp.getFundingRateHistory(symbol, limit, startTimeAtMillis, endTimeAtMillis, page, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves aggregated ticker data for a market.
         * @summary /exchange/ticker
         * @param {string} symbol Market symbol.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMarketTicker(symbol: string, options?: RawAxiosRequestConfig): AxiosPromise<TickerResponse> {
            return localVarFp.getMarketTicker(symbol, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the current state of the orderbook.
         * @summary /exchange/depth
         * @param {string} symbol Market symbol to get the orderbook depth for.
         * @param {number} [limit] Maximum number of bids and asks to return. Default 500; max 1000.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderbookDepth(symbol: string, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<OrderbookDepthResponse> {
            return localVarFp.getOrderbookDepth(symbol, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieves recent trades executed on a market.
         * @summary /exchange/trades
         * @param {string} symbol The market symbol to get the trades for.
         * @param {TradeType} [tradeType] Type of trade.
         * @param {number} [limit] Default 500; max 1000.
         * @param {number} [startTimeAtMillis] The timestamp specifies the earliest point in time for which data should be returned. The value is not included.
         * @param {number} [endTimeAtMillis] The timestamp specifies the latest point in time for which data should be returned. The value is included.
         * @param {number} [page] The page number to retrieve in a paginated response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRecentTrades(symbol: string, tradeType?: TradeType, limit?: number, startTimeAtMillis?: number, endTimeAtMillis?: number, page?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<Trade>> {
            return localVarFp.getRecentTrades(symbol, tradeType, limit, startTimeAtMillis, endTimeAtMillis, page, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ExchangeApi - object-oriented interface
 * @export
 * @class ExchangeApi
 * @extends {BaseAPI}
 */
export class ExchangeApi extends BaseAPI {
    /**
     * Retrieves all market ticker information.
     * @summary /exchange/tickers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExchangeApi
     */
    public getAllMarketTicker(options?: RawAxiosRequestConfig) {
        return ExchangeApiFp(this.configuration).getAllMarketTicker(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves candle stick data for a market.
     * @summary /exchange/candlesticks
     * @param {string} symbol The market symbol to get the klines for.
     * @param {KlineInterval} interval The interval to get the klines for.
     * @param {CandlePriceType} type Candle price type (last price, market price or oracle).
     * @param {number} [startTimeAtMillis] Timestamp in milliseconds in ms to get klines from.
     * @param {number} [endTimeAtMillis] Timestamp in milliseconds in ms to get klines until.
     * @param {number} [limit] Default 50; max 1000.
     * @param {number} [page] The page number to retrieve in a paginated response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExchangeApi
     */
    public getCandlestickData(symbol: string, interval: KlineInterval, type: CandlePriceType, startTimeAtMillis?: number, endTimeAtMillis?: number, limit?: number, page?: number, options?: RawAxiosRequestConfig) {
        return ExchangeApiFp(this.configuration).getCandlestickData(symbol, interval, type, startTimeAtMillis, endTimeAtMillis, limit, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Check if the country is geo restricted.
     * @summary /exchange/country
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExchangeApi
     */
    public getCountry(options?: RawAxiosRequestConfig) {
        return ExchangeApiFp(this.configuration).getCountry(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the current exchange information including available margin assets, markets, and rules.
     * @summary /exchange/info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExchangeApi
     */
    public getExchangeInfo(options?: RawAxiosRequestConfig) {
        return ExchangeApiFp(this.configuration).getExchangeInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves exchange statistics.
     * @summary /exchange/stats
     * @param {StatsInterval} [interval] 
     * @param {number} [startTimeAtMillis] Timestamp in milliseconds.
     * @param {number} [endTimeAtMillis] Timestamp in milliseconds.
     * @param {number} [limit] Number of records to return. Default is 30; max is 200.
     * @param {number} [page] The page number to retrieve in a paginated response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExchangeApi
     */
    public getExchangeStats(interval?: StatsInterval, startTimeAtMillis?: number, endTimeAtMillis?: number, limit?: number, page?: number, options?: RawAxiosRequestConfig) {
        return ExchangeApiFp(this.configuration).getExchangeStats(interval, startTimeAtMillis, endTimeAtMillis, limit, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves all time exchange statistics.
     * @summary /v1/exchange/stats/allTime
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExchangeApi
     */
    public getExchangeStatsAllTime(options?: RawAxiosRequestConfig) {
        return ExchangeApiFp(this.configuration).getExchangeStatsAllTime(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve the funding rate history for a specific market address.
     * @summary /exchange/fundingRateHistory
     * @param {string} symbol The market symbol to get funding rate history for
     * @param {number} [limit] Number of records to return. Default is 100; max is 1000.
     * @param {number} [startTimeAtMillis] The timestamp specifies the earliest point in time for which data should be returned. The value is not included.
     * @param {number} [endTimeAtMillis] The timestamp specifies the latest point in time for which data should be returned. The value is included.
     * @param {number} [page] The page number to retrieve in a paginated response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExchangeApi
     */
    public getFundingRateHistory(symbol: string, limit?: number, startTimeAtMillis?: number, endTimeAtMillis?: number, page?: number, options?: RawAxiosRequestConfig) {
        return ExchangeApiFp(this.configuration).getFundingRateHistory(symbol, limit, startTimeAtMillis, endTimeAtMillis, page, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves aggregated ticker data for a market.
     * @summary /exchange/ticker
     * @param {string} symbol Market symbol.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExchangeApi
     */
    public getMarketTicker(symbol: string, options?: RawAxiosRequestConfig) {
        return ExchangeApiFp(this.configuration).getMarketTicker(symbol, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the current state of the orderbook.
     * @summary /exchange/depth
     * @param {string} symbol Market symbol to get the orderbook depth for.
     * @param {number} [limit] Maximum number of bids and asks to return. Default 500; max 1000.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExchangeApi
     */
    public getOrderbookDepth(symbol: string, limit?: number, options?: RawAxiosRequestConfig) {
        return ExchangeApiFp(this.configuration).getOrderbookDepth(symbol, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieves recent trades executed on a market.
     * @summary /exchange/trades
     * @param {string} symbol The market symbol to get the trades for.
     * @param {TradeType} [tradeType] Type of trade.
     * @param {number} [limit] Default 500; max 1000.
     * @param {number} [startTimeAtMillis] The timestamp specifies the earliest point in time for which data should be returned. The value is not included.
     * @param {number} [endTimeAtMillis] The timestamp specifies the latest point in time for which data should be returned. The value is included.
     * @param {number} [page] The page number to retrieve in a paginated response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExchangeApi
     */
    public getRecentTrades(symbol: string, tradeType?: TradeType, limit?: number, startTimeAtMillis?: number, endTimeAtMillis?: number, page?: number, options?: RawAxiosRequestConfig) {
        return ExchangeApiFp(this.configuration).getRecentTrades(symbol, tradeType, limit, startTimeAtMillis, endTimeAtMillis, page, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RewardsApi - axios parameter creator
 * @export
 */
export const RewardsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns detailed earnings breakdown for an affiliate by interval, ordered by interval number in descending order.
         * @summary /rewards/affiliate/intervalOverview
         * @param {string} userAddress The address of the user to get interval overview for
         * @param {number} [page] The page number to retrieve in a paginated response
         * @param {number} [limit] The page size for pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAffiliateIntervalOverview: async (userAddress: string, page?: number, limit?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userAddress' is not null or undefined
            assertParamExists('getAffiliateIntervalOverview', 'userAddress', userAddress)
            const localVarPath = `/v1/rewards/affiliate/intervalOverview`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (userAddress !== undefined) {
                localVarQueryParameter['userAddress'] = userAddress;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns rankings and earnings for affiliates, sorted by the specified category.
         * @summary /rewards/affiliate/leaderDashboard
         * @param {GetAffiliateLeaderDashboardSortByEnum} [sortBy] The category to sort rankings by
         * @param {GetAffiliateLeaderDashboardSortOrderEnum} [sortOrder] The order to sort rankings by
         * @param {number} [page] The page number to retrieve in a paginated response
         * @param {number} [limit] The page size for pagination
         * @param {string} [search] The name/address of the user to filter by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAffiliateLeaderDashboard: async (sortBy?: GetAffiliateLeaderDashboardSortByEnum, sortOrder?: GetAffiliateLeaderDashboardSortOrderEnum, page?: number, limit?: number, search?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/rewards/affiliate/leaderDashboard`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the affiliate metadata.
         * @summary /rewards/affiliate
         * @param {string} userAddress Specify wallet address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAffiliateMetadata: async (userAddress: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userAddress' is not null or undefined
            assertParamExists('getAffiliateMetadata', 'userAddress', userAddress)
            const localVarPath = `/v1/rewards/affiliate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (userAddress !== undefined) {
                localVarQueryParameter['userAddress'] = userAddress;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns detailed earnings breakdown for an affiliate users earnings (including perps, spot LP, lending), referral earnings, and total earnings.
         * @summary /rewards/affiliate/overview
         * @param {string} userAddress Specify wallet address.
         * @param {number} [page] The page number to retrieve in a paginated response
         * @param {number} [limit] The page size for pagination
         * @param {GetAffiliateOverviewSortByEnum} [sortBy] The category to sort earnings by
         * @param {GetAffiliateOverviewSortOrderEnum} [sortOrder] The order to sort earnings by
         * @param {string} [search] The name/address of the user to filter by
         * @param {string} [minEarningsE9] The minimum earnings to filter by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAffiliateOverview: async (userAddress: string, page?: number, limit?: number, sortBy?: GetAffiliateOverviewSortByEnum, sortOrder?: GetAffiliateOverviewSortOrderEnum, search?: string, minEarningsE9?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userAddress' is not null or undefined
            assertParamExists('getAffiliateOverview', 'userAddress', userAddress)
            const localVarPath = `/v1/rewards/affiliate/overview`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (sortBy !== undefined) {
                localVarQueryParameter['sortBy'] = sortBy;
            }

            if (sortOrder !== undefined) {
                localVarQueryParameter['sortOrder'] = sortOrder;
            }

            if (search !== undefined) {
                localVarQueryParameter['search'] = search;
            }

            if (userAddress !== undefined) {
                localVarQueryParameter['userAddress'] = userAddress;
            }

            if (minEarningsE9 !== undefined) {
                localVarQueryParameter['minEarningsE9'] = minEarningsE9;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns performance summary for an affiliate including total referrals, earnings, and rankings.
         * @summary /rewards/affiliate/summary
         * @param {string} userAddress Specify wallet address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAffiliateSummary: async (userAddress: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userAddress' is not null or undefined
            assertParamExists('getAffiliateSummary', 'userAddress', userAddress)
            const localVarPath = `/v1/rewards/affiliate/summary`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (userAddress !== undefined) {
                localVarQueryParameter['userAddress'] = userAddress;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the rewards earned by users for a specific campaign.
         * @summary /rewards/campaign
         * @param {string} campaignName Specify the campaign name
         * @param {string} userAddress Specify wallet address.
         * @param {number} [epochNumber] Optionally specify epoch number.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCampaignRewards: async (campaignName: string, userAddress: string, epochNumber?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'campaignName' is not null or undefined
            assertParamExists('getCampaignRewards', 'campaignName', campaignName)
            // verify required parameter 'userAddress' is not null or undefined
            assertParamExists('getCampaignRewards', 'userAddress', userAddress)
            const localVarPath = `/v1/rewards/campaign`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (campaignName !== undefined) {
                localVarQueryParameter['campaignName'] = campaignName;
            }

            if (epochNumber !== undefined) {
                localVarQueryParameter['epochNumber'] = epochNumber;
            }

            if (userAddress !== undefined) {
                localVarQueryParameter['userAddress'] = userAddress;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the rewards earned by users for the intervals.
         * @summary /rewards
         * @param {number} [intervalNumber] Optionally specify interval number.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRewards: async (intervalNumber?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/rewards`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (intervalNumber !== undefined) {
                localVarQueryParameter['intervalNumber'] = intervalNumber;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the metadata for the rewards campaigns.
         * @summary /rewards/metadata/campaign
         * @param {string} [campaignName] Specify the campaign name
         * @param {GetRewardsCampaignMetadataStatusEnum} [status] Optionally specify the status of the campaigns.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRewardsCampaignMetadata: async (campaignName?: string, status?: GetRewardsCampaignMetadataStatusEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/rewards/metadata/campaign`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (campaignName !== undefined) {
                localVarQueryParameter['campaignName'] = campaignName;
            }

            if (status !== undefined) {
                localVarQueryParameter['Status'] = status;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the latest epoch configs for the campaigns.
         * @summary /rewards/metadata/epoch/configs
         * @param {number} [intervalNumber] Specify the interval number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRewardsEpochConfigMetadata: async (intervalNumber?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/rewards/metadata/epoch/configs`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (intervalNumber !== undefined) {
                localVarQueryParameter['intervalNumber'] = intervalNumber;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the latest or next epoch epoch for campaign.
         * @summary /rewards/metadata/epoch
         * @param {string} [campaignName] Specify the campaign name
         * @param {GetRewardsEpochMetadataEpochEnum} [epoch] Specify the string \&quot;next\&quot; or \&quot;latest\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRewardsEpochMetadata: async (campaignName?: string, epoch?: GetRewardsEpochMetadataEpochEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/rewards/metadata/epoch`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (campaignName !== undefined) {
                localVarQueryParameter['campaignName'] = campaignName;
            }

            if (epoch !== undefined) {
                localVarQueryParameter['epoch'] = epoch;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the interval metadata for provided parameters.
         * @summary /rewards/metadata/interval
         * @param {number} [interval] Either specify an interval number or the string \&quot;next\&quot; or \&quot;latest\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRewardsIntervalMetadata: async (interval?: number, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/rewards/metadata/interval`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (interval !== undefined) {
                localVarQueryParameter['interval'] = interval;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the all time rewards earned by users.
         * @summary /rewards/summary
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRewardsSummary: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/v1/rewards/summary`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Submit an application to become an affiliate.
         * @summary /rewards/affiliate/onboard
         * @param {OnboardAffiliateRequest} onboardAffiliateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        onboardAffiliate: async (onboardAffiliateRequest: OnboardAffiliateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'onboardAffiliateRequest' is not null or undefined
            assertParamExists('onboardAffiliate', 'onboardAffiliateRequest', onboardAffiliateRequest)
            const localVarPath = `/v1/rewards/affiliate/onboard`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(onboardAffiliateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Onboard a referee with a referral code.
         * @summary /rewards/affiliate/onboard/referee
         * @param {OnboardRefereeRequest} onboardRefereeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        onboardReferee: async (onboardRefereeRequest: OnboardRefereeRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'onboardRefereeRequest' is not null or undefined
            assertParamExists('onboardReferee', 'onboardRefereeRequest', onboardRefereeRequest)
            const localVarPath = `/v1/rewards/affiliate/onboard/referee`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(onboardRefereeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the ember refferal share for an affiliate.
         * @summary /rewards/affiliate/emberRefferalShare
         * @param {UpdateAffiliateEmberRefferalShareRequest} updateAffiliateEmberRefferalShareRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAffiliateEmberRefferalShare: async (updateAffiliateEmberRefferalShareRequest: UpdateAffiliateEmberRefferalShareRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateAffiliateEmberRefferalShareRequest' is not null or undefined
            assertParamExists('updateAffiliateEmberRefferalShare', 'updateAffiliateEmberRefferalShareRequest', updateAffiliateEmberRefferalShareRequest)
            const localVarPath = `/v1/rewards/affiliate/emberRefferalShare`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateAffiliateEmberRefferalShareRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Update the fee config for an affiliate.
         * @summary /rewards/affiliate/feeConfig
         * @param {UpdateAffiliateFeeConfigRequest} updateAffiliateFeeConfigRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAffiliateFeeConfig: async (updateAffiliateFeeConfigRequest: UpdateAffiliateFeeConfigRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateAffiliateFeeConfigRequest' is not null or undefined
            assertParamExists('updateAffiliateFeeConfig', 'updateAffiliateFeeConfigRequest', updateAffiliateFeeConfigRequest)
            const localVarPath = `/v1/rewards/affiliate/feeConfig`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateAffiliateFeeConfigRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RewardsApi - functional programming interface
 * @export
 */
export const RewardsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RewardsApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns detailed earnings breakdown for an affiliate by interval, ordered by interval number in descending order.
         * @summary /rewards/affiliate/intervalOverview
         * @param {string} userAddress The address of the user to get interval overview for
         * @param {number} [page] The page number to retrieve in a paginated response
         * @param {number} [limit] The page size for pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAffiliateIntervalOverview(userAddress: string, page?: number, limit?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAffiliateIntervalOverview200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAffiliateIntervalOverview(userAddress, page, limit, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RewardsApi.getAffiliateIntervalOverview']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns rankings and earnings for affiliates, sorted by the specified category.
         * @summary /rewards/affiliate/leaderDashboard
         * @param {GetAffiliateLeaderDashboardSortByEnum} [sortBy] The category to sort rankings by
         * @param {GetAffiliateLeaderDashboardSortOrderEnum} [sortOrder] The order to sort rankings by
         * @param {number} [page] The page number to retrieve in a paginated response
         * @param {number} [limit] The page size for pagination
         * @param {string} [search] The name/address of the user to filter by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAffiliateLeaderDashboard(sortBy?: GetAffiliateLeaderDashboardSortByEnum, sortOrder?: GetAffiliateLeaderDashboardSortOrderEnum, page?: number, limit?: number, search?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAffiliateLeaderDashboard200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAffiliateLeaderDashboard(sortBy, sortOrder, page, limit, search, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RewardsApi.getAffiliateLeaderDashboard']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the affiliate metadata.
         * @summary /rewards/affiliate
         * @param {string} userAddress Specify wallet address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAffiliateMetadata(userAddress: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AffiliateMetadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAffiliateMetadata(userAddress, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RewardsApi.getAffiliateMetadata']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns detailed earnings breakdown for an affiliate users earnings (including perps, spot LP, lending), referral earnings, and total earnings.
         * @summary /rewards/affiliate/overview
         * @param {string} userAddress Specify wallet address.
         * @param {number} [page] The page number to retrieve in a paginated response
         * @param {number} [limit] The page size for pagination
         * @param {GetAffiliateOverviewSortByEnum} [sortBy] The category to sort earnings by
         * @param {GetAffiliateOverviewSortOrderEnum} [sortOrder] The order to sort earnings by
         * @param {string} [search] The name/address of the user to filter by
         * @param {string} [minEarningsE9] The minimum earnings to filter by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAffiliateOverview(userAddress: string, page?: number, limit?: number, sortBy?: GetAffiliateOverviewSortByEnum, sortOrder?: GetAffiliateOverviewSortOrderEnum, search?: string, minEarningsE9?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAffiliateOverview200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAffiliateOverview(userAddress, page, limit, sortBy, sortOrder, search, minEarningsE9, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RewardsApi.getAffiliateOverview']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns performance summary for an affiliate including total referrals, earnings, and rankings.
         * @summary /rewards/affiliate/summary
         * @param {string} userAddress Specify wallet address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAffiliateSummary(userAddress: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AffiliateSummary>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAffiliateSummary(userAddress, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RewardsApi.getAffiliateSummary']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the rewards earned by users for a specific campaign.
         * @summary /rewards/campaign
         * @param {string} campaignName Specify the campaign name
         * @param {string} userAddress Specify wallet address.
         * @param {number} [epochNumber] Optionally specify epoch number.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCampaignRewards(campaignName: string, userAddress: string, epochNumber?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserCampaignRewards>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCampaignRewards(campaignName, userAddress, epochNumber, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RewardsApi.getCampaignRewards']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the rewards earned by users for the intervals.
         * @summary /rewards
         * @param {number} [intervalNumber] Optionally specify interval number.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRewards(intervalNumber?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<IntervalRewards>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRewards(intervalNumber, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RewardsApi.getRewards']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the metadata for the rewards campaigns.
         * @summary /rewards/metadata/campaign
         * @param {string} [campaignName] Specify the campaign name
         * @param {GetRewardsCampaignMetadataStatusEnum} [status] Optionally specify the status of the campaigns.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRewardsCampaignMetadata(campaignName?: string, status?: GetRewardsCampaignMetadataStatusEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<CampaignMetadata>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRewardsCampaignMetadata(campaignName, status, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RewardsApi.getRewardsCampaignMetadata']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the latest epoch configs for the campaigns.
         * @summary /rewards/metadata/epoch/configs
         * @param {number} [intervalNumber] Specify the interval number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRewardsEpochConfigMetadata(intervalNumber?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EpochConfigsResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRewardsEpochConfigMetadata(intervalNumber, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RewardsApi.getRewardsEpochConfigMetadata']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the latest or next epoch epoch for campaign.
         * @summary /rewards/metadata/epoch
         * @param {string} [campaignName] Specify the campaign name
         * @param {GetRewardsEpochMetadataEpochEnum} [epoch] Specify the string \&quot;next\&quot; or \&quot;latest\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRewardsEpochMetadata(campaignName?: string, epoch?: GetRewardsEpochMetadataEpochEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<EpochMetadata>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRewardsEpochMetadata(campaignName, epoch, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RewardsApi.getRewardsEpochMetadata']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the interval metadata for provided parameters.
         * @summary /rewards/metadata/interval
         * @param {number} [interval] Either specify an interval number or the string \&quot;next\&quot; or \&quot;latest\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRewardsIntervalMetadata(interval?: number, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<IntervalMetadata>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRewardsIntervalMetadata(interval, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RewardsApi.getRewardsIntervalMetadata']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Returns the all time rewards earned by users.
         * @summary /rewards/summary
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRewardsSummary(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RewardsSummary>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRewardsSummary(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RewardsApi.getRewardsSummary']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Submit an application to become an affiliate.
         * @summary /rewards/affiliate/onboard
         * @param {OnboardAffiliateRequest} onboardAffiliateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async onboardAffiliate(onboardAffiliateRequest: OnboardAffiliateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AffiliateOnboardResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.onboardAffiliate(onboardAffiliateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RewardsApi.onboardAffiliate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Onboard a referee with a referral code.
         * @summary /rewards/affiliate/onboard/referee
         * @param {OnboardRefereeRequest} onboardRefereeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async onboardReferee(onboardRefereeRequest: OnboardRefereeRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RefereeOnboardResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.onboardReferee(onboardRefereeRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RewardsApi.onboardReferee']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update the ember refferal share for an affiliate.
         * @summary /rewards/affiliate/emberRefferalShare
         * @param {UpdateAffiliateEmberRefferalShareRequest} updateAffiliateEmberRefferalShareRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAffiliateEmberRefferalShare(updateAffiliateEmberRefferalShareRequest: UpdateAffiliateEmberRefferalShareRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AffiliateMetadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAffiliateEmberRefferalShare(updateAffiliateEmberRefferalShareRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RewardsApi.updateAffiliateEmberRefferalShare']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Update the fee config for an affiliate.
         * @summary /rewards/affiliate/feeConfig
         * @param {UpdateAffiliateFeeConfigRequest} updateAffiliateFeeConfigRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAffiliateFeeConfig(updateAffiliateFeeConfigRequest: UpdateAffiliateFeeConfigRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AffiliateMetadata>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAffiliateFeeConfig(updateAffiliateFeeConfigRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RewardsApi.updateAffiliateFeeConfig']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RewardsApi - factory interface
 * @export
 */
export const RewardsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RewardsApiFp(configuration)
    return {
        /**
         * Returns detailed earnings breakdown for an affiliate by interval, ordered by interval number in descending order.
         * @summary /rewards/affiliate/intervalOverview
         * @param {string} userAddress The address of the user to get interval overview for
         * @param {number} [page] The page number to retrieve in a paginated response
         * @param {number} [limit] The page size for pagination
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAffiliateIntervalOverview(userAddress: string, page?: number, limit?: number, options?: RawAxiosRequestConfig): AxiosPromise<GetAffiliateIntervalOverview200Response> {
            return localVarFp.getAffiliateIntervalOverview(userAddress, page, limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns rankings and earnings for affiliates, sorted by the specified category.
         * @summary /rewards/affiliate/leaderDashboard
         * @param {GetAffiliateLeaderDashboardSortByEnum} [sortBy] The category to sort rankings by
         * @param {GetAffiliateLeaderDashboardSortOrderEnum} [sortOrder] The order to sort rankings by
         * @param {number} [page] The page number to retrieve in a paginated response
         * @param {number} [limit] The page size for pagination
         * @param {string} [search] The name/address of the user to filter by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAffiliateLeaderDashboard(sortBy?: GetAffiliateLeaderDashboardSortByEnum, sortOrder?: GetAffiliateLeaderDashboardSortOrderEnum, page?: number, limit?: number, search?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetAffiliateLeaderDashboard200Response> {
            return localVarFp.getAffiliateLeaderDashboard(sortBy, sortOrder, page, limit, search, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the affiliate metadata.
         * @summary /rewards/affiliate
         * @param {string} userAddress Specify wallet address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAffiliateMetadata(userAddress: string, options?: RawAxiosRequestConfig): AxiosPromise<AffiliateMetadata> {
            return localVarFp.getAffiliateMetadata(userAddress, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns detailed earnings breakdown for an affiliate users earnings (including perps, spot LP, lending), referral earnings, and total earnings.
         * @summary /rewards/affiliate/overview
         * @param {string} userAddress Specify wallet address.
         * @param {number} [page] The page number to retrieve in a paginated response
         * @param {number} [limit] The page size for pagination
         * @param {GetAffiliateOverviewSortByEnum} [sortBy] The category to sort earnings by
         * @param {GetAffiliateOverviewSortOrderEnum} [sortOrder] The order to sort earnings by
         * @param {string} [search] The name/address of the user to filter by
         * @param {string} [minEarningsE9] The minimum earnings to filter by
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAffiliateOverview(userAddress: string, page?: number, limit?: number, sortBy?: GetAffiliateOverviewSortByEnum, sortOrder?: GetAffiliateOverviewSortOrderEnum, search?: string, minEarningsE9?: string, options?: RawAxiosRequestConfig): AxiosPromise<GetAffiliateOverview200Response> {
            return localVarFp.getAffiliateOverview(userAddress, page, limit, sortBy, sortOrder, search, minEarningsE9, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns performance summary for an affiliate including total referrals, earnings, and rankings.
         * @summary /rewards/affiliate/summary
         * @param {string} userAddress Specify wallet address.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAffiliateSummary(userAddress: string, options?: RawAxiosRequestConfig): AxiosPromise<AffiliateSummary> {
            return localVarFp.getAffiliateSummary(userAddress, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the rewards earned by users for a specific campaign.
         * @summary /rewards/campaign
         * @param {string} campaignName Specify the campaign name
         * @param {string} userAddress Specify wallet address.
         * @param {number} [epochNumber] Optionally specify epoch number.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCampaignRewards(campaignName: string, userAddress: string, epochNumber?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<UserCampaignRewards>> {
            return localVarFp.getCampaignRewards(campaignName, userAddress, epochNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the rewards earned by users for the intervals.
         * @summary /rewards
         * @param {number} [intervalNumber] Optionally specify interval number.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRewards(intervalNumber?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<IntervalRewards>> {
            return localVarFp.getRewards(intervalNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the metadata for the rewards campaigns.
         * @summary /rewards/metadata/campaign
         * @param {string} [campaignName] Specify the campaign name
         * @param {GetRewardsCampaignMetadataStatusEnum} [status] Optionally specify the status of the campaigns.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRewardsCampaignMetadata(campaignName?: string, status?: GetRewardsCampaignMetadataStatusEnum, options?: RawAxiosRequestConfig): AxiosPromise<Array<CampaignMetadata>> {
            return localVarFp.getRewardsCampaignMetadata(campaignName, status, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the latest epoch configs for the campaigns.
         * @summary /rewards/metadata/epoch/configs
         * @param {number} [intervalNumber] Specify the interval number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRewardsEpochConfigMetadata(intervalNumber?: number, options?: RawAxiosRequestConfig): AxiosPromise<EpochConfigsResponse> {
            return localVarFp.getRewardsEpochConfigMetadata(intervalNumber, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the latest or next epoch epoch for campaign.
         * @summary /rewards/metadata/epoch
         * @param {string} [campaignName] Specify the campaign name
         * @param {GetRewardsEpochMetadataEpochEnum} [epoch] Specify the string \&quot;next\&quot; or \&quot;latest\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRewardsEpochMetadata(campaignName?: string, epoch?: GetRewardsEpochMetadataEpochEnum, options?: RawAxiosRequestConfig): AxiosPromise<Array<EpochMetadata>> {
            return localVarFp.getRewardsEpochMetadata(campaignName, epoch, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the interval metadata for provided parameters.
         * @summary /rewards/metadata/interval
         * @param {number} [interval] Either specify an interval number or the string \&quot;next\&quot; or \&quot;latest\&quot;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRewardsIntervalMetadata(interval?: number, options?: RawAxiosRequestConfig): AxiosPromise<Array<IntervalMetadata>> {
            return localVarFp.getRewardsIntervalMetadata(interval, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the all time rewards earned by users.
         * @summary /rewards/summary
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRewardsSummary(options?: RawAxiosRequestConfig): AxiosPromise<Array<RewardsSummary>> {
            return localVarFp.getRewardsSummary(options).then((request) => request(axios, basePath));
        },
        /**
         * Submit an application to become an affiliate.
         * @summary /rewards/affiliate/onboard
         * @param {OnboardAffiliateRequest} onboardAffiliateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        onboardAffiliate(onboardAffiliateRequest: OnboardAffiliateRequest, options?: RawAxiosRequestConfig): AxiosPromise<AffiliateOnboardResponse> {
            return localVarFp.onboardAffiliate(onboardAffiliateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Onboard a referee with a referral code.
         * @summary /rewards/affiliate/onboard/referee
         * @param {OnboardRefereeRequest} onboardRefereeRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        onboardReferee(onboardRefereeRequest: OnboardRefereeRequest, options?: RawAxiosRequestConfig): AxiosPromise<RefereeOnboardResponse> {
            return localVarFp.onboardReferee(onboardRefereeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the ember refferal share for an affiliate.
         * @summary /rewards/affiliate/emberRefferalShare
         * @param {UpdateAffiliateEmberRefferalShareRequest} updateAffiliateEmberRefferalShareRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAffiliateEmberRefferalShare(updateAffiliateEmberRefferalShareRequest: UpdateAffiliateEmberRefferalShareRequest, options?: RawAxiosRequestConfig): AxiosPromise<AffiliateMetadata> {
            return localVarFp.updateAffiliateEmberRefferalShare(updateAffiliateEmberRefferalShareRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Update the fee config for an affiliate.
         * @summary /rewards/affiliate/feeConfig
         * @param {UpdateAffiliateFeeConfigRequest} updateAffiliateFeeConfigRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAffiliateFeeConfig(updateAffiliateFeeConfigRequest: UpdateAffiliateFeeConfigRequest, options?: RawAxiosRequestConfig): AxiosPromise<AffiliateMetadata> {
            return localVarFp.updateAffiliateFeeConfig(updateAffiliateFeeConfigRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RewardsApi - object-oriented interface
 * @export
 * @class RewardsApi
 * @extends {BaseAPI}
 */
export class RewardsApi extends BaseAPI {
    /**
     * Returns detailed earnings breakdown for an affiliate by interval, ordered by interval number in descending order.
     * @summary /rewards/affiliate/intervalOverview
     * @param {string} userAddress The address of the user to get interval overview for
     * @param {number} [page] The page number to retrieve in a paginated response
     * @param {number} [limit] The page size for pagination
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RewardsApi
     */
    public getAffiliateIntervalOverview(userAddress: string, page?: number, limit?: number, options?: RawAxiosRequestConfig) {
        return RewardsApiFp(this.configuration).getAffiliateIntervalOverview(userAddress, page, limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns rankings and earnings for affiliates, sorted by the specified category.
     * @summary /rewards/affiliate/leaderDashboard
     * @param {GetAffiliateLeaderDashboardSortByEnum} [sortBy] The category to sort rankings by
     * @param {GetAffiliateLeaderDashboardSortOrderEnum} [sortOrder] The order to sort rankings by
     * @param {number} [page] The page number to retrieve in a paginated response
     * @param {number} [limit] The page size for pagination
     * @param {string} [search] The name/address of the user to filter by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RewardsApi
     */
    public getAffiliateLeaderDashboard(sortBy?: GetAffiliateLeaderDashboardSortByEnum, sortOrder?: GetAffiliateLeaderDashboardSortOrderEnum, page?: number, limit?: number, search?: string, options?: RawAxiosRequestConfig) {
        return RewardsApiFp(this.configuration).getAffiliateLeaderDashboard(sortBy, sortOrder, page, limit, search, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the affiliate metadata.
     * @summary /rewards/affiliate
     * @param {string} userAddress Specify wallet address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RewardsApi
     */
    public getAffiliateMetadata(userAddress: string, options?: RawAxiosRequestConfig) {
        return RewardsApiFp(this.configuration).getAffiliateMetadata(userAddress, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns detailed earnings breakdown for an affiliate users earnings (including perps, spot LP, lending), referral earnings, and total earnings.
     * @summary /rewards/affiliate/overview
     * @param {string} userAddress Specify wallet address.
     * @param {number} [page] The page number to retrieve in a paginated response
     * @param {number} [limit] The page size for pagination
     * @param {GetAffiliateOverviewSortByEnum} [sortBy] The category to sort earnings by
     * @param {GetAffiliateOverviewSortOrderEnum} [sortOrder] The order to sort earnings by
     * @param {string} [search] The name/address of the user to filter by
     * @param {string} [minEarningsE9] The minimum earnings to filter by
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RewardsApi
     */
    public getAffiliateOverview(userAddress: string, page?: number, limit?: number, sortBy?: GetAffiliateOverviewSortByEnum, sortOrder?: GetAffiliateOverviewSortOrderEnum, search?: string, minEarningsE9?: string, options?: RawAxiosRequestConfig) {
        return RewardsApiFp(this.configuration).getAffiliateOverview(userAddress, page, limit, sortBy, sortOrder, search, minEarningsE9, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns performance summary for an affiliate including total referrals, earnings, and rankings.
     * @summary /rewards/affiliate/summary
     * @param {string} userAddress Specify wallet address.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RewardsApi
     */
    public getAffiliateSummary(userAddress: string, options?: RawAxiosRequestConfig) {
        return RewardsApiFp(this.configuration).getAffiliateSummary(userAddress, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the rewards earned by users for a specific campaign.
     * @summary /rewards/campaign
     * @param {string} campaignName Specify the campaign name
     * @param {string} userAddress Specify wallet address.
     * @param {number} [epochNumber] Optionally specify epoch number.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RewardsApi
     */
    public getCampaignRewards(campaignName: string, userAddress: string, epochNumber?: number, options?: RawAxiosRequestConfig) {
        return RewardsApiFp(this.configuration).getCampaignRewards(campaignName, userAddress, epochNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the rewards earned by users for the intervals.
     * @summary /rewards
     * @param {number} [intervalNumber] Optionally specify interval number.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RewardsApi
     */
    public getRewards(intervalNumber?: number, options?: RawAxiosRequestConfig) {
        return RewardsApiFp(this.configuration).getRewards(intervalNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the metadata for the rewards campaigns.
     * @summary /rewards/metadata/campaign
     * @param {string} [campaignName] Specify the campaign name
     * @param {GetRewardsCampaignMetadataStatusEnum} [status] Optionally specify the status of the campaigns.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RewardsApi
     */
    public getRewardsCampaignMetadata(campaignName?: string, status?: GetRewardsCampaignMetadataStatusEnum, options?: RawAxiosRequestConfig) {
        return RewardsApiFp(this.configuration).getRewardsCampaignMetadata(campaignName, status, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the latest epoch configs for the campaigns.
     * @summary /rewards/metadata/epoch/configs
     * @param {number} [intervalNumber] Specify the interval number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RewardsApi
     */
    public getRewardsEpochConfigMetadata(intervalNumber?: number, options?: RawAxiosRequestConfig) {
        return RewardsApiFp(this.configuration).getRewardsEpochConfigMetadata(intervalNumber, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the latest or next epoch epoch for campaign.
     * @summary /rewards/metadata/epoch
     * @param {string} [campaignName] Specify the campaign name
     * @param {GetRewardsEpochMetadataEpochEnum} [epoch] Specify the string \&quot;next\&quot; or \&quot;latest\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RewardsApi
     */
    public getRewardsEpochMetadata(campaignName?: string, epoch?: GetRewardsEpochMetadataEpochEnum, options?: RawAxiosRequestConfig) {
        return RewardsApiFp(this.configuration).getRewardsEpochMetadata(campaignName, epoch, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the interval metadata for provided parameters.
     * @summary /rewards/metadata/interval
     * @param {number} [interval] Either specify an interval number or the string \&quot;next\&quot; or \&quot;latest\&quot;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RewardsApi
     */
    public getRewardsIntervalMetadata(interval?: number, options?: RawAxiosRequestConfig) {
        return RewardsApiFp(this.configuration).getRewardsIntervalMetadata(interval, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the all time rewards earned by users.
     * @summary /rewards/summary
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RewardsApi
     */
    public getRewardsSummary(options?: RawAxiosRequestConfig) {
        return RewardsApiFp(this.configuration).getRewardsSummary(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Submit an application to become an affiliate.
     * @summary /rewards/affiliate/onboard
     * @param {OnboardAffiliateRequest} onboardAffiliateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RewardsApi
     */
    public onboardAffiliate(onboardAffiliateRequest: OnboardAffiliateRequest, options?: RawAxiosRequestConfig) {
        return RewardsApiFp(this.configuration).onboardAffiliate(onboardAffiliateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Onboard a referee with a referral code.
     * @summary /rewards/affiliate/onboard/referee
     * @param {OnboardRefereeRequest} onboardRefereeRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RewardsApi
     */
    public onboardReferee(onboardRefereeRequest: OnboardRefereeRequest, options?: RawAxiosRequestConfig) {
        return RewardsApiFp(this.configuration).onboardReferee(onboardRefereeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the ember refferal share for an affiliate.
     * @summary /rewards/affiliate/emberRefferalShare
     * @param {UpdateAffiliateEmberRefferalShareRequest} updateAffiliateEmberRefferalShareRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RewardsApi
     */
    public updateAffiliateEmberRefferalShare(updateAffiliateEmberRefferalShareRequest: UpdateAffiliateEmberRefferalShareRequest, options?: RawAxiosRequestConfig) {
        return RewardsApiFp(this.configuration).updateAffiliateEmberRefferalShare(updateAffiliateEmberRefferalShareRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Update the fee config for an affiliate.
     * @summary /rewards/affiliate/feeConfig
     * @param {UpdateAffiliateFeeConfigRequest} updateAffiliateFeeConfigRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RewardsApi
     */
    public updateAffiliateFeeConfig(updateAffiliateFeeConfigRequest: UpdateAffiliateFeeConfigRequest, options?: RawAxiosRequestConfig) {
        return RewardsApiFp(this.configuration).updateAffiliateFeeConfig(updateAffiliateFeeConfigRequest, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const GetAffiliateLeaderDashboardSortByEnum = {
    PerpsRank: 'perpsRank',
    LendingRank: 'lendingRank',
    SpotRank: 'spotRank'
} as const;
export type GetAffiliateLeaderDashboardSortByEnum = typeof GetAffiliateLeaderDashboardSortByEnum[keyof typeof GetAffiliateLeaderDashboardSortByEnum];
/**
 * @export
 */
export const GetAffiliateLeaderDashboardSortOrderEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type GetAffiliateLeaderDashboardSortOrderEnum = typeof GetAffiliateLeaderDashboardSortOrderEnum[keyof typeof GetAffiliateLeaderDashboardSortOrderEnum];
/**
 * @export
 */
export const GetAffiliateOverviewSortByEnum = {
    RefreeEarnings: 'refreeEarnings',
    ReferralEarnings: 'referralEarnings',
    TotalEarnings: 'totalEarnings'
} as const;
export type GetAffiliateOverviewSortByEnum = typeof GetAffiliateOverviewSortByEnum[keyof typeof GetAffiliateOverviewSortByEnum];
/**
 * @export
 */
export const GetAffiliateOverviewSortOrderEnum = {
    Asc: 'asc',
    Desc: 'desc'
} as const;
export type GetAffiliateOverviewSortOrderEnum = typeof GetAffiliateOverviewSortOrderEnum[keyof typeof GetAffiliateOverviewSortOrderEnum];
/**
 * @export
 */
export const GetRewardsCampaignMetadataStatusEnum = {
    Active: 'ACTIVE',
    Inactive: 'INACTIVE'
} as const;
export type GetRewardsCampaignMetadataStatusEnum = typeof GetRewardsCampaignMetadataStatusEnum[keyof typeof GetRewardsCampaignMetadataStatusEnum];
/**
 * @export
 */
export const GetRewardsEpochMetadataEpochEnum = {
    Next: 'next',
    Latest: 'latest'
} as const;
export type GetRewardsEpochMetadataEpochEnum = typeof GetRewardsEpochMetadataEpochEnum[keyof typeof GetRewardsEpochMetadataEpochEnum];


/**
 * StreamsApi - axios parameter creator
 * @export
 */
export const StreamsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * WebSocket Account Streams URL.
         * @param {string} authorization 
         * @param {WebSocketAccountDataUpgradeEnum} upgrade 
         * @param {string} secWebSocketKey WebSocket key used during the handshake.
         * @param {WebSocketAccountDataSecWebSocketVersionEnum} secWebSocketVersion WebSocket protocol version.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webSocketAccountData: async (authorization: string, upgrade: WebSocketAccountDataUpgradeEnum, secWebSocketKey: string, secWebSocketVersion: WebSocketAccountDataSecWebSocketVersionEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'authorization' is not null or undefined
            assertParamExists('webSocketAccountData', 'authorization', authorization)
            // verify required parameter 'upgrade' is not null or undefined
            assertParamExists('webSocketAccountData', 'upgrade', upgrade)
            // verify required parameter 'secWebSocketKey' is not null or undefined
            assertParamExists('webSocketAccountData', 'secWebSocketKey', secWebSocketKey)
            // verify required parameter 'secWebSocketVersion' is not null or undefined
            assertParamExists('webSocketAccountData', 'secWebSocketVersion', secWebSocketVersion)
            const localVarPath = `/ws/account`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            if (authorization != null) {
                localVarHeaderParameter['Authorization'] = String(authorization);
            }
            if (upgrade != null) {
                localVarHeaderParameter['Upgrade'] = String(upgrade);
            }
            if (secWebSocketKey != null) {
                localVarHeaderParameter['Sec-WebSocket-Key'] = String(secWebSocketKey);
            }
            if (secWebSocketVersion != null) {
                localVarHeaderParameter['Sec-WebSocket-Version'] = String(secWebSocketVersion);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * WebSocket Market Streams URL.
         * @param {WebSocketMarketDataUpgradeEnum} upgrade 
         * @param {string} secWebSocketKey WebSocket key used during the handshake.
         * @param {WebSocketMarketDataSecWebSocketVersionEnum} secWebSocketVersion WebSocket protocol version.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webSocketMarketData: async (upgrade: WebSocketMarketDataUpgradeEnum, secWebSocketKey: string, secWebSocketVersion: WebSocketMarketDataSecWebSocketVersionEnum, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'upgrade' is not null or undefined
            assertParamExists('webSocketMarketData', 'upgrade', upgrade)
            // verify required parameter 'secWebSocketKey' is not null or undefined
            assertParamExists('webSocketMarketData', 'secWebSocketKey', secWebSocketKey)
            // verify required parameter 'secWebSocketVersion' is not null or undefined
            assertParamExists('webSocketMarketData', 'secWebSocketVersion', secWebSocketVersion)
            const localVarPath = `/ws/market`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            if (upgrade != null) {
                localVarHeaderParameter['Upgrade'] = String(upgrade);
            }
            if (secWebSocketKey != null) {
                localVarHeaderParameter['Sec-WebSocket-Key'] = String(secWebSocketKey);
            }
            if (secWebSocketVersion != null) {
                localVarHeaderParameter['Sec-WebSocket-Version'] = String(secWebSocketVersion);
            }
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StreamsApi - functional programming interface
 * @export
 */
export const StreamsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = StreamsApiAxiosParamCreator(configuration)
    return {
        /**
         * WebSocket Account Streams URL.
         * @param {string} authorization 
         * @param {WebSocketAccountDataUpgradeEnum} upgrade 
         * @param {string} secWebSocketKey WebSocket key used during the handshake.
         * @param {WebSocketAccountDataSecWebSocketVersionEnum} secWebSocketVersion WebSocket protocol version.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webSocketAccountData(authorization: string, upgrade: WebSocketAccountDataUpgradeEnum, secWebSocketKey: string, secWebSocketVersion: WebSocketAccountDataSecWebSocketVersionEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webSocketAccountData(authorization, upgrade, secWebSocketKey, secWebSocketVersion, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StreamsApi.webSocketAccountData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * WebSocket Market Streams URL.
         * @param {WebSocketMarketDataUpgradeEnum} upgrade 
         * @param {string} secWebSocketKey WebSocket key used during the handshake.
         * @param {WebSocketMarketDataSecWebSocketVersionEnum} secWebSocketVersion WebSocket protocol version.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async webSocketMarketData(upgrade: WebSocketMarketDataUpgradeEnum, secWebSocketKey: string, secWebSocketVersion: WebSocketMarketDataSecWebSocketVersionEnum, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.webSocketMarketData(upgrade, secWebSocketKey, secWebSocketVersion, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['StreamsApi.webSocketMarketData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * StreamsApi - factory interface
 * @export
 */
export const StreamsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = StreamsApiFp(configuration)
    return {
        /**
         * WebSocket Account Streams URL.
         * @param {string} authorization 
         * @param {WebSocketAccountDataUpgradeEnum} upgrade 
         * @param {string} secWebSocketKey WebSocket key used during the handshake.
         * @param {WebSocketAccountDataSecWebSocketVersionEnum} secWebSocketVersion WebSocket protocol version.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webSocketAccountData(authorization: string, upgrade: WebSocketAccountDataUpgradeEnum, secWebSocketKey: string, secWebSocketVersion: WebSocketAccountDataSecWebSocketVersionEnum, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.webSocketAccountData(authorization, upgrade, secWebSocketKey, secWebSocketVersion, options).then((request) => request(axios, basePath));
        },
        /**
         * WebSocket Market Streams URL.
         * @param {WebSocketMarketDataUpgradeEnum} upgrade 
         * @param {string} secWebSocketKey WebSocket key used during the handshake.
         * @param {WebSocketMarketDataSecWebSocketVersionEnum} secWebSocketVersion WebSocket protocol version.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        webSocketMarketData(upgrade: WebSocketMarketDataUpgradeEnum, secWebSocketKey: string, secWebSocketVersion: WebSocketMarketDataSecWebSocketVersionEnum, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.webSocketMarketData(upgrade, secWebSocketKey, secWebSocketVersion, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * StreamsApi - object-oriented interface
 * @export
 * @class StreamsApi
 * @extends {BaseAPI}
 */
export class StreamsApi extends BaseAPI {
    /**
     * WebSocket Account Streams URL.
     * @param {string} authorization 
     * @param {WebSocketAccountDataUpgradeEnum} upgrade 
     * @param {string} secWebSocketKey WebSocket key used during the handshake.
     * @param {WebSocketAccountDataSecWebSocketVersionEnum} secWebSocketVersion WebSocket protocol version.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StreamsApi
     */
    public webSocketAccountData(authorization: string, upgrade: WebSocketAccountDataUpgradeEnum, secWebSocketKey: string, secWebSocketVersion: WebSocketAccountDataSecWebSocketVersionEnum, options?: RawAxiosRequestConfig) {
        return StreamsApiFp(this.configuration).webSocketAccountData(authorization, upgrade, secWebSocketKey, secWebSocketVersion, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * WebSocket Market Streams URL.
     * @param {WebSocketMarketDataUpgradeEnum} upgrade 
     * @param {string} secWebSocketKey WebSocket key used during the handshake.
     * @param {WebSocketMarketDataSecWebSocketVersionEnum} secWebSocketVersion WebSocket protocol version.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StreamsApi
     */
    public webSocketMarketData(upgrade: WebSocketMarketDataUpgradeEnum, secWebSocketKey: string, secWebSocketVersion: WebSocketMarketDataSecWebSocketVersionEnum, options?: RawAxiosRequestConfig) {
        return StreamsApiFp(this.configuration).webSocketMarketData(upgrade, secWebSocketKey, secWebSocketVersion, options).then((request) => request(this.axios, this.basePath));
    }
}

/**
 * @export
 */
export const WebSocketAccountDataUpgradeEnum = {
    Websocket: 'websocket'
} as const;
export type WebSocketAccountDataUpgradeEnum = typeof WebSocketAccountDataUpgradeEnum[keyof typeof WebSocketAccountDataUpgradeEnum];
/**
 * @export
 */
export const WebSocketAccountDataSecWebSocketVersionEnum = {
    _13: '13'
} as const;
export type WebSocketAccountDataSecWebSocketVersionEnum = typeof WebSocketAccountDataSecWebSocketVersionEnum[keyof typeof WebSocketAccountDataSecWebSocketVersionEnum];
/**
 * @export
 */
export const WebSocketMarketDataUpgradeEnum = {
    Websocket: 'websocket'
} as const;
export type WebSocketMarketDataUpgradeEnum = typeof WebSocketMarketDataUpgradeEnum[keyof typeof WebSocketMarketDataUpgradeEnum];
/**
 * @export
 */
export const WebSocketMarketDataSecWebSocketVersionEnum = {
    _13: '13'
} as const;
export type WebSocketMarketDataSecWebSocketVersionEnum = typeof WebSocketMarketDataSecWebSocketVersionEnum[keyof typeof WebSocketMarketDataSecWebSocketVersionEnum];


/**
 * TradeApi - axios parameter creator
 * @export
 */
export const TradeApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Cancel orders for a market using order hashes. - May be a single order hash or a list of order hashes. - All orders must belong to the same account. - If no order hashes are specified, then will cancel all orders for the given market  - All orders being cancelled by request will receive the same time priority. 
         * @summary /trade/orders/cancel
         * @param {CancelOrdersRequest} cancelOrdersRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelOrders: async (cancelOrdersRequest: CancelOrdersRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cancelOrdersRequest' is not null or undefined
            assertParamExists('cancelOrders', 'cancelOrdersRequest', cancelOrdersRequest)
            const localVarPath = `/api/v1/trade/orders/cancel`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cancelOrdersRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Cancel orders in standby for a market using order hashes. - May be a single order hash or a list of order hashes. - All orders must belong to the same account. - If no order hashes are specified, then will cancel all orders for the given market - All orders being cancelled by request will receive the same time priority. 
         * @summary /trade/orders/cancel/standby
         * @param {CancelOrdersRequest} cancelOrdersRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelStandbyOrders: async (cancelOrdersRequest: CancelOrdersRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cancelOrdersRequest' is not null or undefined
            assertParamExists('cancelStandbyOrders', 'cancelOrdersRequest', cancelOrdersRequest)
            const localVarPath = `/api/v1/trade/orders/cancel/standby`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cancelOrdersRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve details of open orders for a specific account.
         * @summary /trade/openOrders
         * @param {string} [symbol] Filter by specific perpetual symbol (optional)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpenOrders: async (symbol?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/trade/openOrders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve details of orders in standby for a specific account.
         * @summary /trade/standbyOrders
         * @param {string} [symbol] Filter by specific perpetual symbol (optional)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStandbyOrders: async (symbol?: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/trade/standbyOrders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)

            if (symbol !== undefined) {
                localVarQueryParameter['symbol'] = symbol;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Submit a new order for execution.
         * @summary /trade/orders
         * @param {CreateOrderRequest} createOrderRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCreateOrder: async (createOrderRequest: CreateOrderRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createOrderRequest' is not null or undefined
            assertParamExists('postCreateOrder', 'createOrderRequest', createOrderRequest)
            const localVarPath = `/api/v1/trade/orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createOrderRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Initiates a withdraw action to remove some amount of funds from a user\'s account.
         * @summary /trade/withdraw
         * @param {WithdrawRequest} withdrawRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postWithdraw: async (withdrawRequest: WithdrawRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'withdrawRequest' is not null or undefined
            assertParamExists('postWithdraw', 'withdrawRequest', withdrawRequest)
            const localVarPath = `/api/v1/trade/withdraw`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(withdrawRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Adjust margin for an isolated position on a specific market.
         * @summary /trade/adjustIsolatedMargin
         * @param {AdjustIsolatedMarginRequest} adjustIsolatedMarginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putAdjustIsolatedMargin: async (adjustIsolatedMarginRequest: AdjustIsolatedMarginRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'adjustIsolatedMarginRequest' is not null or undefined
            assertParamExists('putAdjustIsolatedMargin', 'adjustIsolatedMarginRequest', adjustIsolatedMarginRequest)
            const localVarPath = `/api/v1/trade/adjustIsolatedMargin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(adjustIsolatedMarginRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Authorizes an account to trade, perform liquidations and more, on behalf of another account.
         * @summary /trade/accounts/authorize
         * @param {AccountAuthorizationRequest} accountAuthorizationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putAuthorizeAccount: async (accountAuthorizationRequest: AccountAuthorizationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountAuthorizationRequest' is not null or undefined
            assertParamExists('putAuthorizeAccount', 'accountAuthorizationRequest', accountAuthorizationRequest)
            const localVarPath = `/api/v1/trade/accounts/authorize`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accountAuthorizationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deauthorizes an account to trade, perform liquidations and more, on behalf of another account.
         * @summary /trade/accounts/deauthorize
         * @param {AccountAuthorizationRequest} accountAuthorizationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putDeauthorizeAccount: async (accountAuthorizationRequest: AccountAuthorizationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountAuthorizationRequest' is not null or undefined
            assertParamExists('putDeauthorizeAccount', 'accountAuthorizationRequest', accountAuthorizationRequest)
            const localVarPath = `/api/v1/trade/accounts/deauthorize`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accountAuthorizationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates leverage for positions of a given market and closes all open orders for that market.
         * @summary /trade/leverage
         * @param {AccountPositionLeverageUpdateRequest} accountPositionLeverageUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putLeverageUpdate: async (accountPositionLeverageUpdateRequest: AccountPositionLeverageUpdateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'accountPositionLeverageUpdateRequest' is not null or undefined
            assertParamExists('putLeverageUpdate', 'accountPositionLeverageUpdateRequest', accountPositionLeverageUpdateRequest)
            const localVarPath = `/api/v1/trade/leverage`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(accountPositionLeverageUpdateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TradeApi - functional programming interface
 * @export
 */
export const TradeApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TradeApiAxiosParamCreator(configuration)
    return {
        /**
         * Cancel orders for a market using order hashes. - May be a single order hash or a list of order hashes. - All orders must belong to the same account. - If no order hashes are specified, then will cancel all orders for the given market  - All orders being cancelled by request will receive the same time priority. 
         * @summary /trade/orders/cancel
         * @param {CancelOrdersRequest} cancelOrdersRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelOrders(cancelOrdersRequest: CancelOrdersRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelOrders(cancelOrdersRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.cancelOrders']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Cancel orders in standby for a market using order hashes. - May be a single order hash or a list of order hashes. - All orders must belong to the same account. - If no order hashes are specified, then will cancel all orders for the given market - All orders being cancelled by request will receive the same time priority. 
         * @summary /trade/orders/cancel/standby
         * @param {CancelOrdersRequest} cancelOrdersRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelStandbyOrders(cancelOrdersRequest: CancelOrdersRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CancelOrdersResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelStandbyOrders(cancelOrdersRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.cancelStandbyOrders']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve details of open orders for a specific account.
         * @summary /trade/openOrders
         * @param {string} [symbol] Filter by specific perpetual symbol (optional)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOpenOrders(symbol?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OpenOrderResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOpenOrders(symbol, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.getOpenOrders']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Retrieve details of orders in standby for a specific account.
         * @summary /trade/standbyOrders
         * @param {string} [symbol] Filter by specific perpetual symbol (optional)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStandbyOrders(symbol?: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OpenOrderResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStandbyOrders(symbol, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.getStandbyOrders']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Submit a new order for execution.
         * @summary /trade/orders
         * @param {CreateOrderRequest} createOrderRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postCreateOrder(createOrderRequest: CreateOrderRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateOrderResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postCreateOrder(createOrderRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.postCreateOrder']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Initiates a withdraw action to remove some amount of funds from a user\'s account.
         * @summary /trade/withdraw
         * @param {WithdrawRequest} withdrawRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async postWithdraw(withdrawRequest: WithdrawRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.postWithdraw(withdrawRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.postWithdraw']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Adjust margin for an isolated position on a specific market.
         * @summary /trade/adjustIsolatedMargin
         * @param {AdjustIsolatedMarginRequest} adjustIsolatedMarginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putAdjustIsolatedMargin(adjustIsolatedMarginRequest: AdjustIsolatedMarginRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putAdjustIsolatedMargin(adjustIsolatedMarginRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.putAdjustIsolatedMargin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Authorizes an account to trade, perform liquidations and more, on behalf of another account.
         * @summary /trade/accounts/authorize
         * @param {AccountAuthorizationRequest} accountAuthorizationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putAuthorizeAccount(accountAuthorizationRequest: AccountAuthorizationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putAuthorizeAccount(accountAuthorizationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.putAuthorizeAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Deauthorizes an account to trade, perform liquidations and more, on behalf of another account.
         * @summary /trade/accounts/deauthorize
         * @param {AccountAuthorizationRequest} accountAuthorizationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putDeauthorizeAccount(accountAuthorizationRequest: AccountAuthorizationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putDeauthorizeAccount(accountAuthorizationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.putDeauthorizeAccount']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Updates leverage for positions of a given market and closes all open orders for that market.
         * @summary /trade/leverage
         * @param {AccountPositionLeverageUpdateRequest} accountPositionLeverageUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async putLeverageUpdate(accountPositionLeverageUpdateRequest: AccountPositionLeverageUpdateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.putLeverageUpdate(accountPositionLeverageUpdateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TradeApi.putLeverageUpdate']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TradeApi - factory interface
 * @export
 */
export const TradeApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TradeApiFp(configuration)
    return {
        /**
         * Cancel orders for a market using order hashes. - May be a single order hash or a list of order hashes. - All orders must belong to the same account. - If no order hashes are specified, then will cancel all orders for the given market  - All orders being cancelled by request will receive the same time priority. 
         * @summary /trade/orders/cancel
         * @param {CancelOrdersRequest} cancelOrdersRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelOrders(cancelOrdersRequest: CancelOrdersRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.cancelOrders(cancelOrdersRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Cancel orders in standby for a market using order hashes. - May be a single order hash or a list of order hashes. - All orders must belong to the same account. - If no order hashes are specified, then will cancel all orders for the given market - All orders being cancelled by request will receive the same time priority. 
         * @summary /trade/orders/cancel/standby
         * @param {CancelOrdersRequest} cancelOrdersRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelStandbyOrders(cancelOrdersRequest: CancelOrdersRequest, options?: RawAxiosRequestConfig): AxiosPromise<CancelOrdersResponse> {
            return localVarFp.cancelStandbyOrders(cancelOrdersRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve details of open orders for a specific account.
         * @summary /trade/openOrders
         * @param {string} [symbol] Filter by specific perpetual symbol (optional)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOpenOrders(symbol?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<OpenOrderResponse>> {
            return localVarFp.getOpenOrders(symbol, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve details of orders in standby for a specific account.
         * @summary /trade/standbyOrders
         * @param {string} [symbol] Filter by specific perpetual symbol (optional)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStandbyOrders(symbol?: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<OpenOrderResponse>> {
            return localVarFp.getStandbyOrders(symbol, options).then((request) => request(axios, basePath));
        },
        /**
         * Submit a new order for execution.
         * @summary /trade/orders
         * @param {CreateOrderRequest} createOrderRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postCreateOrder(createOrderRequest: CreateOrderRequest, options?: RawAxiosRequestConfig): AxiosPromise<CreateOrderResponse> {
            return localVarFp.postCreateOrder(createOrderRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Initiates a withdraw action to remove some amount of funds from a user\'s account.
         * @summary /trade/withdraw
         * @param {WithdrawRequest} withdrawRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        postWithdraw(withdrawRequest: WithdrawRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.postWithdraw(withdrawRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Adjust margin for an isolated position on a specific market.
         * @summary /trade/adjustIsolatedMargin
         * @param {AdjustIsolatedMarginRequest} adjustIsolatedMarginRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putAdjustIsolatedMargin(adjustIsolatedMarginRequest: AdjustIsolatedMarginRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.putAdjustIsolatedMargin(adjustIsolatedMarginRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Authorizes an account to trade, perform liquidations and more, on behalf of another account.
         * @summary /trade/accounts/authorize
         * @param {AccountAuthorizationRequest} accountAuthorizationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putAuthorizeAccount(accountAuthorizationRequest: AccountAuthorizationRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.putAuthorizeAccount(accountAuthorizationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Deauthorizes an account to trade, perform liquidations and more, on behalf of another account.
         * @summary /trade/accounts/deauthorize
         * @param {AccountAuthorizationRequest} accountAuthorizationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putDeauthorizeAccount(accountAuthorizationRequest: AccountAuthorizationRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.putDeauthorizeAccount(accountAuthorizationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates leverage for positions of a given market and closes all open orders for that market.
         * @summary /trade/leverage
         * @param {AccountPositionLeverageUpdateRequest} accountPositionLeverageUpdateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        putLeverageUpdate(accountPositionLeverageUpdateRequest: AccountPositionLeverageUpdateRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.putLeverageUpdate(accountPositionLeverageUpdateRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TradeApi - object-oriented interface
 * @export
 * @class TradeApi
 * @extends {BaseAPI}
 */
export class TradeApi extends BaseAPI {
    /**
     * Cancel orders for a market using order hashes. - May be a single order hash or a list of order hashes. - All orders must belong to the same account. - If no order hashes are specified, then will cancel all orders for the given market  - All orders being cancelled by request will receive the same time priority. 
     * @summary /trade/orders/cancel
     * @param {CancelOrdersRequest} cancelOrdersRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public cancelOrders(cancelOrdersRequest: CancelOrdersRequest, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).cancelOrders(cancelOrdersRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Cancel orders in standby for a market using order hashes. - May be a single order hash or a list of order hashes. - All orders must belong to the same account. - If no order hashes are specified, then will cancel all orders for the given market - All orders being cancelled by request will receive the same time priority. 
     * @summary /trade/orders/cancel/standby
     * @param {CancelOrdersRequest} cancelOrdersRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public cancelStandbyOrders(cancelOrdersRequest: CancelOrdersRequest, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).cancelStandbyOrders(cancelOrdersRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve details of open orders for a specific account.
     * @summary /trade/openOrders
     * @param {string} [symbol] Filter by specific perpetual symbol (optional)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public getOpenOrders(symbol?: string, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).getOpenOrders(symbol, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve details of orders in standby for a specific account.
     * @summary /trade/standbyOrders
     * @param {string} [symbol] Filter by specific perpetual symbol (optional)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public getStandbyOrders(symbol?: string, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).getStandbyOrders(symbol, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Submit a new order for execution.
     * @summary /trade/orders
     * @param {CreateOrderRequest} createOrderRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public postCreateOrder(createOrderRequest: CreateOrderRequest, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).postCreateOrder(createOrderRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Initiates a withdraw action to remove some amount of funds from a user\'s account.
     * @summary /trade/withdraw
     * @param {WithdrawRequest} withdrawRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public postWithdraw(withdrawRequest: WithdrawRequest, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).postWithdraw(withdrawRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Adjust margin for an isolated position on a specific market.
     * @summary /trade/adjustIsolatedMargin
     * @param {AdjustIsolatedMarginRequest} adjustIsolatedMarginRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public putAdjustIsolatedMargin(adjustIsolatedMarginRequest: AdjustIsolatedMarginRequest, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).putAdjustIsolatedMargin(adjustIsolatedMarginRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Authorizes an account to trade, perform liquidations and more, on behalf of another account.
     * @summary /trade/accounts/authorize
     * @param {AccountAuthorizationRequest} accountAuthorizationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public putAuthorizeAccount(accountAuthorizationRequest: AccountAuthorizationRequest, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).putAuthorizeAccount(accountAuthorizationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Deauthorizes an account to trade, perform liquidations and more, on behalf of another account.
     * @summary /trade/accounts/deauthorize
     * @param {AccountAuthorizationRequest} accountAuthorizationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public putDeauthorizeAccount(accountAuthorizationRequest: AccountAuthorizationRequest, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).putDeauthorizeAccount(accountAuthorizationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates leverage for positions of a given market and closes all open orders for that market.
     * @summary /trade/leverage
     * @param {AccountPositionLeverageUpdateRequest} accountPositionLeverageUpdateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TradeApi
     */
    public putLeverageUpdate(accountPositionLeverageUpdateRequest: AccountPositionLeverageUpdateRequest, options?: RawAxiosRequestConfig) {
        return TradeApiFp(this.configuration).putLeverageUpdate(accountPositionLeverageUpdateRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



