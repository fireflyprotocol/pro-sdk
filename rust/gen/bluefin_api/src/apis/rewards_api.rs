/*
 * Bluefin API
 *
 * Bluefin API
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`get_affiliate_interval_overview`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAffiliateIntervalOverviewError {
    Status401(models::Error),
    Status404(models::Error),
    Status400(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_affiliate_leader_dashboard`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAffiliateLeaderDashboardError {
    Status401(models::Error),
    Status404(models::Error),
    Status400(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_affiliate_metadata`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAffiliateMetadataError {
    Status401(models::Error),
    Status404(models::Error),
    Status400(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_affiliate_overview`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAffiliateOverviewError {
    Status401(models::Error),
    Status404(models::Error),
    Status400(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_affiliate_summary`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAffiliateSummaryError {
    Status401(models::Error),
    Status404(models::Error),
    Status400(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_campaign_rewards`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetCampaignRewardsError {
    Status400(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_rewards`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetRewardsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_rewards_campaign_metadata`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetRewardsCampaignMetadataError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_rewards_epoch_config_metadata`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetRewardsEpochConfigMetadataError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_rewards_epoch_metadata`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetRewardsEpochMetadataError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_rewards_interval_metadata`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetRewardsIntervalMetadataError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_rewards_summary`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetRewardsSummaryError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`onboard_affiliate`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OnboardAffiliateError {
    Status401(models::Error),
    Status404(models::Error),
    Status400(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`onboard_referee`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum OnboardRefereeError {
    Status401(models::Error),
    Status404(models::Error),
    Status400(models::Error),
    Status412(models::Error),
    Status409(models::Error),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`update_affiliate_fee_config`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UpdateAffiliateFeeConfigError {
    Status401(models::Error),
    Status404(models::Error),
    Status400(models::Error),
    Status500(models::Error),
    UnknownValue(serde_json::Value),
}


/// Returns detailed earnings breakdown for an affiliate by interval, ordered by interval number in descending order.
pub async fn get_affiliate_interval_overview(configuration: &configuration::Configuration, user_address: &str, page: Option<u32>, limit: Option<u32>) -> Result<models::GetAffiliateIntervalOverview200Response, Error<GetAffiliateIntervalOverviewError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_user_address = user_address;
    let p_page = page;
    let p_limit = limit;

    let uri_str = format!("{}/v1/rewards/affiliate/intervalOverview", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("userAddress", &p_user_address.to_string())]);
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetAffiliateIntervalOverview200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetAffiliateIntervalOverview200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetAffiliateIntervalOverviewError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns rankings and earnings for affiliates, sorted by the specified category.
pub async fn get_affiliate_leader_dashboard(configuration: &configuration::Configuration, sort_by: Option<&str>, sort_order: Option<&str>, page: Option<u32>, limit: Option<u32>, search: Option<&str>) -> Result<models::GetAffiliateLeaderDashboard200Response, Error<GetAffiliateLeaderDashboardError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_sort_by = sort_by;
    let p_sort_order = sort_order;
    let p_page = page;
    let p_limit = limit;
    let p_search = search;

    let uri_str = format!("{}/v1/rewards/affiliate/leaderDashboard", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_sort_by {
        req_builder = req_builder.query(&[("sortBy", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_sort_order {
        req_builder = req_builder.query(&[("sortOrder", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_search {
        req_builder = req_builder.query(&[("search", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetAffiliateLeaderDashboard200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetAffiliateLeaderDashboard200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetAffiliateLeaderDashboardError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns the affiliate metadata.
pub async fn get_affiliate_metadata(configuration: &configuration::Configuration, user_address: &str) -> Result<models::AffiliateMetadata, Error<GetAffiliateMetadataError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_user_address = user_address;

    let uri_str = format!("{}/v1/rewards/affiliate", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("userAddress", &p_user_address.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AffiliateMetadata`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AffiliateMetadata`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetAffiliateMetadataError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns detailed earnings breakdown for an affiliate users earnings (including perps, spot LP, lending), referral earnings, and total earnings.
pub async fn get_affiliate_overview(configuration: &configuration::Configuration, user_address: &str, page: Option<u32>, limit: Option<u32>, sort_by: Option<&str>, sort_order: Option<&str>, search: Option<&str>, min_earnings_e9: Option<&str>) -> Result<models::GetAffiliateOverview200Response, Error<GetAffiliateOverviewError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_user_address = user_address;
    let p_page = page;
    let p_limit = limit;
    let p_sort_by = sort_by;
    let p_sort_order = sort_order;
    let p_search = search;
    let p_min_earnings_e9 = min_earnings_e9;

    let uri_str = format!("{}/v1/rewards/affiliate/overview", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_page {
        req_builder = req_builder.query(&[("page", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_sort_by {
        req_builder = req_builder.query(&[("sortBy", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_sort_order {
        req_builder = req_builder.query(&[("sortOrder", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_search {
        req_builder = req_builder.query(&[("search", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("userAddress", &p_user_address.to_string())]);
    if let Some(ref param_value) = p_min_earnings_e9 {
        req_builder = req_builder.query(&[("minEarningsE9", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetAffiliateOverview200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetAffiliateOverview200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetAffiliateOverviewError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns performance summary for an affiliate including total referrals, earnings, and rankings.
pub async fn get_affiliate_summary(configuration: &configuration::Configuration, user_address: &str) -> Result<models::AffiliateSummary, Error<GetAffiliateSummaryError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_user_address = user_address;

    let uri_str = format!("{}/v1/rewards/affiliate/summary", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("userAddress", &p_user_address.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AffiliateSummary`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AffiliateSummary`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetAffiliateSummaryError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns the rewards earned by users for a specific campaign.
pub async fn get_campaign_rewards(configuration: &configuration::Configuration, campaign_name: &str, user_address: &str, epoch_number: Option<i32>) -> Result<Vec<models::UserCampaignRewards>, Error<GetCampaignRewardsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_campaign_name = campaign_name;
    let p_user_address = user_address;
    let p_epoch_number = epoch_number;

    let uri_str = format!("{}/v1/rewards/campaign", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("campaignName", &p_campaign_name.to_string())]);
    if let Some(ref param_value) = p_epoch_number {
        req_builder = req_builder.query(&[("epochNumber", &param_value.to_string())]);
    }
    req_builder = req_builder.query(&[("userAddress", &p_user_address.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::UserCampaignRewards&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::UserCampaignRewards&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetCampaignRewardsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns the rewards earned by users for the intervals.
pub async fn get_rewards(configuration: &configuration::Configuration, interval_number: Option<i32>) -> Result<Vec<models::IntervalRewards>, Error<GetRewardsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_interval_number = interval_number;

    let uri_str = format!("{}/v1/rewards", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_interval_number {
        req_builder = req_builder.query(&[("intervalNumber", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::IntervalRewards&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::IntervalRewards&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetRewardsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns the metadata for the rewards campaigns.
pub async fn get_rewards_campaign_metadata(configuration: &configuration::Configuration, campaign_name: Option<&str>, status: Option<&str>) -> Result<Vec<models::CampaignMetadata>, Error<GetRewardsCampaignMetadataError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_campaign_name = campaign_name;
    let p_status = status;

    let uri_str = format!("{}/v1/rewards/metadata/campaign", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_campaign_name {
        req_builder = req_builder.query(&[("campaignName", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_status {
        req_builder = req_builder.query(&[("Status", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::CampaignMetadata&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::CampaignMetadata&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetRewardsCampaignMetadataError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns the latest epoch configs for the campaigns.
pub async fn get_rewards_epoch_config_metadata(configuration: &configuration::Configuration, ) -> Result<Vec<models::EpochConfigs>, Error<GetRewardsEpochConfigMetadataError>> {

    let uri_str = format!("{}/v1/rewards/metadata/epoch/configs", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::EpochConfigs&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::EpochConfigs&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetRewardsEpochConfigMetadataError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns the latest or next epoch epoch for campaign.
pub async fn get_rewards_epoch_metadata(configuration: &configuration::Configuration, campaign_name: Option<&str>, epoch: Option<&str>) -> Result<Vec<models::EpochMetadata>, Error<GetRewardsEpochMetadataError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_campaign_name = campaign_name;
    let p_epoch = epoch;

    let uri_str = format!("{}/v1/rewards/metadata/epoch", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_campaign_name {
        req_builder = req_builder.query(&[("campaignName", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_epoch {
        req_builder = req_builder.query(&[("epoch", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::EpochMetadata&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::EpochMetadata&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetRewardsEpochMetadataError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns the interval metadata for provided parameters.
pub async fn get_rewards_interval_metadata(configuration: &configuration::Configuration, interval: Option<i32>) -> Result<Vec<models::IntervalMetadata>, Error<GetRewardsIntervalMetadataError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_interval = interval;

    let uri_str = format!("{}/v1/rewards/metadata/interval", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_interval {
        req_builder = req_builder.query(&[("interval", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::IntervalMetadata&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::IntervalMetadata&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetRewardsIntervalMetadataError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns the all time rewards earned by users.
pub async fn get_rewards_summary(configuration: &configuration::Configuration, ) -> Result<Vec<models::RewardsSummary>, Error<GetRewardsSummaryError>> {

    let uri_str = format!("{}/v1/rewards/summary", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `Vec&lt;models::RewardsSummary&gt;`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `Vec&lt;models::RewardsSummary&gt;`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetRewardsSummaryError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Submit an application to become an affiliate.
pub async fn onboard_affiliate(configuration: &configuration::Configuration, onboard_affiliate_request: models::OnboardAffiliateRequest) -> Result<models::AffiliateOnboardResponse, Error<OnboardAffiliateError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_onboard_affiliate_request = onboard_affiliate_request;

    let uri_str = format!("{}/v1/rewards/affiliate/onboard", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_onboard_affiliate_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AffiliateOnboardResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AffiliateOnboardResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<OnboardAffiliateError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Onboard a referee with a referral code.
pub async fn onboard_referee(configuration: &configuration::Configuration, onboard_referee_request: models::OnboardRefereeRequest) -> Result<models::RefereeOnboardResponse, Error<OnboardRefereeError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_onboard_referee_request = onboard_referee_request;

    let uri_str = format!("{}/v1/rewards/affiliate/onboard/referee", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_onboard_referee_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::RefereeOnboardResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::RefereeOnboardResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<OnboardRefereeError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Update the fee config for an affiliate.
pub async fn update_affiliate_fee_config(configuration: &configuration::Configuration, update_affiliate_fee_config_request: models::UpdateAffiliateFeeConfigRequest) -> Result<models::AffiliateMetadata, Error<UpdateAffiliateFeeConfigError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_update_affiliate_fee_config_request = update_affiliate_fee_config_request;

    let uri_str = format!("{}/v1/rewards/affiliate/feeConfig", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_update_affiliate_fee_config_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AffiliateMetadata`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AffiliateMetadata`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UpdateAffiliateFeeConfigError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

